This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-25T20:54:04.478Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
backend/
  api/
    app.py
    errors.py
    routes.py
    services.py
  migrations/
    add_status_column.py
    migrate_receipt_data.py
    run_migrations.py
  models/
    __init__.py
    create_db.py
    database.py
    receipt.py
  scripts/
    recreate_db.py
  services/
    categorization_service.py
    categorization.py
    ocr_service_with_tessaract_not_working.py
    ocr_service.py
  src/
    index.ts
  tests/
    __init__.py
    base.py
    config.py
    conftest_integration.py
    conftest.py
    test_api_integration.py
    test_api_options.py
    test_api.py
    test_categorization.py
    test_config.py
    test_models.py
    test_receipt_updates.py
    test_upload.py
  __init__.py
  app.py
  clean_receipts.py
  config.py
  init_db.py
  pytest.ini
  repomix-output.txt
  requirements.txt
  run_tests.py
frontend/
  components/
    common/
      DialogWrapper.tsx
      ErrorMessage.tsx
      index.ts
      LoadingSpinner.tsx
    Documents/
      DocumentFilters.tsx
      DocumentsFilters.tsx
      DocumentsTable.tsx
      DocumentsTabs.tsx
      DocumentUploadArea.tsx
      DocumentUploadFab.tsx
      EditableCell.tsx
      ExpenseFilters.tsx
    GlobalHeader/
      GlobalHeader.tsx
    Layout/
      Layout.tsx
    LeftNav/
      LeftNav.tsx
    ErrorBoundary.tsx
    ImageViewer.tsx
    JsonViewer.tsx
    ReceiptDetail.tsx
    ReceiptList.tsx
    ReceiptTable.tsx
    ReceiptUploader.tsx
    UploadArea.tsx
  config/
    index.ts
  contexts/
    AppContext.tsx
    index.ts
    SearchContext.tsx
  hooks/
    useDocumentManagement.ts
    useSearch.ts
  lib/
    api/
      documents.ts
    api.ts
    createEmotionCache.ts
  pages/
    receipt/
      [id].tsx
    _app.tsx
    1040.tsx
    dashboard.tsx
    documents.tsx
    index.tsx
    profile.tsx
  styles/
    globals.css
    theme.ts
  types/
    documents.ts
    filters.ts
    index.ts
  .env.development
  .eslintrc.js
  .gitignore
  config.ts
  next.config.js
  package.json
  tsconfig.json
.gitignore
next.config.js
README.md

================================================================
Repository Files
================================================================

================
File: backend/api/app.py
================
from flask import Flask
from werkzeug.exceptions import HTTPException
from .errors import APIError, handle_api_error, handle_http_error, handle_generic_error

app = Flask(__name__)

# Register error handlers
app.register_error_handler(APIError, handle_api_error)
app.register_error_handler(HTTPException, handle_http_error)
app.register_error_handler(Exception, handle_generic_error)

# ... rest of app configuration

================
File: backend/api/errors.py
================
import logging
from typing import Dict, Any, Optional
from flask import jsonify
from werkzeug.exceptions import HTTPException

logger = logging.getLogger(__name__)

class APIError(Exception):
    """Base exception class for API errors"""
    def __init__(self, message: str, status_code: int = 400, details: Optional[Dict[str, Any]] = None):
        super().__init__()
        self.message = message
        self.status_code = status_code
        self.details = details or {}

    def to_dict(self) -> Dict[str, Any]:
        response = {
            'error': True,
            'message': self.message,
            'status_code': self.status_code
        }
        if self.details:
            response['details'] = self.details
        return response

def handle_api_error(error: APIError):
    """Handler for our custom APIError exceptions"""
    logger.error(f"API Error: {error.message}", extra={
        'status_code': error.status_code,
        'details': error.details
    })
    response = jsonify(error.to_dict())
    response.status_code = error.status_code
    return response

def handle_http_error(error: HTTPException):
    """Handler for Werkzeug HTTP exceptions"""
    logger.error(f"HTTP Error: {error.description}", extra={
        'status_code': error.code
    })
    response = jsonify({
        'error': True,
        'message': error.description,
        'status_code': error.code
    })
    response.status_code = error.code
    return response

def handle_generic_error(error: Exception):
    """Handler for unexpected exceptions"""
    logger.exception("Unexpected error occurred")
    response = jsonify({
        'error': True,
        'message': 'An unexpected error occurred',
        'status_code': 500
    })
    response.status_code = 500
    return response

================
File: backend/api/routes.py
================
from flask import Blueprint, request, jsonify, current_app, send_from_directory
from werkzeug.utils import secure_filename
import os
import logging
from models.database import get_db, Receipt, ReceiptChangeHistory
from services.ocr_service import OCRService
from services.categorization_service import CategorizationService
import uuid
from PIL import Image
from datetime import datetime
from config import config
from functools import wraps
from http import HTTPStatus
from decimal import Decimal, InvalidOperation
import time
from .errors import APIError

# Configure logging
logger = logging.getLogger('api.routes')

api_bp = Blueprint('api', __name__)

def verify_image(filepath):
    """Verify image was saved correctly"""
    try:
        with Image.open(filepath) as img:
            logger.info(f"Image verified: {filepath} ({img.size}, {img.mode})")
            return True
    except Exception as e:
        logger.error(f"Image verification failed: {str(e)}")
        return False

def validate_request(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not request.is_json:
            raise APIError(
                "Request must be JSON",
                status_code=400,
                details={'content_type': request.content_type}
            )
        return f(*args, **kwargs)
    return decorated_function

def validate_field_values(data, receipt_id):
    errors = {}
    
    # Validate vendor
    if 'vendor' in data:
        if not isinstance(data['vendor'], str) or len(data['vendor']) > 100:
            errors['vendor'] = "Vendor must be a string of max 100 characters"
    
    # Validate amount
    if 'amount' in data:
        try:
            amount = Decimal(data['amount'])
            if amount <= 0 or amount > Decimal('999999.99'):
                errors['amount'] = "Amount must be between 0.01 and 999999.99"
        except InvalidOperation:
            errors['amount'] = "Amount must be a valid decimal number"
    
    # Validate date
    if 'date' in data:
        try:
            logger.info(f"Validating date field. Raw value: {data['date']!r}, Type: {type(data['date'])}")
            
            if not data['date']:
                logger.info("Empty date value received")
                return {'date': "Date cannot be empty"}
                
            date = datetime.strptime(data['date'], '%Y-%m-%d').date()
            logger.info(f"Successfully parsed date: {date}")
            
            if date > datetime.now().date():
                logger.error(f"Future date not allowed: {date}")
                return {'date': "Date cannot be in the future"}
                
            logger.info(f"Date validation successful: {date}")
            
        except ValueError as e:
            logger.error(f"Date validation error: {str(e)}, received value: {data['date']!r}, type: {type(data['date'])}")
            return {'date': "Date must be in YYYY-MM-DD format"}
        except Exception as e:
            logger.error(f"Unexpected error validating date: {str(e)}, received value: {data['date']!r}, type: {type(data['date'])}")
            return {'date': "Invalid date format"}
    
    # Validate category - case insensitive
    if 'category' in data:
        category = data['category'].lower()
        if category not in [cat.lower() for cat in config.expense_categories]:
            errors['category'] = f"Category must be one of: {', '.join(config.expense_categories)}"
    
    # Validate payment_method - case insensitive
    if 'payment_method' in data:
        payment_method = data['payment_method'].lower()
        if payment_method not in [pm.lower() for pm in config.payment_methods]:
            errors['payment_method'] = f"Payment method must be one of: {', '.join(config.payment_methods)}"
    
    # Validate status - case insensitive and transitions
    if 'status' in data:
        new_status = data['status'].lower()
        if new_status not in [status.lower() for status in config.receipt_statuses]:
            errors['status'] = f"Status must be one of: {', '.join(config.receipt_statuses)}"
        else:
            # Get current status if updating an existing receipt
            try:
                with get_db() as db:
                    receipt = db.query(Receipt).get(receipt_id)
                    if receipt:
                        current_status = receipt.status.lower()
                        valid_transition = False
                        
                        if current_status == 'pending':
                            valid_transition = new_status in ['approved', 'rejected']
                        elif current_status == 'approved':
                            valid_transition = new_status in ['pending', 'rejected']
                        elif current_status == 'rejected':
                            valid_transition = new_status in ['approved', 'pending']
                            
                        if not valid_transition:
                            errors['status'] = f"Invalid status transition from {current_status} to {new_status}"
            except Exception as e:
                logger.error(f"Error checking status transition: {str(e)}")
    
    return errors

@api_bp.route('/upload', methods=['POST'])
def upload_file():
    logger.info("Received upload request")
    try:
        if 'file' not in request.files:
            raise APIError("No file part in request", status_code=400)
        
        file = request.files['file']
        if file.filename == '':
            raise APIError("No selected file", status_code=400)
        
        logger.info(f"Processing file: {file.filename}")
        
        # Generate unique filename
        original_filename = secure_filename(file.filename)
        saved_filename = f"{uuid.uuid4()}_{original_filename}"
        filepath = os.path.join(current_app.config['UPLOAD_FOLDER'], saved_filename)
        
        # Save file
        file.save(filepath)
        logger.info(f"File saved to: {filepath}")
        
        # Verify image
        if not verify_image(filepath):
            raise APIError("Failed to verify saved image", status_code=400)
        
        try:
            # Process with OCR
            ocr_result = OCRService.extract_receipt_data(filepath)
            receipt_data = ocr_result['content']
            logger.info(f"Receipt data: {receipt_data}")
            
            # Add categorization step
            try:
                category = CategorizationService.categorize_receipt(receipt_data)
                logger.info(f"Categorized as: {category}")
            except Exception as e:
                logger.error(f"Categorization error: {str(e)}")
                category = "Other expenses"
            
            # Save to database
            with get_db() as db:
                receipt = Receipt(
                    image_path=saved_filename,
                    content=receipt_data,
                    category=category,
                    vendor=receipt_data.get('Vendor', ''),
                    amount=receipt_data.get('Amount', '0.00'),
                    date=receipt_data.get('Date', ''),
                    payment_method=receipt_data.get('Payment_Method', ''),
                    status='pending'
                )
                db.add(receipt)
                db.commit()
                
                return jsonify(receipt.to_dict())
                
        except Exception as e:
            # Clean up file if processing failed
            try:
                os.remove(filepath)
            except:
                pass
            logger.error(f"Processing error: {str(e)}")
            raise APIError("Failed to process receipt", status_code=500, details={'error': str(e)})
        
    except APIError:
        raise
    except Exception as e:
        logger.error(f"Upload error: {str(e)}")
        raise APIError("Failed to upload receipt", status_code=500, details={'error': str(e)})

@api_bp.route('/receipts', methods=['GET'])
def get_receipts():
    start_time = time.time()
    try:
        with get_db() as db:
            receipts = db.query(Receipt).all()
            return jsonify([r.to_dict() for r in receipts])
    except Exception as e:
        logger.error(f"Failed to get receipts: {str(e)}")
        raise APIError("Failed to fetch receipts", status_code=500, details={'error': str(e)})
    finally:
        execution_time = time.time() - start_time
        logger.info(f"Execution time for get_receipts: {execution_time:.2f} seconds")

@api_bp.route('/receipts/<int:receipt_id>', methods=['GET'])
def get_receipt(receipt_id):
    """Get a single receipt by ID"""
    try:
        with get_db() as db:
            receipt = db.query(Receipt).get(receipt_id)
            if not receipt:
                raise APIError("Receipt not found", status_code=404)
            return jsonify(receipt.to_dict())
    except APIError:
        raise
    except Exception as e:
        logger.error(f"Failed to get receipt {receipt_id}: {str(e)}")
        raise APIError("Failed to fetch receipt", status_code=500)

@api_bp.route('/receipts/<int:receipt_id>/update', methods=['PATCH'])
@validate_request
def update_receipt_fields(receipt_id):
    data = request.get_json()

    # Validate input data
    validation_errors = validate_field_values(data, receipt_id)
    if validation_errors:
        raise APIError(
            "Invalid field values",
            status_code=400,
            details=validation_errors
        )

    try:
        with get_db() as db:
            receipt = db.query(Receipt).get(receipt_id)
            if not receipt:
                raise APIError("Receipt not found", status_code=404)

            # Track changes and update fields
            updated_fields = {}
            for field in ['vendor', 'amount', 'date', 'payment_method', 'category', 'status']:
                # Only update fields present in the request data
                if field in data:
                    old_value = getattr(receipt, field)
                    new_value = data[field].lower() if field == 'status' else data[field]

                    if old_value != new_value:
                        # Create change history record
                        change = ReceiptChangeHistory(
                            receipt_id=receipt_id,
                            field_name=field,
                            new_value=new_value,
                            changed_at=datetime.utcnow(),
                            changed_by="system"  # Replace with actual user ID when auth is implemented
                        )
                        db.add(change)

                        # Update receipt field
                        setattr(receipt, field, new_value)
                        updated_fields[field] = new_value

            # Commit the changes
            db.commit()

            # Return the full receipt data, preserving all fields
            receipt_data = {
                "id": receipt.id,
                "image_path": receipt.image_path,
                "vendor": receipt.vendor,
                "amount": receipt.amount,
                "date": receipt.date,
                "payment_method": receipt.payment_method,
                "category": receipt.category,
                "status": receipt.status,
                "content": receipt.content,
            }

            return jsonify({
                "success": True,
                "receipt_id": receipt_id,
                "updated_fields": updated_fields,
                "updated_at": datetime.utcnow().isoformat(),
                "receipt": receipt_data,
            }), HTTPStatus.OK

    except APIError:
        raise
    except Exception as e:
        logger.error(f"Failed to update receipt {receipt_id}: {str(e)}")
        raise APIError(
            "Failed to update receipt",
            status_code=500,
            details={'error': str(e)}
        )

@api_bp.route('/receipts/<int:receipt_id>', methods=['DELETE'])
def delete_receipt(receipt_id):
    """Delete a receipt"""
    try:
        with get_db() as db:
            receipt = db.query(Receipt).get(receipt_id)
            if not receipt:
                raise APIError("Receipt not found", status_code=404)

            # Delete image file
            try:
                image_path = os.path.join(current_app.config['UPLOAD_FOLDER'], receipt.image_path)
                if os.path.exists(image_path):
                    os.remove(image_path)
                    logger.info(f"Deleted image file: {image_path}")
            except Exception as e:
                logger.error(f"Failed to delete image: {str(e)}")
                raise APIError("Failed to delete image file", status_code=500)

            # Delete database record
            db.delete(receipt)
            logger.info(f"Deleted receipt: {receipt_id}")
            
            return jsonify({'message': 'Receipt deleted successfully'})
            
    except APIError:
        raise
    except Exception as e:
        logger.error(f"Failed to delete receipt {receipt_id}: {str(e)}")
        raise APIError("Failed to delete receipt", status_code=500)

@api_bp.route('/images/<path:filename>')
def get_image(filename):
    """Serve receipt images"""
    return send_from_directory(current_app.config['UPLOAD_FOLDER'], filename)

@api_bp.route('/receipts/<int:receipt_id>/history', methods=['GET'])
def get_receipt_history(receipt_id):
    try:
        with get_db() as db:
            # Verify receipt exists
            receipt = db.query(Receipt).get(receipt_id)
            if not receipt:
                raise APIError("Receipt not found", status_code=404)

            # Get changes ordered by timestamp
            changes = db.query(ReceiptChangeHistory)\
                       .filter(ReceiptChangeHistory.receipt_id == receipt_id)\
                       .order_by(ReceiptChangeHistory.changed_at.desc())\
                       .all()

            return jsonify([{
                'field': change.field_name,
                'new_value': change.new_value,
                'changed_at': change.changed_at.isoformat(),
                'changed_by': change.changed_by
            } for change in changes])

    except APIError:
        raise
    except Exception as e:
        logger.error(f"Failed to get history for receipt {receipt_id}: {str(e)}")
        raise APIError("Failed to fetch receipt history", status_code=500, details={'error': str(e)})

@api_bp.route('/process', methods=['POST'])
def process_document():
    try:
        if not request.files:
            raise APIError("No file provided", status_code=400)

        file = request.files.get('file')
        if not file:
            raise APIError("File field is required", status_code=400)

        # Validate file type
        if not allowed_file(file.filename):
            raise APIError(
                "Invalid file type", 
                status_code=400, 
                details={'allowed_types': ALLOWED_EXTENSIONS}
            )

        # Process the document
        result = ocr_service.process(file)
        
        logger.info("Document processed successfully", extra={
            'filename': file.filename,
            'result_length': len(result)
        })
        
        return jsonify({
            'success': True,
            'data': result
        })

    except OCRServiceError as e:
        raise APIError(
            "OCR processing failed",
            status_code=422,
            details={'ocr_error': str(e)}
        )

@api_bp.route('/categorize', methods=['POST'])
def categorize_text():
    try:
        data = request.get_json()
        if not data:
            raise APIError("No JSON data provided", status_code=400)

        text = data.get('text')
        if not text:
            raise APIError("Text field is required", status_code=400)

        # Categorize the text
        categories = categorization_service.categorize(text)
        
        logger.info("Text categorized successfully", extra={
            'text_length': len(text),
            'categories_count': len(categories)
        })
        
        return jsonify({
            'success': True,
            'categories': categories
        })

    except CategorizationError as e:
        raise APIError(
            "Categorization failed",
            status_code=422,
            details={'categorization_error': str(e)}
        )

@api_bp.route('/options', methods=['GET'])
def get_options():
    """Get all available options for filters"""
    try:
        with get_db() as db:
            # Get unique vendors from database
            vendors = [r[0] for r in db.query(Receipt.vendor).distinct().all() if r[0] != 'Missing']
            
            return jsonify({
                'categories': config.expense_categories,
                'payment_methods': config.payment_methods,
                'statuses': config.receipt_statuses,
                'vendors': sorted(vendors)
            })
    except Exception as e:
        logger.error(f"Failed to get options: {str(e)}")
        raise APIError("Failed to fetch options", status_code=500, details={'error': str(e)})

================
File: backend/api/services.py
================
class OCRServiceError(Exception):
    """Custom exception for OCR service errors"""
    pass

class CategorizationError(Exception):
    """Custom exception for categorization service errors"""
    pass

class OCRService:
    def process(self, file):
        try:
            # OCR processing logic
            pass
        except Exception as e:
            raise OCRServiceError(f"OCR processing failed: {str(e)}")

class CategorizationService:
    def categorize(self, text):
        try:
            # Categorization logic
            pass
        except Exception as e:
            raise CategorizationError(f"Categorization failed: {str(e)}")

================
File: backend/migrations/add_status_column.py
================
from sqlalchemy import create_engine, text
from backend.config import DATABASE_URL

def upgrade():
    engine = create_engine(DATABASE_URL)
    with engine.connect() as connection:
        # Add status column with 'pending' as default
        connection.execute(text("""
            ALTER TABLE receipts 
            ADD COLUMN status VARCHAR(20) DEFAULT 'pending' NOT NULL;
        """))
        connection.commit()

def downgrade():
    engine = create_engine(DATABASE_URL)
    with engine.connect() as connection:
        connection.execute(text("""
            ALTER TABLE receipts 
            DROP COLUMN status;
        """))
        connection.commit()

if __name__ == "__main__":
    upgrade()

================
File: backend/migrations/migrate_receipt_data.py
================
from datetime import datetime
from decimal import Decimal
from models.database import get_db, Receipt, ExpenseCategory

def convert_amount(amount_str):
    """Convert amount string to Decimal"""
    if not amount_str or amount_str == 'Missing':
        return Decimal('0.00')
    # Remove currency symbols and convert to Decimal
    cleaned = amount_str.replace('$', '').replace(',', '').strip()
    try:
        return Decimal(cleaned)
    except:
        return Decimal('0.00')

def convert_date(date_str):
    """Convert date string to datetime"""
    if not date_str or date_str == 'Missing':
        return datetime.utcnow()
    try:
        # Add more date formats as needed
        for fmt in ['%Y-%m-%d', '%m/%d/%Y', '%d/%m/%Y']:
            try:
                return datetime.strptime(date_str, fmt)
            except ValueError:
                continue
        return datetime.utcnow()
    except:
        return datetime.utcnow()

def convert_category(category_str):
    """Convert category string to ExpenseCategory enum"""
    if not category_str or category_str == 'Missing':
        return ExpenseCategory.OTHER
    
    # Try to match with enum values
    try:
        return next(
            (cat for cat in ExpenseCategory 
             if cat.value.lower() == category_str.lower()),
            ExpenseCategory.OTHER
        )
    except:
        return ExpenseCategory.OTHER

def migrate_data():
    """Migrate existing receipt data to new schema"""
    with get_db() as db:
        receipts = db.query(Receipt).all()
        
        for receipt in receipts:
            # Convert amount to Decimal
            receipt.amount = convert_amount(receipt.amount)
            
            # Convert date to datetime
            receipt.date = convert_date(receipt.date)
            
            # Convert category to enum
            receipt.category = convert_category(receipt.category)
        
        db.commit()

if __name__ == '__main__':
    migrate_data()
    print("Migration completed successfully")

================
File: backend/migrations/run_migrations.py
================
import os
import importlib.util

def run_migrations():
    migrations_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Get all .py files in migrations directory
    migration_files = [f for f in os.listdir(migrations_dir) 
                      if f.endswith('.py') and f != '__init__.py' 
                      and f != 'run_migrations.py']
    
    for migration_file in sorted(migration_files):
        print(f"Running migration: {migration_file}")
        
        # Import and run migration
        spec = importlib.util.spec_from_file_location(
            migration_file[:-3],
            os.path.join(migrations_dir, migration_file)
        )
        migration = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(migration)
        
        try:
            migration.upgrade()
            print(f"Successfully completed migration: {migration_file}")
        except Exception as e:
            print(f"Error running migration {migration_file}: {str(e)}")
            raise

if __name__ == "__main__":
    run_migrations()

================
File: backend/models/__init__.py
================
from .database import Base, get_db, Receipt, get_engine

================
File: backend/models/create_db.py
================
from database import Base, get_engine

def init_db():
    Base.metadata.drop_all(bind=get_engine())  # Warning: This drops existing tables
    Base.metadata.create_all(bind=get_engine())

if __name__ == '__main__':
    init_db()
    print("Database initialized")

================
File: backend/models/database.py
================
from sqlalchemy import create_engine, Column, Integer, String, JSON, DateTime, Numeric, ForeignKey, Enum, inspect
from sqlalchemy.orm import declarative_base, relationship
from sqlalchemy.orm import sessionmaker
from config import config
from contextlib import contextmanager
from datetime import datetime
import os
import enum
from decimal import Decimal

Base = declarative_base()

def get_engine():
    """Get SQLAlchemy engine, creating database directory if needed"""
    db_dir = os.path.dirname(config.db_path)
    if not os.path.exists(db_dir):
        os.makedirs(db_dir)
    return create_engine(f'sqlite:///{config.db_path}')

# Dynamically create ExpenseCategory enum from config
ExpenseCategory = enum.Enum(
    'ExpenseCategory',
    {category.upper().replace(' ', '_'): category for category in config.expense_categories}
)

class Receipt(Base):
    """Receipt database model"""
    __tablename__ = 'receipts'

    id = Column(Integer, primary_key=True)
    image_path = Column(String, nullable=False)
    vendor = Column(String)
    amount = Column(String)  # Back to String to handle 'Missing'
    date = Column(String)    # Back to String to handle 'Missing'
    payment_method = Column(String)
    category = Column(String)  # Back to String to handle 'Missing'
    content = Column(JSON, nullable=False)
    status = Column(String(20), nullable=False, default='pending')
    # Relationship to change history
    changes = relationship(
        "ReceiptChangeHistory",
        back_populates="receipt",
        cascade="all, delete-orphan"
    )

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if self.content:
            # Flatten nested JSON structure recursively
            def flatten_dict(d, parent_key='', sep='_'):
                items = []
                for k, v in d.items():
                    new_key = f"{parent_key}{sep}{k}" if parent_key else k
                    if isinstance(v, dict):
                        items.extend(flatten_dict(v, new_key, sep=sep).items())
                    else:
                        items.append((new_key, v))
                return dict(items)

            # Flatten and convert to lowercase
            flattened = flatten_dict(self.content)
            content_lower = {k.lower(): v for k, v in flattened.items()}
            
            # Set fields directly from content, defaulting to 'Missing'
            self.vendor = content_lower.get('vendor') or self.vendor or 'Missing'
            self.amount = content_lower.get('amount') or self.amount or 'Missing'
            self.date = content_lower.get('date') or self.date or 'Missing'
            self.payment_method = content_lower.get('payment_method') or self.payment_method or 'Missing'
            
            # Handle category
            if not self.category:
                from services.categorization_service import CategorizationService
                self.category = CategorizationService.categorize_receipt(self.content)

    def to_dict(self):
        """Convert receipt to dictionary"""
        return {
            'id': self.id,
            'image_path': self.image_path,
            'vendor': self.vendor or 'Missing',
            'amount': self.amount or 'Missing',
            'date': self.date or 'Missing',
            'payment_method': self.payment_method or 'Missing',
            'category': self.category or 'Other Expenses',
            'content': self.content,
            'status': self.status
        }

class ReceiptChangeHistory(Base):
    __tablename__ = 'receipt_change_history'

    id = Column(Integer, primary_key=True)
    #receipt_id = Column(Integer, ForeignKey('receipts.id'), nullable=False)
    receipt_id = Column(Integer, ForeignKey('receipts.id', ondelete="CASCADE"), nullable=False)
    field_name = Column(String, nullable=False)
    new_value = Column(String, nullable=False)
    changed_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    changed_by = Column(String, nullable=True)  # Will be used later for user tracking

    # Relationship to receipt
    receipt = relationship("Receipt", back_populates="changes")

# Initialize database
engine = get_engine()
Base.metadata.create_all(engine)
SessionLocal = sessionmaker(bind=engine)

@contextmanager
def get_db():
    """Database session context manager"""
    db = SessionLocal()
    try:
        yield db
        db.commit()
    except Exception:
        db.rollback()
        raise
    finally:
        db.close()

# Drop all tables and recreate - should only be called explicitly
def init_db():
    Base.metadata.drop_all(engine)
    Base.metadata.create_all(engine)

# Only create tables if they don't exist
inspector = inspect(engine)
if not inspector.has_table('receipts'):
    Base.metadata.create_all(engine)

================
File: backend/models/receipt.py
================
from sqlalchemy import Column, String, Integer, DateTime, Text
from backend.database import Base

class Receipt(Base):
    __tablename__ = 'receipts'
    
    id = Column(Integer, primary_key=True)
    image_path = Column(String(255), nullable=False)
    vendor = Column(String(255))
    amount = Column(String(50))
    date = Column(String(50))
    payment_method = Column(String(50))
    category = Column(String(50))
    content = Column(Text)
    status = Column(String(20), nullable=False, default='pending')

================
File: backend/scripts/recreate_db.py
================
from backend.database import Base, engine
from backend.models.receipt import Receipt

def recreate_database():
    print("Dropping all tables...")
    Base.metadata.drop_all(engine)
    
    print("Creating all tables...")
    Base.metadata.create_all(engine)
    
    print("Database recreation completed successfully!")

if __name__ == "__main__":
    recreate_database()

================
File: backend/services/categorization_service.py
================
import os
from openai import OpenAI
from typing import Dict, Optional
from config import config

client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))

class CategorizationService:
    @staticmethod
    def categorize_receipt(content: Dict) -> str:
        """Categorize receipt based on its content using LLM"""
        try:
            prompt = f"""
            Analyze this receipt and categorize it into one of these IRS Schedule C expense categories:
            {', '.join(config.expense_categories)}

            Receipt details:
            Vendor: {content.get('Vendor', '')}
            Items/Description: {content.get('text', [])}

            Return only the category name, nothing else.
            """

            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=50
            )

            category = response.choices[0].message.content.strip()
            return category if category in config.expense_categories else "Other Expenses"
            
        except Exception as e:
            print(f"Categorization error: {str(e)}")
            return "Other Expenses"

================
File: backend/services/categorization.py
================
import logging

logger = logging.getLogger(__name__)

def categorize_document(document):
    try:
        # ... existing logic ...
    except KeyError as e:
        logger.error(f"Missing key in document: {str(e)}", exc_info=True)
        return {"error": "Document is missing required fields"}, 400
    except Exception as e:
        logger.error(f"Unexpected error in document categorization: {str(e)}", exc_info=True)
        return {"error": "Document categorization failed"}, 500

================
File: backend/services/ocr_service_with_tessaract_not_working.py
================
import json
import logging
import ollama
import pytesseract
from PIL import Image
import cv2
import numpy as np
from config import config

logger = logging.getLogger(__name__)

def preprocess_image(image_path):
    """Preprocess image for better OCR results"""
    try:
        # Read image using opencv
        image = cv2.imread(image_path)
        
        # Convert to grayscale
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        
        # Apply adaptive thresholding
        gray = cv2.adaptiveThreshold(
            gray, 
            255, 
            cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
            cv2.THRESH_BINARY, 
            11, 
            2
        )
        
        # Denoise the image
        gray = cv2.fastNlMeansDenoising(gray)
        
        # Scale the image (upsampling might help with text recognition)
        scale_factor = 2
        gray = cv2.resize(gray, None, fx=scale_factor, fy=scale_factor, interpolation=cv2.INTER_CUBIC)
        
        return gray
    except Exception as e:
        logger.error(f"Error preprocessing image: {str(e)}")
        raise

def extract_text_with_tesseract(image):
    """Extract text from image using Tesseract"""
    try:
        # Configure Tesseract parameters for better accuracy
        custom_config = r'--oem 3 --psm 6 -c tessedit_char_whitelist="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@.,()-:/$% "'
        
        # Extract text
        text = pytesseract.image_to_string(
            image,
            config=custom_config,
            lang='eng'  # Explicitly specify English language
        )
        
        # Get detailed OCR data including positions
        ocr_data = pytesseract.image_to_data(image, output_type=pytesseract.Output.DICT)
        
        return text, ocr_data
    except Exception as e:
        logger.error(f"Tesseract OCR failed: {str(e)}")
        raise

def clean_json_text(json_text: str) -> str:
    """Clean and format JSON text for parsing"""
    import re
    
    # Find the first complete JSON object
    start = json_text.find('{')
    end = json_text.rfind('}') + 1
    if start >= 0 and end > start:
        json_text = json_text[start:end]
    
    # Clean up currency format - remove $ and ensure USD suffix
    json_text = re.sub(r'\$?(\d+\.\d{2})(?!\s*USD)', r'\1 USD', json_text)
    
    # Fix quoted null values
    json_text = re.sub(r'"null"', r'null', json_text)
    
    # Fix common JSON formatting issues
    json_text = re.sub(r'}\s*{', '},{', json_text)  # Add comma between objects
    json_text = re.sub(r'}\s*"', '},"', json_text)  # Add comma after closing brace
    json_text = re.sub(r']\s*"', '],"', json_text)  # Add comma after closing bracket
    json_text = re.sub(r'\s+', ' ', json_text)      # Normalize whitespace
    
    # Remove any control characters
    json_text = ''.join(char for char in json_text if ord(char) >= 32 or char in '\n\r\t')
    
    # Try to parse and re-serialize to ensure valid JSON
    try:
        parsed = json.loads(json_text)
        return json.dumps(parsed, indent=4)
    except json.JSONDecodeError:
        return json_text.strip()

class OCRService:
    @staticmethod
    def extract_receipt_data(image_path):
        """Extract receipt data using hybrid approach: Tesseract + Llama"""
        try:
            logger.info(f"Starting OCR process for image: {image_path}")
            
            # Step 1: Preprocess the image
            preprocessed_image = preprocess_image(image_path)
            
            # Step 2: Extract text using Tesseract
            raw_text, ocr_data = extract_text_with_tesseract(preprocessed_image)
            if not raw_text.strip():
                logger.error("No text extracted from the image. Check preprocessing or OCR steps.\n")
                # raise ValueError("OCR failed to extract text.")
            else:
                # Log the extracted text    
                logger.info("=" * 50)
                logger.info("TESSERACT OCR OUTPUT:")
                logger.info("=" * 50)
                logger.info(f"{raw_text}")
                logger.info("=" * 50)

            # Read original image for Llama
            with open(image_path, 'rb') as f:
                image_bytes = f.read()

            # Step 3: Use Llama to interpret the extracted text and image
            logger.info("Calling Llama for contextual understanding...")
            try:
                # Prepare the prompt template
                prompt_template = """IMPORTANT: Return ONLY a JSON object with EXACTLY these field names and structure. No explanations, no markdown, no analysis - just the JSON.

You are an advanced AI tasked with interpreting raw text extracted from a receipt or invoice, along with their image, and organizing it into a clean JSON format. Follow the instructions carefully to ensure accurate and structured data extraction based solely on the image and the raw text.

### Input ###
You will receive raw text extracted from a receipt or invoice using Tesseract. The text may include details about the buyer, vendor, items purchased, and totals. You will also receive the image of the receipt or invoice.

### Instructions ###
1. **Extract Only Visible Information:**
   - Do not make assumptions or add information not explicitly provided in the text.
   - Ignore fields that are missing or unclear. Use `null` for such fields in the JSON.

2. **Organize Data into a JSON Structure: as a minimum include the following fields, but if there are other fields that are present in the text/image, include them as well:**
    - `"purchased_by"`: Information about the buyer or customer.
    - `"vendor"`: Information about the vendor, store, or service provider.
    - `"order_summary"`: An array of items or services purchased, each including:
        - `"description"`: Description of the item or service.
        - `"price"`: The price per unit (formatted as a plain number with "USD").
        - `"quantity"`: The quantity of the item purchased.
        - `"subtotal"`: The calculated subtotal for the item (price × quantity).
        - `"tax"`: The tax rate applied to the item (if available).
    - `"totals"`: Information about the total cost of the transaction, including:
        - `"subtotal"`: The sum of all item subtotals (before taxes and discounts).
        - `"tax"`: The total tax applied to the purchase.
        - `"total"`: The total amount due, including taxes and discounts.
        - `"amount_paid"`: The amount paid by the customer.
        - `"balance_due"`: Any remaining balance due after payment.
    - `"comments"`: Any additional terms, policies, or notes provided in the receipt.

3. **Use Standardized Formatting:**
   - Use "USD" for currency values and "%" for percentages in tax rates.
   - Ensure the JSON is clean and free of special characters, non-standard formatting, or unnecessary explanations.

4. **DO NOT INVENT OR ASSUME:**
   - Avoid adding text, policies, or terms unless explicitly stated.
   - If subtotal, tax, or total fields are unclear or inconsistent, report them as `null`.

### Example Output. ONLY use it as an example to structure your response. ###
{
    "purchased_by": {
        "name": null,
        "email": null,
        "order_id": "US-001",
        "order_time": "11/02/2019",
        "order_type": "In-Person"
    },
    "vendor": {
        "name": "East Repair Inc.",
        "address": {
            "street": "1912 Harvest Lane",
            "city_state_zip": "New York, NY 12210"
        },
        "contact": {
            "phone": null,
            "fax": null,
            "email": null,
            "website": null
        }
    },
    "order_summary": [
        {
            "description": "Front and rear brake cables",
            "price": "100.00 USD",
            "quantity": 1,
            "subtotal": "100.00 USD",
            "tax": null
        },
        {
            "description": "New set of pedal arms",
            "price": "15.00 USD",
            "quantity": 2,
            "subtotal": "30.00 USD",
            "tax": null
        },
        {
            "description": "Labor 3hrs",
            "price": "5.00 USD",
            "quantity": 3,
            "subtotal": "15.00 USD",
            "tax": null
        }
    ],
    "totals": {
        "subtotal": "145.00 USD",
        "tax": "9.06 USD",
        "total": "154.06 USD",
        "amount_paid": null,
        "balance_due": "0.00 USD"
    },
    "comments": "string or null"
}

### Task ###
Analyze the raw text and the image below to extract the data, and return the structured JSON in the format described above. Ensure accuracy by only using the visible text from the input. IMPORTANT: Your response must be a single, valid JSON object only. No markdown, no explanations, no code blocks - just the JSON starting with { and ending with }. 

Raw OCR Text:
"""
                # Combine the prompt template with the raw text
                full_prompt = prompt_template + raw_text

                response = ollama.chat(
                    model='llama3.2-vision',
                    messages=[{
                        'role': 'user',
                        'content': full_prompt,
                        'images': [image_bytes]
                    }],
                    stream=False
                )
                logger.info("Successfully received response from Llama")

                content = response['message']['content']
                logger.info(f"Raw content from Llama: {content}")

                # Clean and parse the JSON
                try:
                    cleaned_json = clean_json_text(content)
                    data = json.loads(cleaned_json)
                    
                    # Post-process the data
                    if isinstance(data, dict):
                        # Ensure all currency values have USD
                        for key in data.get('totals', {}):
                            if data['totals'][key] and isinstance(data['totals'][key], str):
                                if data['totals'][key].replace('.', '').isdigit():
                                    data['totals'][key] = f"{float(data['totals'][key]):.2f} USD"
                        
                        # Ensure all items in order_summary have proper currency format
                        for item in data.get('order_summary', []):
                            for key in ['price', 'discount_amount', 'service_charge', 'subtotal']:
                                if item.get(key) and isinstance(item[key], str):
                                    if item[key].replace('.', '').isdigit():
                                        item[key] = f"{float(item[key]):.2f} USD"
                    
                    logger.info(f"Successfully parsed and processed JSON: {data}")
                    return {'content': data}
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to parse JSON: {str(e)}")
                    logger.error(f"Raw content: {content}")
                    logger.error(f"Cleaned content: {cleaned_json}")
                    return {'content': f"Error parsing JSON: {str(e)}", 'raw_content': content, 'cleaned_content': cleaned_json}

            except Exception as e:
                logger.error(f"Failed to process with Llama: {str(e)}")
                return {'content': f"Processing Error: {str(e)}"}
            
        except Exception as e:
            logger.error(f"OCR process failed: {str(e)}")
            return {'content': f"OCR Error: {str(e)}"}

================
File: backend/services/ocr_service.py
================
import os
import json
import base64
import logging
from openai import OpenAI
from dotenv import load_dotenv
 
# Load environment variables
load_dotenv()

logger = logging.getLogger(__name__)

# Initialize the OpenAI client with error handling
try:
    client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
    if not os.getenv('OPENAI_API_KEY'):
        logger.error("OPENAI_API_KEY not found in environment variables")
except Exception as e:
    logger.error(f"Failed to initialize OpenAI client: {str(e)}")
    raise

def clean_json_text(json_text: str) -> str:
    """Clean and format JSON text for parsing"""
    import re
    
    # Remove markdown code block syntax and headers
    json_text = re.sub(r'\*\*.*?\*\*', '', json_text)
    json_text = re.sub(r'Here is the extracted data.*?structure:', '', json_text)
    json_text = re.sub(r'```json\s*', '', json_text)
    json_text = re.sub(r'```\s*', '', json_text)
    json_text = re.sub(r'Note:.*', '', json_text)
    
    # Find the JSON object
    start = json_text.find('{')
    end = json_text.rfind('}') + 1
    if start >= 0 and end > start:
        json_text = json_text[start:end]
    
    # Only clean up currency format if needed
    json_text = re.sub(r'\$(\d+\.\d{2})(?!\s*USD)', r'\1 USD', json_text)
    
    # Remove any control characters
    json_text = ''.join(char for char in json_text if ord(char) >= 32 or char in '\n\r\t')
    
    return json_text.strip()

class OCRService:
    @staticmethod
    def extract_receipt_data(image_path):
        """Extract receipt data using gpt-4o-mini"""
        try:
            logger.info(f"Processing receipt image: {image_path}")
            
            # Read image file and convert to base64
            try:
                with open(image_path, 'rb') as f:
                    image_bytes = f.read()
                base64_image = base64.b64encode(image_bytes).decode('utf-8')
            except Exception as e:
                logger.error(f"Failed to read image file: {str(e)}")
                raise

            try:
                response = client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[
                        {
                            "role": "user",
                            "content": [
                                {
                                    "type": "text",
                                    "text": """Extract the text from this image and format the output as a JSON object with two parts:
1. The main fields at the root level (use exactly these field names):
   - Vendor
   - Amount
   - Date
   - Payment_Method

2. A 'text' array containing all lines of text from the receipt in order, preserving the original formatting and content.

Example format:
{
    "Vendor": "store name",
    "Amount": "total amount",
    "Date": "receipt date",
    "Payment_Method": "payment type",
    "text": [
        "line 1 of receipt",
        "line 2 of receipt",
        ...
    ]
}

Capture every line of text, including store details, items, prices, subtotals, taxes, and any additional information."""
                                },  
                                {
                                    "type": "image_url",
                                    "image_url": {
                                        "url": f"data:image/jpeg;base64,{base64_image}"
                                    }
                                }
                            ]
                        }
                    ],
                    max_tokens=1000
                )
                
                content = response.choices[0].message.content

                try:
                    # Clean and format the entire response
                    cleaned_json = clean_json_text(content)
                    data = json.loads(cleaned_json)
                    return {'content': data}
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to parse OCR response: {str(e)}")
                    return {'content': f"Error parsing JSON: {str(e)}"}

            except Exception as e:
                logger.error(f"Failed to process image with Vision API: {str(e)}")
                return {'content': f"Vision API Error: {str(e)}"}
            
        except Exception as e:
            logger.error(f"OCR process failed: {str(e)}")
            return {'content': f"OCR Error: {str(e)}"}

================
File: backend/src/index.ts
================
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const port = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

// Basic health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});

================
File: backend/tests/__init__.py
================
import logging

# Configure logging for tests
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

================
File: backend/tests/base.py
================
import logging
import requests
import time
from PIL import Image, ImageDraw
import io
import sys

# Configure logging
logger = logging.getLogger(__name__)

class BaseTest:
    """Base class for API tests"""
    
    BASE_URL = 'http://localhost:3456/api'
    UPLOAD_TIMEOUT = 120  # 2 minutes for upload/OCR
    REQUEST_TIMEOUT = 30  # 30 seconds for other requests

    @classmethod
    def wait_for_server(cls, timeout=30, interval=2):
        """Wait for server to become available"""
        logger.info("Checking server availability...")
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                response = requests.get(f'{cls.BASE_URL}/health')
                if response.status_code == 200:
                    logger.info("Server is available")
                    return True
            except requests.ConnectionError:
                logger.debug(f"Server not ready, retrying in {interval} seconds...")
            time.sleep(interval)
        
        logger.error(f"Server did not become available within {timeout} seconds")
        return False

    @staticmethod
    def create_test_receipt_image():
        """Create a test receipt image"""
        logger.info("Creating test receipt image...")
        
        # Create image
        width, height = 576, 1000
        img = Image.new('RGB', (width, height), color=(250, 250, 250))
        draw = ImageDraw.Draw(img)
        
        # Add content
        y = 50
        draw.text((width//2 - 50, y), "TEST STORE", fill=(0, 0, 0))
        y += 50
        draw.text((50, y), "Date: 2024-01-20", fill=(0, 0, 0))
        y += 50
        
        # Add items
        items = [
            ("Item 1", "$10.99"),
            ("Item 2", "$15.00"),
            ("Item 3", "$17.00")
        ]
        for item, price in items:
            draw.text((50, y), f"{item}{' ' * 20}{price}", fill=(0, 0, 0))
            y += 30
        
        # Add totals
        y += 20
        draw.text((50, y), f"Subtotal{' ' * 20}$42.99", fill=(0, 0, 0))
        y += 30
        draw.text((50, y), f"Tax{' ' * 25}$3.44", fill=(0, 0, 0))
        y += 30
        draw.text((50, y), f"Total{' ' * 23}$46.43", fill=(0, 0, 0))
        
        # Convert to bytes
        img_bytes = io.BytesIO()
        img.save(img_bytes, format='PNG')
        img_bytes.seek(0)
        
        return img_bytes

================
File: backend/tests/config.py
================
import os

# Test configuration class - used by other tests
class TestConfig:
    """Test configuration"""
    def __init__(self):
        # Use in-memory SQLite for tests
        self.db_path = ':memory:'
        # Use temporary directory for test uploads
        self.upload_folder = os.path.join('tests', 'test_uploads')
        
        # Single source of truth for expense categories
        self.expense_categories = [
            "Advertising",
            "Car and Truck Expenses",
            "Commissions and Fees",
            "Contract Labor",
            "Depletion",
            "Depreciation and Section 179 Expense Deduction",
            "Employee Benefit Programs",
            "Insurance (Other Than Health)",
            "Interest",
            "Legal and Professional Services",
            "Office Expenses",
            "Pension and Profit-Sharing Plans",
            "Rent or Lease",
            "Repairs and Maintenance",
            "Supplies",
            "Taxes and Licenses",
            "Travel",
            "Meals",
            "Utilities",
            "Wages",
            "Other Expenses"
        ]
        
        # Payment methods
        self.payment_methods = [
            "Credit Card",
            "Debit Card",
            "Cash",
            "Check",
            "Wire Transfer",
            "Other"
        ]
        
        # Receipt statuses
        self.receipt_statuses = [
            "Pending",
            "Approved",
            "Rejected"
        ]

# Create config instance used by other tests
config = TestConfig()

================
File: backend/tests/conftest_integration.py
================
import pytest
import logging
import os

# Configure logging
logging.basicConfig(level=logging.INFO)

# Set testing environment variable
os.environ['TESTING'] = 'true'

# Create test directories
os.makedirs('test_uploads', exist_ok=True)
os.makedirs('data', exist_ok=True)

@pytest.fixture(scope='session', autouse=True)
def setup_test_env():
    """Set up test environment"""
    yield
    # Clean up after all tests
    import shutil
    if os.path.exists('test_uploads'):
        shutil.rmtree('test_uploads')
    if os.path.exists('data'):
        shutil.rmtree('data')

================
File: backend/tests/conftest.py
================
import pytest
from dotenv import load_dotenv
import os
import sys
import logging
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, scoped_session
from flask import Flask, g
from werkzeug.exceptions import HTTPException

# Load environment variables
load_dotenv()
print(os.getenv('TEST_DATABASE_URL'))

# Add backend directory to Python path
backend_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, backend_dir)

# Import after path setup
from models.database import Base
from backend.config import config
from api.routes import api_bp

# Configure logging
logging.basicConfig(level=logging.INFO)

# Create test directories
os.makedirs(config.upload_folder, exist_ok=True)

@pytest.fixture(scope='session')
def engine():
    """Create test database engine"""
    database_url = os.getenv('TEST_DATABASE_URL', 'sqlite:///:memory:')
    return create_engine(database_url, echo=False)

@pytest.fixture(scope='session')
def tables(engine):
    """Create all database tables"""
    Base.metadata.create_all(engine)
    yield
    Base.metadata.drop_all(engine)

@pytest.fixture
def db_session(engine):
    """Create a new database session for a test"""
    connection = engine.connect()
    
    # Start a new transaction
    transaction = connection.begin()
    
    # Configure the session
    Session = sessionmaker(bind=connection)
    session = Session()

    # Ensure we're starting with a clean slate
    session.execute(text('DELETE FROM receipts'))
    session.commit()

    yield session

    # Rollback everything and close
    session.close()
    transaction.rollback()
    connection.close()

@pytest.fixture
def client(engine, tables, db_session):
    """Create Flask test client"""
    app = Flask(__name__)
    app.config['TESTING'] = True
    app.config['UPLOAD_FOLDER'] = config.upload_folder
    app.config['DATABASE_URL'] = os.getenv('TEST_DATABASE_URL', 'sqlite:///:memory:')
    
    @app.before_request
    def before_request():
        g.db_session = db_session
    
    # Register error handlers
    from api.errors import APIError, handle_api_error, handle_http_error, handle_generic_error
    app.register_error_handler(APIError, handle_api_error)
    app.register_error_handler(HTTPException, handle_http_error)
    app.register_error_handler(Exception, handle_generic_error)
    
    # Register blueprint
    app.register_blueprint(api_bp, url_prefix='/api')
    
    with app.test_client() as client:
        with app.app_context():
            yield client

@pytest.fixture(scope='session', autouse=True)
def cleanup():
    """Clean up after all tests"""
    yield
    # Clean up test uploads
    import shutil
    if os.path.exists(config.upload_folder):
        shutil.rmtree(config.upload_folder)

================
File: backend/tests/test_api_integration.py
================
import unittest
import requests
import io
from PIL import Image, ImageDraw

class TestReceiptAPI(unittest.TestCase):
    """Integration tests for Receipt REST API"""
    
    BASE_URL = 'http://localhost:3456/api'

    def create_test_image(self):
        """Create a test receipt image"""
        # Create image
        width, height = 576, 1000
        img = Image.new('RGB', (width, height), color=(250, 250, 250))
        draw = ImageDraw.Draw(img)
        
        # Add content
        y = 50
        draw.text((width//2 - 50, y), "TEST STORE", fill=(0, 0, 0))
        y += 50
        draw.text((50, y), "Date: 2024-01-20", fill=(0, 0, 0))
        y += 50
        
        # Add items
        items = [
            ("Item 1", "$10.99"),
            ("Item 2", "$15.00"),
            ("Item 3", "$17.00")
        ]
        for item, price in items:
            draw.text((50, y), f"{item}{' ' * 20}{price}", fill=(0, 0, 0))
            y += 30
        
        # Add totals
        y += 20
        draw.text((50, y), f"Subtotal{' ' * 20}$42.99", fill=(0, 0, 0))
        y += 30
        draw.text((50, y), f"Tax{' ' * 25}$3.44", fill=(0, 0, 0))
        y += 30
        draw.text((50, y), f"Total{' ' * 23}$46.43", fill=(0, 0, 0))
        
        # Convert to bytes
        img_bytes = io.BytesIO()
        img.save(img_bytes, format='PNG')
        img_bytes.seek(0)
        return img_bytes

    def test_upload_receipt(self):
        """Test receipt upload endpoint"""
        # Upload a test image
        test_image = self.create_test_image()
        response = requests.post(
            f'{self.BASE_URL}/upload',
            files={'file': ('test.png', test_image, 'image/png')}
        )
        
        # Verify response
        self.assertEqual(response.status_code, 200)
        data = response.json()
        
        # Verify response has required fields
        required_fields = {'id', 'image_path', 'vendor', 'amount', 'date', 'payment_method', 'category'}
        self.assertTrue(all(field in data for field in required_fields))
        
        return data['id']

    def test_get_receipts(self):
        """Test get all receipts endpoint"""
        response = requests.get(f'{self.BASE_URL}/receipts')
        
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertIsInstance(data, list)

    def test_get_receipt(self):
        """Test get single receipt endpoint"""
        # First create a receipt
        receipt_id = self.test_upload_receipt()
        
        # Get the receipt
        response = requests.get(f'{self.BASE_URL}/receipts/{receipt_id}')
        
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertEqual(data['id'], receipt_id)

    def test_update_receipt(self):
        """Test update receipt endpoint"""
        # First create a receipt
        receipt_id = self.test_upload_receipt()
        
        # Update it
        update_data = {
            'vendor': 'Updated Store',
            'amount': '99.99',
            'category': 'Office Expenses'
        }
        
        response = requests.patch(
            f'{self.BASE_URL}/receipts/{receipt_id}/update',
            json=update_data
        )
        
        self.assertEqual(response.status_code, 200)
        data = response.json()
        
        # Verify updates were applied
        for field, value in update_data.items():
            self.assertEqual(data['updated_fields'][field], value)

    def test_delete_receipt(self):
        """Test delete receipt endpoint"""
        # First create a receipt
        receipt_id = self.test_upload_receipt()
        
        # Delete it
        response = requests.delete(f'{self.BASE_URL}/receipts/{receipt_id}')
        self.assertEqual(response.status_code, 200)
        
        # Verify it's gone
        response = requests.get(f'{self.BASE_URL}/receipts/{receipt_id}')
        self.assertEqual(response.status_code, 404)

    def test_error_cases(self):
        """Test error responses"""
        # Test 404 on non-existent receipt
        response = requests.get(f'{self.BASE_URL}/receipts/99999')
        self.assertEqual(response.status_code, 404)
        self.assertTrue(response.json()['error'])
        self.assertEqual(response.json()['message'], "Receipt not found")
        
        # Test 400 on upload with no file
        response = requests.post(f'{self.BASE_URL}/upload', files={})
        self.assertEqual(response.status_code, 400)
        self.assertTrue(response.json()['error'])
        self.assertIn('message', response.json())

================
File: backend/tests/test_api_options.py
================
import pytest
from backend.config import config

def test_get_options(client):
    """Test options endpoint returns correct configuration options"""
    response = client.get('/api/options')
    assert response.status_code == 200
    
    data = response.json
    # Verify all required fields are present
    assert 'categories' in data
    assert 'payment_methods' in data
    assert 'statuses' in data
    assert 'vendors' in data
    
    # Verify configuration values are correct
    assert set(data['categories']) == set(config.expense_categories)
    assert set(data['payment_methods']) == set(config.payment_methods)
    assert set(data['statuses']) == set(config.receipt_statuses)

================
File: backend/tests/test_api.py
================
import pytest
import io
from PIL import Image, ImageDraw
import json
from datetime import datetime, timedelta

def create_test_receipt_image():
    """Create a test receipt image"""
    # Create image
    width, height = 576, 1000
    img = Image.new('RGB', (width, height), color=(250, 250, 250))
    draw = ImageDraw.Draw(img)
    
    # Add content
    y = 50
    draw.text((width//2 - 50, y), "TEST STORE", fill=(0, 0, 0))
    y += 50
    draw.text((50, y), "Date: 2024-01-20", fill=(0, 0, 0))
    y += 50
    
    # Add items
    items = [
        ("Item 1", "$10.99"),
        ("Item 2", "$15.00"),
        ("Item 3", "$17.00")
    ]
    for item, price in items:
        draw.text((50, y), f"{item}{' ' * 20}{price}", fill=(0, 0, 0))
        y += 30
    
    # Add totals
    y += 20
    draw.text((50, y), f"Subtotal{' ' * 20}$42.99", fill=(0, 0, 0))
    y += 30
    draw.text((50, y), f"Tax{' ' * 25}$3.44", fill=(0, 0, 0))
    y += 30
    draw.text((50, y), f"Total{' ' * 23}$46.43", fill=(0, 0, 0))
    
    # Convert to bytes
    img_bytes = io.BytesIO()
    img.save(img_bytes, format='PNG')
    img_bytes.seek(0)
    
    return img_bytes

def test_upload_receipt_unit(client):
    """Unit test for receipt upload endpoint"""
    # Debug: Print all registered routes
    print("\nRegistered routes:")
    for rule in client.application.url_map.iter_rules():
        print(f"{rule.endpoint}: {rule.rule}")
    
    test_image = create_test_receipt_image()
    response = client.post(
        '/api/upload',
        data={'file': (test_image, 'test_receipt.png', 'image/png')}
    )
    
    assert response.status_code == 200
    data = json.loads(response.data)
    assert 'id' in data
    assert 'image_path' in data
    assert 'content' in data
    return data['id']

def test_get_receipts_unit(client):
    """Unit test for get all receipts endpoint"""
    # Temporary debug - you can remove after confirming
    print("\nAvailable routes:")
    for rule in client.application.url_map.iter_rules():
        print(f"{rule.endpoint}: {rule.rule}")
        
    response = client.get('/api/receipts')
    assert response.status_code == 200
    data = json.loads(response.data)
    assert isinstance(data, list)

def test_get_receipt_unit(client):
    """Unit test for get single receipt endpoint"""
    receipt_id = test_upload_receipt_unit(client)
    response = client.get(f'/api/receipts/{receipt_id}')
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['id'] == receipt_id

def test_update_receipt_unit(client):
    """Unit test for update receipt endpoint"""
    receipt_id = test_upload_receipt_unit(client)
    
    update_data = {
        'content': {
            'store_name': 'Updated Store',
            'date': '2024-01-20',
            'items': [
                {'name': 'Test Item 1', 'quantity': 1, 'price': 19.99},
                {'name': 'Test Item 2', 'quantity': 2, 'price': 29.99}
            ],
            'subtotal': 79.97,
            'tax': 6.40,
            'total_amount': 86.37
        }
    }
    
    response = client.patch(
        f'/api/receipts/{receipt_id}/update',
        json=update_data
    )
    
    assert response.status_code == 200
#    data = json.loads(response.data) # seems like a redundant check as content should not be returned in the response
#    assert data['content'] == update_data['content']

def test_delete_receipt_unit(client):
    """Unit test for delete receipt endpoint"""
    receipt_id = test_upload_receipt_unit(client)

    # Delete the receipt
    response = client.delete(f'/api/receipts/{receipt_id}')
    assert response.status_code == 200

    # Verify deletion by checking that the receipt no longer exists
    response = client.get(f'/api/receipts/{receipt_id}')
    assert response.status_code == 404  # Now we expect a 404 status code
    assert response.json['error'] == True
    assert response.json['message'] == "Receipt not found"

def test_update_receipt_validation(client):
    """Test field validation rules"""
    receipt_id = test_upload_receipt_unit(client)
    
    # Test invalid vendor
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'vendor': 'x' * 101  # Too long
    })
    assert response.status_code == 400
    assert response.json['error'] == True
    assert 'message' in response.json
    assert 'details' in response.json
    assert 'vendor' in response.json['details']
    
    # Test invalid amount
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'amount': '1000000.00'  # Too large
    })
    assert response.status_code == 400
    assert 'error' in response.json
    assert 'details' in response.json
    assert 'amount' in response.json['details']
    
    # Test future date
    future_date = (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d')
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'date': future_date
    })
    assert response.status_code == 400
    assert 'error' in response.json
    assert 'details' in response.json
    assert 'date' in response.json['details']
    
    # Test invalid status
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'invalid_status'
    })
    assert response.status_code == 400
    assert 'error' in response.json
    assert 'details' in response.json
    assert 'status' in response.json['details']

def test_update_receipt_success(client):
    """Test successful field updates"""
    receipt_id = test_upload_receipt_unit(client)  # Create test receipt
    
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'vendor': 'New Vendor',
        'amount': '150.00',
        'status': 'approved'
    })
    
    assert response.status_code == 200
    assert response.json['success'] is True
    assert 'vendor' in response.json['updated_fields']
    assert 'amount' in response.json['updated_fields']
    assert 'status' in response.json['updated_fields']
    
    # Verify status change from default 'pending' to 'approved'
    assert response.json['updated_fields']['status'] == 'approved'

def test_update_receipt_errors(client):
    """Test various error conditions"""
    # Test non-existent receipt
    response = client.patch('/api/receipts/99999/update', json={
        'vendor': 'New Vendor'
    })
    assert response.status_code == 404
    assert response.json['error'] == True
    assert response.json['message'] == "Receipt not found"
    
    # Test non-JSON request
    receipt_id = test_upload_receipt_unit(client)
    response = client.patch(f'/api/receipts/{receipt_id}/update', data='not json')
    assert response.status_code == 400
    assert response.json['error'] == True
    assert 'message' in response.json

def test_partial_update_receipt(client):
    """Test updating subset of fields"""
    receipt_id = test_upload_receipt_unit(client)
    
    # Verify initial status is 'pending'
    response = client.get(f'/api/receipts/{receipt_id}')
    assert response.status_code == 200
    assert response.json['status'] == 'pending'
    
    # Update only status
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'approved'
    })
    
    assert response.status_code == 200
    assert len(response.json['updated_fields']) == 1
    assert response.json['updated_fields']['status'] == 'approved'

def test_status_transitions(client):
    """Test status transition rules"""
    receipt_id = test_upload_receipt_unit(client)
    
    # Verify initial status is 'pending'
    response = client.get(f'/api/receipts/{receipt_id}')
    assert response.status_code == 200
    assert response.json['status'] == 'pending'
    
    # Valid transition: pending → approved
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'APPROVED'  # Test case insensitive
    })
    assert response.status_code == 200
    assert response.json['updated_fields']['status'] == 'approved'
    
    # Invalid transition: approved → pending
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'pending'
    })
    assert response.status_code == 200
    assert response.json['updated_fields']['status'] == 'pending'
    
    # Valid transition: approved → rejected
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'rejected'
    })
    assert response.status_code == 200
    assert response.json['updated_fields']['status'] == 'rejected'
    
    # Valid transition: rejected → approved
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'approved'
    })
    assert response.status_code == 200
    assert response.json['updated_fields']['status'] == 'approved'

================
File: backend/tests/test_categorization.py
================
import pytest
from services.categorization_service import CategorizationService
from tests.config import config
from unittest.mock import patch, MagicMock

def test_categorize_receipt_valid_category():
    """Test categorization with a valid category response"""
    test_content = {
        'Vendor': 'Office Depot',
        'text': ['Paper', 'Pens', 'Stapler']
    }
    
    # Mock OpenAI response with a valid category
    mock_response = MagicMock()
    mock_response.choices = [
        MagicMock(message=MagicMock(content=config.expense_categories[0]))
    ]
    
    with patch('services.categorization_service.client.chat.completions.create', return_value=mock_response):
        category = CategorizationService.categorize_receipt(test_content)
        assert category in config.expense_categories

def test_categorize_receipt_invalid_category():
    """Test categorization with an invalid category response"""
    test_content = {
        'Vendor': 'Some Store',
        'text': ['Item 1', 'Item 2']
    }
    
    # Mock OpenAI response with an invalid category
    mock_response = MagicMock()
    mock_response.choices = [
        MagicMock(message=MagicMock(content="Invalid Category"))
    ]
    
    with patch('services.categorization_service.client.chat.completions.create', return_value=mock_response):
        category = CategorizationService.categorize_receipt(test_content)
        assert category == "Other Expenses"  # Should default to Other Expenses

def test_categorize_receipt_api_error():
    """Test categorization when API call fails"""
    test_content = {
        'Vendor': 'Some Store',
        'text': ['Item 1', 'Item 2']
    }
    
    # Mock API error
    with patch('services.categorization_service.client.chat.completions.create', side_effect=Exception("API Error")):
        category = CategorizationService.categorize_receipt(test_content)
        assert category == "Other Expenses"  # Should default to Other Expenses

def test_categorize_receipt_prompt_content():
    """Test that the prompt includes all categories"""
    test_content = {
        'Vendor': 'Test Store',
        'text': ['Test Item']
    }
    
    mock_create = MagicMock()
    
    with patch('services.categorization_service.client.chat.completions.create', mock_create):
        CategorizationService.categorize_receipt(test_content)
        
        # Check that all categories are included in the prompt
        call_args = mock_create.call_args[1]
        messages = call_args['messages']
        prompt = messages[0]['content']
        
        for category in config.expense_categories:
            assert category in prompt

def test_categorize_receipt_empty_content():
    """Test categorization with empty content"""
    test_content = {}
    
    mock_response = MagicMock()
    mock_response.choices = [
        MagicMock(message=MagicMock(content=config.expense_categories[0]))
    ]
    
    with patch('services.categorization_service.client.chat.completions.create', return_value=mock_response):
        category = CategorizationService.categorize_receipt(test_content)
        assert category in config.expense_categories

def test_categorize_receipt_none_content():
    """Test categorization with None content"""
    # Test that None input returns default category
    category = CategorizationService.categorize_receipt(None)
    assert category == "Other Expenses"

================
File: backend/tests/test_config.py
================
import os
import pytest
from backend.config import config  # Import the config object directly

class ConfigTests:
    """Tests for configuration settings"""
    
    def test_database_path(self):
        """Test that test config uses in-memory database"""
        assert config.db_path == ':memory:'
        
    def test_upload_folder(self):
        """Test upload folder configuration"""
        assert config.upload_folder == 'test_uploads'
            
    def test_expense_categories(self):
        """Test expense categories configuration"""
        # Test that expense categories are defined
        assert hasattr(config, 'expense_categories')
        assert isinstance(config.expense_categories, list)
        assert len(config.expense_categories) > 0
        
        # Test that required categories are present
        required_categories = [
            "Advertising",
            "Travel",
            "Meals",
            "Other Expenses"
        ]
        for category in required_categories:
            assert category in config.expense_categories, f"Required category '{category}' not found"
        
        # Test that categories are strings and properly formatted
        for category in config.expense_categories:
            assert isinstance(category, str), f"Category '{category}' is not a string"
            assert len(category.strip()) == len(category), f"Category '{category}' has leading/trailing whitespace"
            assert category[0].isupper(), f"Category '{category}' should start with uppercase letter"

    def test_payment_methods(self):
        """Test payment methods configuration"""
        # Test that required methods are present
        required_methods = ["Credit Card", "Cash", "Check"]
        for method in required_methods:
            assert method in config.payment_methods, f"Required payment method '{method}' not found"
            
        # Test for duplicates
        assert len(config.payment_methods) == len(set(config.payment_methods))

    def test_receipt_statuses(self):
        """Test receipt statuses configuration"""
        # Test required statuses
        required_statuses = {"Pending", "Approved", "Rejected"}
        assert set(config.receipt_statuses) == required_statuses
        
        # Test for duplicates
        assert len(config.receipt_statuses) == len(set(config.receipt_statuses))

================
File: backend/tests/test_models.py
================
import pytest
from sqlalchemy import inspect
from models.database import engine, Receipt

def test_receipt_model_configuration():
    """Test that Receipt model is configured correctly"""
    # Get model metadata
    receipt_table = Receipt.__table__

    # Test status column configuration
    status_column = receipt_table.columns.get('status')
    assert status_column is not None
    assert status_column.type.length == 20
    assert not status_column.nullable
    assert status_column.default.arg == 'pending'

    # Test required columns exist
    required_columns = {'id', 'image_path', 'content', 'status'}
    actual_columns = set(receipt_table.columns.keys())
    assert required_columns.issubset(actual_columns)

================
File: backend/tests/test_receipt_updates.py
================
import pytest
from models.database import Receipt, get_db
from backend.config import config

def test_update_receipt_fields(client):
    """Test updating receipt fields"""
    # Create a test receipt
    with get_db() as db:
        receipt = Receipt(
            image_path="test.jpg",
            vendor="Test Vendor",
            amount="10.00",
            date="2023-12-16",
            payment_method="CASH",
            category="Other",
            content={"test": "data"}
        )
        db.add(receipt)
        db.commit()
        receipt_id = receipt.id

    # Test updating fields
    update_data = {
        "vendor": "New Vendor",
        "amount": "25.50",
        "category": "Office Expenses"
    }

    response = client.patch(f'/api/receipts/{receipt_id}/update', json=update_data)
    assert response.status_code == 200

    # Verify the updates were applied
    with get_db() as db:
        updated_receipt = db.query(Receipt).get(receipt_id)
        assert updated_receipt.vendor == "New Vendor"
        assert updated_receipt.amount == "25.50"
        assert updated_receipt.category == "Office Expenses"

    # Clean up
    with get_db() as db:
        db.query(Receipt).filter_by(id=receipt_id).delete()
        db.commit()

def test_update_invalid_receipt(client):
    """Test updating non-existent receipt"""
    response = client.patch('/api/receipts/99999/update', json={"vendor": "Test"})
    assert response.status_code == 404
    assert response.json['error'] == True
    assert response.json['message'] == "Receipt not found"

def test_partial_update_receipt(client):
    """Test updating only some fields of a receipt"""
    with get_db() as db:
        receipt = Receipt(
            image_path="test.jpg",
            vendor="Original Vendor",
            amount="10.00",
            date="2023-12-16",
            payment_method="CASH",
            category="Other Expenses",
            content={"test": "data"}
        )
        db.add(receipt)
        db.commit()
        receipt_id = receipt.id

    # Update only vendor
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={"vendor": "New Vendor"})
    assert response.status_code == 200

    # Verify only vendor changed, other fields remained same
    with get_db() as db:
        updated_receipt = db.query(Receipt).get(receipt_id)
        assert updated_receipt.vendor == "New Vendor"
        assert updated_receipt.amount == "10.00"  # unchanged
        assert updated_receipt.category == "Other Expenses"  # unchanged

    # Clean up
    with get_db() as db:
        db.query(Receipt).filter_by(id=receipt_id).delete()
        db.commit()

def test_update_invalid_fields(client):
    """Test updating with invalid field values"""
    with get_db() as db:
        receipt = Receipt(
            image_path="test.jpg",
            content={"test": "data"}
        )
        db.add(receipt)
        db.commit()
        receipt_id = receipt.id

    # Test invalid amount format
    response = client.patch(f'/api/receipts/{receipt_id}/update', 
                          json={"amount": "invalid"})
    assert response.status_code == 400
    assert response.json['error'] == True
    assert 'message' in response.json
    assert 'details' in response.json
    assert 'amount' in response.json['details']

    # Clean up
    with get_db() as db:
        db.query(Receipt).filter_by(id=receipt_id).delete()
        db.commit()

def test_validate_category(client):
    """Test category validation in receipt updates"""
    # Create a test receipt
    response = client.post('/api/upload', data={
        'file': (open('tests/test_receipt_debug.png', 'rb'), 'test_receipt.png')
    })
    assert response.status_code == 200
    receipt_id = response.json['id']
    
    # Test valid category
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'category': config.expense_categories[0]
    })
    assert response.status_code == 200
    
    # Test invalid category
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'category': 'Invalid Category'
    })
    assert response.status_code == 400
    assert 'category' in response.json['details']

def test_validate_payment_method(client):
    """Test payment method validation in receipt updates"""
    # Create a test receipt
    response = client.post('/api/upload', data={
        'file': (open('tests/test_receipt_debug.png', 'rb'), 'test_receipt.png')
    })
    assert response.status_code == 200
    receipt_id = response.json['id']
    
    # Test valid payment method
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'payment_method': config.payment_methods[0]
    })
    assert response.status_code == 200
    
    # Test invalid payment method
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'payment_method': 'Invalid Method'
    })
    assert response.status_code == 400
    assert 'payment_method' in response.json['details']

def test_validate_status(client):
    """Test status validation and transitions in receipt updates"""
    # Create a test receipt
    response = client.post('/api/upload', data={
        'file': (open('tests/test_receipt_debug.png', 'rb'), 'test_receipt.png')
    })
    assert response.status_code == 200
    receipt_id = response.json['id']
    
    # Test valid status transition: pending -> approved
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': config.receipt_statuses[1]  # 'Approved'
    })
    assert response.status_code == 200
    
    # Test invalid status transition: approved -> approved (no change)
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': config.receipt_statuses[1]  # 'Approved'
    })
    assert response.status_code == 400
    assert 'status' in response.json['details']
    
    # Test invalid status value
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'invalid_status'
    })
    assert response.status_code == 400
    assert 'status' in response.json['details']

================
File: backend/tests/test_upload.py
================
import requests
import os
import logging
from PIL import Image, ImageDraw, ImageFont
import io
import random
import sys

# Force logging to stdout with DEBUG level
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    force=True,  # Force override any existing logger
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

# Disable other loggers
logging.getLogger('urllib3').setLevel(logging.WARNING)
logging.getLogger('PIL').setLevel(logging.WARNING)

logger = logging.getLogger('test_upload')
logger.setLevel(logging.DEBUG)

# Test that logging works
logger.debug("Logging initialized")

BASE_URL = 'http://localhost:3456/api'

def create_test_receipt_image():
    """Create a realistic receipt image with noise"""
    logger.info("Creating test receipt image...")
    
    # Create a tall receipt image (typical receipt dimensions)
    width = 576  # Standard receipt width (72mm at 203dpi)
    height = 1000
    img = Image.new('RGB', (width, height), color=(250, 250, 250))  # Slightly off-white
    d = ImageDraw.Draw(img)
    
    # Try to use a monospace font
    try:
        font_paths = [
            '/System/Library/Fonts/Courier.dfont',  # macOS
            '/usr/share/fonts/truetype/liberation/LiberationMono-Regular.ttf',  # Linux
            'C:\\Windows\\Fonts\\cour.ttf'  # Windows
        ]
        
        font = None
        for path in font_paths:
            if os.path.exists(path):
                font = ImageFont.truetype(path, size=24)
                logger.info(f"Using font from: {path}")
                break
        
        if font is None:
            logger.warning("No suitable font found, using default font")
    except Exception as e:
        logger.error(f"Font error: {e}")
        font = None
    
    # Draw receipt content
    y = 50
    # Header
    d.text((width//2 - 50, y), "TEST STORE", fill=(0, 0, 0), font=font)
    y += 40
    d.text((width//2 - 80, y), "123 Main Street", fill=(0, 0, 0), font=font)
    y += 30
    d.text((width//2 - 80, y), "City, State 12345", fill=(0, 0, 0), font=font)
    y += 50
    
    # Transaction details
    d.text((50, y), "Date: 2024-01-20", fill=(0, 0, 0), font=font)
    y += 30
    d.text((50, y), "Receipt #: 1234", fill=(0, 0, 0), font=font)
    y += 50
    
    # Items
    d.text((50, y), "Item 1" + "." * 20 + "$10.99", fill=(0, 0, 0), font=font)
    y += 30
    d.text((50, y), "Item 2" + "." * 20 + "$15.00", fill=(0, 0, 0), font=font)
    y += 30
    d.text((50, y), "Item 3" + "." * 20 + "$17.00", fill=(0, 0, 0), font=font)
    y += 50
    
    # Totals
    d.text((50, y), "Subtotal" + "." * 20 + "$42.99", fill=(0, 0, 0), font=font)
    y += 30
    d.text((50, y), "Tax" + "." * 25 + "$3.44", fill=(0, 0, 0), font=font)
    y += 30
    d.text((50, y), "Total" + "." * 23 + "$46.43", fill=(0, 0, 0), font=font)
    
    # Save to file for inspection
    debug_path = os.path.join(os.path.dirname(__file__), 'test_receipt_debug.png')
    img.save(debug_path, format='PNG', quality=100)
    logger.info(f"Saved debug image to: {debug_path}")
    
    # Save to bytes for API
    img_byte_arr = io.BytesIO()
    img.save(img_byte_arr, format='PNG', quality=100)
    img_byte_arr.seek(0)
    return img_byte_arr

def test_upload():
    """Test receipt upload"""
    logger.info("\n=== Testing Upload API ===")
    
    try:
        # Create and prepare the test image
        img_data = create_test_receipt_image()
        logger.info("Test image created successfully")
        
        # Prepare the upload request
        files = {'file': ('test_receipt.png', img_data, 'image/png')}
        logger.info("Sending upload request to server...")
        
        # Make the request
        response = requests.post(f'{BASE_URL}/upload', files=files)
        logger.info(f"Upload response status code: {response.status_code}")
        
        # Parse and check the response
        response_data = response.json()
        logger.info(f"Upload response data: {response_data}")
        
        # Detailed response analysis
        assert response.status_code == 200
        assert 'content' in response_data
        logger.info("Upload successful!")
        if response_data.get('content') is None:
            logger.warning("OCR processing failed - content is None")
        else:
            logger.info("OCR processing successful")
            logger.info(f"Extracted content: {response_data['content']}")
    except Exception as e:
        logger.error(f"Test failed with error: {str(e)}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")

if __name__ == '__main__':
    # Test that logging is working
    logger.info("Starting upload test...")
    
    test_upload()
    
    sys.exit(0)

================
File: backend/__init__.py
================
# Empty file to make the directory a Python package

================
File: backend/app.py
================
from flask import Flask, jsonify
from flask_cors import CORS
from api.routes import api_bp
# from backend.api.routes import api_bp # Import the API blueprint
from config import config
import logging
from werkzeug.middleware.proxy_fix import ProxyFix
from werkzeug.exceptions import HTTPException
from api.errors import APIError, handle_api_error, handle_http_error, handle_generic_error

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

app = Flask(__name__)
app.register_blueprint(api_bp, url_prefix='/api') # Register API blueprint with /api prefix

# Configure CORS with timeout
CORS(app, resources={
    r"/api/*": {
        "origins": ["http://localhost:3000"],
        "methods": ["GET", "POST", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type"]
    }
})

app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

# Configure upload folder
app.config['UPLOAD_FOLDER'] = config.upload_folder
app.config['UPLOAD_TIMEOUT'] = 120
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size
app.config['PROPAGATE_EXCEPTIONS'] = True  # Enable full error reporting

# Register error handlers
app.register_error_handler(APIError, handle_api_error)
app.register_error_handler(HTTPException, handle_http_error)
app.register_error_handler(Exception, handle_generic_error)

# Register blueprints
# app.register_blueprint(api_bp, url_prefix='/api')

@app.route('/api/health')
def health_check():
    """Health check endpoint"""
    return jsonify({'status': 'ok'})

@app.errorhandler(Exception)
def handle_exception(e):
    # Log the exception details
    app.logger.error(f"Unhandled Exception: {str(e)}", exc_info=True)
    
    # Return a sanitized error response
    response = {
        "error": "An unexpected error occurred. Please try again later."
    }
    return jsonify(response), 500

if __name__ == '__main__':
    app.run(
        host='0.0.0.0', 
        port=3456, 
        debug=True,
        threaded=True
    )

================
File: backend/clean_receipts.py
================
from models.database import SessionLocal, Receipt
import os

def clean_receipt_paths():
    db = SessionLocal()
    try:
        # Get all receipts
        receipts = db.query(Receipt).all()
        
        for receipt in receipts:
            if receipt.image_path and '/' in receipt.image_path:
                # Extract just the filename from the full path
                old_path = receipt.image_path
                filename = os.path.basename(old_path)
                
                print(f"Updating receipt {receipt.id}:")
                print(f"  Old path: {old_path}")
                print(f"  New path: {filename}")
                
                # Update the path in the database
                receipt.image_path = filename
        
        # Commit the changes
        db.commit()
        print("\nDatabase updated successfully!")
        
    except Exception as e:
        print(f"Error: {str(e)}")
        db.rollback()
    finally:
        db.close()

if __name__ == '__main__':
    clean_receipt_paths()

================
File: backend/config.py
================
import os

class Config:
    """Base configuration"""
    def __init__(self):
        self.db_path = os.path.join('data', 'receipts.db')
        self.upload_folder = os.path.join('Receipts', 'uploads')
        
        # Single source of truth for expense categories
        self.expense_categories = [
            "Advertising",
            "Car and Truck Expenses",
            "Commissions and Fees",
            "Contract Labor",
            "Depletion",
            "Depreciation and Section 179 Expense Deduction",
            "Employee Benefit Programs",
            "Insurance (Other Than Health)",
            "Interest",
            "Legal and Professional Services",
            "Office Expenses",
            "Pension and Profit-Sharing Plans",
            "Rent or Lease",
            "Repairs and Maintenance",
            "Supplies",
            "Taxes and Licenses",
            "Travel",
            "Meals",
            "Utilities",
            "Wages",
            "Other Expenses"
        ]
        
        # Payment methods
        self.payment_methods = [
            "Credit Card",
            "Debit Card",
            "Cash",
            "Check",
            "Wire Transfer",
            "Other"
        ]
        
        # Receipt statuses
        self.receipt_statuses = [
            "Pending",
            "Approved",
            "Rejected"
        ]

class TestConfig(Config):
    """Test configuration"""
    def __init__(self):
        super().__init__()  # Call parent init to get the categories and other settings
        self.db_path = ':memory:'  # Use in-memory SQLite for tests
        self.upload_folder = 'test_uploads'

# Use test config if TESTING environment variable is set
config = TestConfig() if os.getenv('TESTING') else Config()

================
File: backend/init_db.py
================
from models.database import Base, get_engine

def init_db():
    Base.metadata.drop_all(bind=get_engine())
    Base.metadata.create_all(bind=get_engine())

if __name__ == '__main__':
    init_db()
    print("Database initialized")

================
File: backend/pytest.ini
================
[pytest]
filterwarnings =
    ignore:urllib3 v2 only supports OpenSSL:urllib3.exceptions.NotOpenSSLWarning 
pythonpath = .
testpaths = tests
python_files = test_*.py

================
File: backend/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-25T20:53:17.084Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
api/
  app.py
  errors.py
  routes.py
  services.py
migrations/
  add_status_column.py
  migrate_receipt_data.py
  run_migrations.py
models/
  __init__.py
  create_db.py
  database.py
  receipt.py
scripts/
  recreate_db.py
services/
  categorization_service.py
  categorization.py
  ocr_service_with_tessaract_not_working.py
  ocr_service.py
src/
  index.ts
tests/
  __init__.py
  base.py
  config.py
  conftest_integration.py
  conftest.py
  test_api_integration.py
  test_api_options.py
  test_api.py
  test_categorization.py
  test_config.py
  test_models.py
  test_receipt_updates.py
  test_upload.py
__init__.py
app.py
clean_receipts.py
config.py
init_db.py
pytest.ini
requirements.txt
run_tests.py

================================================================
Repository Files
================================================================

================
File: api/app.py
================
from flask import Flask
from werkzeug.exceptions import HTTPException
from .errors import APIError, handle_api_error, handle_http_error, handle_generic_error

app = Flask(__name__)

# Register error handlers
app.register_error_handler(APIError, handle_api_error)
app.register_error_handler(HTTPException, handle_http_error)
app.register_error_handler(Exception, handle_generic_error)

# ... rest of app configuration

================
File: api/errors.py
================
import logging
from typing import Dict, Any, Optional
from flask import jsonify
from werkzeug.exceptions import HTTPException

logger = logging.getLogger(__name__)

class APIError(Exception):
    """Base exception class for API errors"""
    def __init__(self, message: str, status_code: int = 400, details: Optional[Dict[str, Any]] = None):
        super().__init__()
        self.message = message
        self.status_code = status_code
        self.details = details or {}

    def to_dict(self) -> Dict[str, Any]:
        response = {
            'error': True,
            'message': self.message,
            'status_code': self.status_code
        }
        if self.details:
            response['details'] = self.details
        return response

def handle_api_error(error: APIError):
    """Handler for our custom APIError exceptions"""
    logger.error(f"API Error: {error.message}", extra={
        'status_code': error.status_code,
        'details': error.details
    })
    response = jsonify(error.to_dict())
    response.status_code = error.status_code
    return response

def handle_http_error(error: HTTPException):
    """Handler for Werkzeug HTTP exceptions"""
    logger.error(f"HTTP Error: {error.description}", extra={
        'status_code': error.code
    })
    response = jsonify({
        'error': True,
        'message': error.description,
        'status_code': error.code
    })
    response.status_code = error.code
    return response

def handle_generic_error(error: Exception):
    """Handler for unexpected exceptions"""
    logger.exception("Unexpected error occurred")
    response = jsonify({
        'error': True,
        'message': 'An unexpected error occurred',
        'status_code': 500
    })
    response.status_code = 500
    return response

================
File: api/routes.py
================
from flask import Blueprint, request, jsonify, current_app, send_from_directory
from werkzeug.utils import secure_filename
import os
import logging
from models.database import get_db, Receipt, ReceiptChangeHistory
from services.ocr_service import OCRService
from services.categorization_service import CategorizationService
import uuid
from PIL import Image
from datetime import datetime
from config import config
from functools import wraps
from http import HTTPStatus
from decimal import Decimal, InvalidOperation
import time
from .errors import APIError

# Configure logging
logger = logging.getLogger('api.routes')

api_bp = Blueprint('api', __name__)

def verify_image(filepath):
    """Verify image was saved correctly"""
    try:
        with Image.open(filepath) as img:
            logger.info(f"Image verified: {filepath} ({img.size}, {img.mode})")
            return True
    except Exception as e:
        logger.error(f"Image verification failed: {str(e)}")
        return False

def validate_request(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not request.is_json:
            raise APIError(
                "Request must be JSON",
                status_code=400,
                details={'content_type': request.content_type}
            )
        return f(*args, **kwargs)
    return decorated_function

def validate_field_values(data, receipt_id):
    errors = {}
    
    # Validate vendor
    if 'vendor' in data:
        if not isinstance(data['vendor'], str) or len(data['vendor']) > 100:
            errors['vendor'] = "Vendor must be a string of max 100 characters"
    
    # Validate amount
    if 'amount' in data:
        try:
            amount = Decimal(data['amount'])
            if amount <= 0 or amount > Decimal('999999.99'):
                errors['amount'] = "Amount must be between 0.01 and 999999.99"
        except InvalidOperation:
            errors['amount'] = "Amount must be a valid decimal number"
    
    # Validate date
    if 'date' in data:
        try:
            logger.info(f"Validating date field. Raw value: {data['date']!r}, Type: {type(data['date'])}")
            
            if not data['date']:
                logger.info("Empty date value received")
                return {'date': "Date cannot be empty"}
                
            date = datetime.strptime(data['date'], '%Y-%m-%d').date()
            logger.info(f"Successfully parsed date: {date}")
            
            if date > datetime.now().date():
                logger.error(f"Future date not allowed: {date}")
                return {'date': "Date cannot be in the future"}
                
            logger.info(f"Date validation successful: {date}")
            
        except ValueError as e:
            logger.error(f"Date validation error: {str(e)}, received value: {data['date']!r}, type: {type(data['date'])}")
            return {'date': "Date must be in YYYY-MM-DD format"}
        except Exception as e:
            logger.error(f"Unexpected error validating date: {str(e)}, received value: {data['date']!r}, type: {type(data['date'])}")
            return {'date': "Invalid date format"}
    
    # Validate category - case insensitive
    if 'category' in data:
        category = data['category'].lower()
        if category not in [cat.lower() for cat in config.expense_categories]:
            errors['category'] = f"Category must be one of: {', '.join(config.expense_categories)}"
    
    # Validate payment_method - case insensitive
    if 'payment_method' in data:
        payment_method = data['payment_method'].lower()
        if payment_method not in [pm.lower() for pm in config.payment_methods]:
            errors['payment_method'] = f"Payment method must be one of: {', '.join(config.payment_methods)}"
    
    # Validate status - case insensitive and transitions
    if 'status' in data:
        new_status = data['status'].lower()
        if new_status not in [status.lower() for status in config.receipt_statuses]:
            errors['status'] = f"Status must be one of: {', '.join(config.receipt_statuses)}"
        else:
            # Get current status if updating an existing receipt
            try:
                with get_db() as db:
                    receipt = db.query(Receipt).get(receipt_id)
                    if receipt:
                        current_status = receipt.status.lower()
                        valid_transition = False
                        
                        if current_status == 'pending':
                            valid_transition = new_status in ['approved', 'rejected']
                        elif current_status == 'approved':
                            valid_transition = new_status in ['pending', 'rejected']
                        elif current_status == 'rejected':
                            valid_transition = new_status in ['approved', 'pending']
                            
                        if not valid_transition:
                            errors['status'] = f"Invalid status transition from {current_status} to {new_status}"
            except Exception as e:
                logger.error(f"Error checking status transition: {str(e)}")
    
    return errors

@api_bp.route('/upload', methods=['POST'])
def upload_file():
    logger.info("Received upload request")
    try:
        if 'file' not in request.files:
            raise APIError("No file part in request", status_code=400)
        
        file = request.files['file']
        if file.filename == '':
            raise APIError("No selected file", status_code=400)
        
        logger.info(f"Processing file: {file.filename}")
        
        # Generate unique filename
        original_filename = secure_filename(file.filename)
        saved_filename = f"{uuid.uuid4()}_{original_filename}"
        filepath = os.path.join(current_app.config['UPLOAD_FOLDER'], saved_filename)
        
        # Save file
        file.save(filepath)
        logger.info(f"File saved to: {filepath}")
        
        # Verify image
        if not verify_image(filepath):
            raise APIError("Failed to verify saved image", status_code=400)
        
        try:
            # Process with OCR
            ocr_result = OCRService.extract_receipt_data(filepath)
            receipt_data = ocr_result['content']
            logger.info(f"Receipt data: {receipt_data}")
            
            # Add categorization step
            try:
                category = CategorizationService.categorize_receipt(receipt_data)
                logger.info(f"Categorized as: {category}")
            except Exception as e:
                logger.error(f"Categorization error: {str(e)}")
                category = "Other expenses"
            
            # Save to database
            with get_db() as db:
                receipt = Receipt(
                    image_path=saved_filename,
                    content=receipt_data,
                    category=category,
                    vendor=receipt_data.get('Vendor', ''),
                    amount=receipt_data.get('Amount', '0.00'),
                    date=receipt_data.get('Date', ''),
                    payment_method=receipt_data.get('Payment_Method', ''),
                    status='pending'
                )
                db.add(receipt)
                db.commit()
                
                return jsonify(receipt.to_dict())
                
        except Exception as e:
            # Clean up file if processing failed
            try:
                os.remove(filepath)
            except:
                pass
            logger.error(f"Processing error: {str(e)}")
            raise APIError("Failed to process receipt", status_code=500, details={'error': str(e)})
        
    except APIError:
        raise
    except Exception as e:
        logger.error(f"Upload error: {str(e)}")
        raise APIError("Failed to upload receipt", status_code=500, details={'error': str(e)})

@api_bp.route('/receipts', methods=['GET'])
def get_receipts():
    start_time = time.time()
    try:
        with get_db() as db:
            receipts = db.query(Receipt).all()
            return jsonify([r.to_dict() for r in receipts])
    except Exception as e:
        logger.error(f"Failed to get receipts: {str(e)}")
        raise APIError("Failed to fetch receipts", status_code=500, details={'error': str(e)})
    finally:
        execution_time = time.time() - start_time
        logger.info(f"Execution time for get_receipts: {execution_time:.2f} seconds")

@api_bp.route('/receipts/<int:receipt_id>', methods=['GET'])
def get_receipt(receipt_id):
    """Get a single receipt by ID"""
    try:
        with get_db() as db:
            receipt = db.query(Receipt).get(receipt_id)
            if not receipt:
                raise APIError("Receipt not found", status_code=404)
            return jsonify(receipt.to_dict())
    except APIError:
        raise
    except Exception as e:
        logger.error(f"Failed to get receipt {receipt_id}: {str(e)}")
        raise APIError("Failed to fetch receipt", status_code=500)

@api_bp.route('/receipts/<int:receipt_id>/update', methods=['PATCH'])
@validate_request
def update_receipt_fields(receipt_id):
    data = request.get_json()

    # Validate input data
    validation_errors = validate_field_values(data, receipt_id)
    if validation_errors:
        raise APIError(
            "Invalid field values",
            status_code=400,
            details=validation_errors
        )

    try:
        with get_db() as db:
            receipt = db.query(Receipt).get(receipt_id)
            if not receipt:
                raise APIError("Receipt not found", status_code=404)

            # Track changes and update fields
            updated_fields = {}
            for field in ['vendor', 'amount', 'date', 'payment_method', 'category', 'status']:
                # Only update fields present in the request data
                if field in data:
                    old_value = getattr(receipt, field)
                    new_value = data[field].lower() if field == 'status' else data[field]

                    if old_value != new_value:
                        # Create change history record
                        change = ReceiptChangeHistory(
                            receipt_id=receipt_id,
                            field_name=field,
                            new_value=new_value,
                            changed_at=datetime.utcnow(),
                            changed_by="system"  # Replace with actual user ID when auth is implemented
                        )
                        db.add(change)

                        # Update receipt field
                        setattr(receipt, field, new_value)
                        updated_fields[field] = new_value

            # Commit the changes
            db.commit()

            # Return the full receipt data, preserving all fields
            receipt_data = {
                "id": receipt.id,
                "image_path": receipt.image_path,
                "vendor": receipt.vendor,
                "amount": receipt.amount,
                "date": receipt.date,
                "payment_method": receipt.payment_method,
                "category": receipt.category,
                "status": receipt.status,
                "content": receipt.content,
            }

            return jsonify({
                "success": True,
                "receipt_id": receipt_id,
                "updated_fields": updated_fields,
                "updated_at": datetime.utcnow().isoformat(),
                "receipt": receipt_data,
            }), HTTPStatus.OK

    except APIError:
        raise
    except Exception as e:
        logger.error(f"Failed to update receipt {receipt_id}: {str(e)}")
        raise APIError(
            "Failed to update receipt",
            status_code=500,
            details={'error': str(e)}
        )

@api_bp.route('/receipts/<int:receipt_id>', methods=['DELETE'])
def delete_receipt(receipt_id):
    """Delete a receipt"""
    try:
        with get_db() as db:
            receipt = db.query(Receipt).get(receipt_id)
            if not receipt:
                raise APIError("Receipt not found", status_code=404)

            # Delete image file
            try:
                image_path = os.path.join(current_app.config['UPLOAD_FOLDER'], receipt.image_path)
                if os.path.exists(image_path):
                    os.remove(image_path)
                    logger.info(f"Deleted image file: {image_path}")
            except Exception as e:
                logger.error(f"Failed to delete image: {str(e)}")
                raise APIError("Failed to delete image file", status_code=500)

            # Delete database record
            db.delete(receipt)
            logger.info(f"Deleted receipt: {receipt_id}")
            
            return jsonify({'message': 'Receipt deleted successfully'})
            
    except APIError:
        raise
    except Exception as e:
        logger.error(f"Failed to delete receipt {receipt_id}: {str(e)}")
        raise APIError("Failed to delete receipt", status_code=500)

@api_bp.route('/images/<path:filename>')
def get_image(filename):
    """Serve receipt images"""
    return send_from_directory(current_app.config['UPLOAD_FOLDER'], filename)

@api_bp.route('/receipts/<int:receipt_id>/history', methods=['GET'])
def get_receipt_history(receipt_id):
    try:
        with get_db() as db:
            # Verify receipt exists
            receipt = db.query(Receipt).get(receipt_id)
            if not receipt:
                raise APIError("Receipt not found", status_code=404)

            # Get changes ordered by timestamp
            changes = db.query(ReceiptChangeHistory)\
                       .filter(ReceiptChangeHistory.receipt_id == receipt_id)\
                       .order_by(ReceiptChangeHistory.changed_at.desc())\
                       .all()

            return jsonify([{
                'field': change.field_name,
                'new_value': change.new_value,
                'changed_at': change.changed_at.isoformat(),
                'changed_by': change.changed_by
            } for change in changes])

    except APIError:
        raise
    except Exception as e:
        logger.error(f"Failed to get history for receipt {receipt_id}: {str(e)}")
        raise APIError("Failed to fetch receipt history", status_code=500, details={'error': str(e)})

@api_bp.route('/process', methods=['POST'])
def process_document():
    try:
        if not request.files:
            raise APIError("No file provided", status_code=400)

        file = request.files.get('file')
        if not file:
            raise APIError("File field is required", status_code=400)

        # Validate file type
        if not allowed_file(file.filename):
            raise APIError(
                "Invalid file type", 
                status_code=400, 
                details={'allowed_types': ALLOWED_EXTENSIONS}
            )

        # Process the document
        result = ocr_service.process(file)
        
        logger.info("Document processed successfully", extra={
            'filename': file.filename,
            'result_length': len(result)
        })
        
        return jsonify({
            'success': True,
            'data': result
        })

    except OCRServiceError as e:
        raise APIError(
            "OCR processing failed",
            status_code=422,
            details={'ocr_error': str(e)}
        )

@api_bp.route('/categorize', methods=['POST'])
def categorize_text():
    try:
        data = request.get_json()
        if not data:
            raise APIError("No JSON data provided", status_code=400)

        text = data.get('text')
        if not text:
            raise APIError("Text field is required", status_code=400)

        # Categorize the text
        categories = categorization_service.categorize(text)
        
        logger.info("Text categorized successfully", extra={
            'text_length': len(text),
            'categories_count': len(categories)
        })
        
        return jsonify({
            'success': True,
            'categories': categories
        })

    except CategorizationError as e:
        raise APIError(
            "Categorization failed",
            status_code=422,
            details={'categorization_error': str(e)}
        )

@api_bp.route('/options', methods=['GET'])
def get_options():
    """Get all available options for filters"""
    try:
        with get_db() as db:
            # Get unique vendors from database
            vendors = [r[0] for r in db.query(Receipt.vendor).distinct().all() if r[0] != 'Missing']
            
            return jsonify({
                'categories': config.expense_categories,
                'payment_methods': config.payment_methods,
                'statuses': config.receipt_statuses,
                'vendors': sorted(vendors)
            })
    except Exception as e:
        logger.error(f"Failed to get options: {str(e)}")
        raise APIError("Failed to fetch options", status_code=500, details={'error': str(e)})

================
File: api/services.py
================
class OCRServiceError(Exception):
    """Custom exception for OCR service errors"""
    pass

class CategorizationError(Exception):
    """Custom exception for categorization service errors"""
    pass

class OCRService:
    def process(self, file):
        try:
            # OCR processing logic
            pass
        except Exception as e:
            raise OCRServiceError(f"OCR processing failed: {str(e)}")

class CategorizationService:
    def categorize(self, text):
        try:
            # Categorization logic
            pass
        except Exception as e:
            raise CategorizationError(f"Categorization failed: {str(e)}")

================
File: migrations/add_status_column.py
================
from sqlalchemy import create_engine, text
from backend.config import DATABASE_URL

def upgrade():
    engine = create_engine(DATABASE_URL)
    with engine.connect() as connection:
        # Add status column with 'pending' as default
        connection.execute(text("""
            ALTER TABLE receipts 
            ADD COLUMN status VARCHAR(20) DEFAULT 'pending' NOT NULL;
        """))
        connection.commit()

def downgrade():
    engine = create_engine(DATABASE_URL)
    with engine.connect() as connection:
        connection.execute(text("""
            ALTER TABLE receipts 
            DROP COLUMN status;
        """))
        connection.commit()

if __name__ == "__main__":
    upgrade()

================
File: migrations/migrate_receipt_data.py
================
from datetime import datetime
from decimal import Decimal
from models.database import get_db, Receipt, ExpenseCategory

def convert_amount(amount_str):
    """Convert amount string to Decimal"""
    if not amount_str or amount_str == 'Missing':
        return Decimal('0.00')
    # Remove currency symbols and convert to Decimal
    cleaned = amount_str.replace('$', '').replace(',', '').strip()
    try:
        return Decimal(cleaned)
    except:
        return Decimal('0.00')

def convert_date(date_str):
    """Convert date string to datetime"""
    if not date_str or date_str == 'Missing':
        return datetime.utcnow()
    try:
        # Add more date formats as needed
        for fmt in ['%Y-%m-%d', '%m/%d/%Y', '%d/%m/%Y']:
            try:
                return datetime.strptime(date_str, fmt)
            except ValueError:
                continue
        return datetime.utcnow()
    except:
        return datetime.utcnow()

def convert_category(category_str):
    """Convert category string to ExpenseCategory enum"""
    if not category_str or category_str == 'Missing':
        return ExpenseCategory.OTHER
    
    # Try to match with enum values
    try:
        return next(
            (cat for cat in ExpenseCategory 
             if cat.value.lower() == category_str.lower()),
            ExpenseCategory.OTHER
        )
    except:
        return ExpenseCategory.OTHER

def migrate_data():
    """Migrate existing receipt data to new schema"""
    with get_db() as db:
        receipts = db.query(Receipt).all()
        
        for receipt in receipts:
            # Convert amount to Decimal
            receipt.amount = convert_amount(receipt.amount)
            
            # Convert date to datetime
            receipt.date = convert_date(receipt.date)
            
            # Convert category to enum
            receipt.category = convert_category(receipt.category)
        
        db.commit()

if __name__ == '__main__':
    migrate_data()
    print("Migration completed successfully")

================
File: migrations/run_migrations.py
================
import os
import importlib.util

def run_migrations():
    migrations_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Get all .py files in migrations directory
    migration_files = [f for f in os.listdir(migrations_dir) 
                      if f.endswith('.py') and f != '__init__.py' 
                      and f != 'run_migrations.py']
    
    for migration_file in sorted(migration_files):
        print(f"Running migration: {migration_file}")
        
        # Import and run migration
        spec = importlib.util.spec_from_file_location(
            migration_file[:-3],
            os.path.join(migrations_dir, migration_file)
        )
        migration = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(migration)
        
        try:
            migration.upgrade()
            print(f"Successfully completed migration: {migration_file}")
        except Exception as e:
            print(f"Error running migration {migration_file}: {str(e)}")
            raise

if __name__ == "__main__":
    run_migrations()

================
File: models/__init__.py
================
from .database import Base, get_db, Receipt, get_engine

================
File: models/create_db.py
================
from database import Base, get_engine

def init_db():
    Base.metadata.drop_all(bind=get_engine())  # Warning: This drops existing tables
    Base.metadata.create_all(bind=get_engine())

if __name__ == '__main__':
    init_db()
    print("Database initialized")

================
File: models/database.py
================
from sqlalchemy import create_engine, Column, Integer, String, JSON, DateTime, Numeric, ForeignKey, Enum, inspect
from sqlalchemy.orm import declarative_base, relationship
from sqlalchemy.orm import sessionmaker
from config import config
from contextlib import contextmanager
from datetime import datetime
import os
import enum
from decimal import Decimal

Base = declarative_base()

def get_engine():
    """Get SQLAlchemy engine, creating database directory if needed"""
    db_dir = os.path.dirname(config.db_path)
    if not os.path.exists(db_dir):
        os.makedirs(db_dir)
    return create_engine(f'sqlite:///{config.db_path}')

# Dynamically create ExpenseCategory enum from config
ExpenseCategory = enum.Enum(
    'ExpenseCategory',
    {category.upper().replace(' ', '_'): category for category in config.expense_categories}
)

class Receipt(Base):
    """Receipt database model"""
    __tablename__ = 'receipts'

    id = Column(Integer, primary_key=True)
    image_path = Column(String, nullable=False)
    vendor = Column(String)
    amount = Column(String)  # Back to String to handle 'Missing'
    date = Column(String)    # Back to String to handle 'Missing'
    payment_method = Column(String)
    category = Column(String)  # Back to String to handle 'Missing'
    content = Column(JSON, nullable=False)
    status = Column(String(20), nullable=False, default='pending')
    # Relationship to change history
    changes = relationship(
        "ReceiptChangeHistory",
        back_populates="receipt",
        cascade="all, delete-orphan"
    )

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if self.content:
            # Flatten nested JSON structure recursively
            def flatten_dict(d, parent_key='', sep='_'):
                items = []
                for k, v in d.items():
                    new_key = f"{parent_key}{sep}{k}" if parent_key else k
                    if isinstance(v, dict):
                        items.extend(flatten_dict(v, new_key, sep=sep).items())
                    else:
                        items.append((new_key, v))
                return dict(items)

            # Flatten and convert to lowercase
            flattened = flatten_dict(self.content)
            content_lower = {k.lower(): v for k, v in flattened.items()}
            
            # Set fields directly from content, defaulting to 'Missing'
            self.vendor = content_lower.get('vendor') or self.vendor or 'Missing'
            self.amount = content_lower.get('amount') or self.amount or 'Missing'
            self.date = content_lower.get('date') or self.date or 'Missing'
            self.payment_method = content_lower.get('payment_method') or self.payment_method or 'Missing'
            
            # Handle category
            if not self.category:
                from services.categorization_service import CategorizationService
                self.category = CategorizationService.categorize_receipt(self.content)

    def to_dict(self):
        """Convert receipt to dictionary"""
        return {
            'id': self.id,
            'image_path': self.image_path,
            'vendor': self.vendor or 'Missing',
            'amount': self.amount or 'Missing',
            'date': self.date or 'Missing',
            'payment_method': self.payment_method or 'Missing',
            'category': self.category or 'Other Expenses',
            'content': self.content,
            'status': self.status
        }

class ReceiptChangeHistory(Base):
    __tablename__ = 'receipt_change_history'

    id = Column(Integer, primary_key=True)
    #receipt_id = Column(Integer, ForeignKey('receipts.id'), nullable=False)
    receipt_id = Column(Integer, ForeignKey('receipts.id', ondelete="CASCADE"), nullable=False)
    field_name = Column(String, nullable=False)
    new_value = Column(String, nullable=False)
    changed_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    changed_by = Column(String, nullable=True)  # Will be used later for user tracking

    # Relationship to receipt
    receipt = relationship("Receipt", back_populates="changes")

# Initialize database
engine = get_engine()
Base.metadata.create_all(engine)
SessionLocal = sessionmaker(bind=engine)

@contextmanager
def get_db():
    """Database session context manager"""
    db = SessionLocal()
    try:
        yield db
        db.commit()
    except Exception:
        db.rollback()
        raise
    finally:
        db.close()

# Drop all tables and recreate - should only be called explicitly
def init_db():
    Base.metadata.drop_all(engine)
    Base.metadata.create_all(engine)

# Only create tables if they don't exist
inspector = inspect(engine)
if not inspector.has_table('receipts'):
    Base.metadata.create_all(engine)

================
File: models/receipt.py
================
from sqlalchemy import Column, String, Integer, DateTime, Text
from backend.database import Base

class Receipt(Base):
    __tablename__ = 'receipts'
    
    id = Column(Integer, primary_key=True)
    image_path = Column(String(255), nullable=False)
    vendor = Column(String(255))
    amount = Column(String(50))
    date = Column(String(50))
    payment_method = Column(String(50))
    category = Column(String(50))
    content = Column(Text)
    status = Column(String(20), nullable=False, default='pending')

================
File: scripts/recreate_db.py
================
from backend.database import Base, engine
from backend.models.receipt import Receipt

def recreate_database():
    print("Dropping all tables...")
    Base.metadata.drop_all(engine)
    
    print("Creating all tables...")
    Base.metadata.create_all(engine)
    
    print("Database recreation completed successfully!")

if __name__ == "__main__":
    recreate_database()

================
File: services/categorization_service.py
================
import os
from openai import OpenAI
from typing import Dict, Optional
from config import config

client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))

class CategorizationService:
    @staticmethod
    def categorize_receipt(content: Dict) -> str:
        """Categorize receipt based on its content using LLM"""
        try:
            prompt = f"""
            Analyze this receipt and categorize it into one of these IRS Schedule C expense categories:
            {', '.join(config.expense_categories)}

            Receipt details:
            Vendor: {content.get('Vendor', '')}
            Items/Description: {content.get('text', [])}

            Return only the category name, nothing else.
            """

            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=50
            )

            category = response.choices[0].message.content.strip()
            return category if category in config.expense_categories else "Other Expenses"
            
        except Exception as e:
            print(f"Categorization error: {str(e)}")
            return "Other Expenses"

================
File: services/categorization.py
================
import logging

logger = logging.getLogger(__name__)

def categorize_document(document):
    try:
        # ... existing logic ...
    except KeyError as e:
        logger.error(f"Missing key in document: {str(e)}", exc_info=True)
        return {"error": "Document is missing required fields"}, 400
    except Exception as e:
        logger.error(f"Unexpected error in document categorization: {str(e)}", exc_info=True)
        return {"error": "Document categorization failed"}, 500

================
File: services/ocr_service_with_tessaract_not_working.py
================
import json
import logging
import ollama
import pytesseract
from PIL import Image
import cv2
import numpy as np
from config import config

logger = logging.getLogger(__name__)

def preprocess_image(image_path):
    """Preprocess image for better OCR results"""
    try:
        # Read image using opencv
        image = cv2.imread(image_path)
        
        # Convert to grayscale
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        
        # Apply adaptive thresholding
        gray = cv2.adaptiveThreshold(
            gray, 
            255, 
            cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
            cv2.THRESH_BINARY, 
            11, 
            2
        )
        
        # Denoise the image
        gray = cv2.fastNlMeansDenoising(gray)
        
        # Scale the image (upsampling might help with text recognition)
        scale_factor = 2
        gray = cv2.resize(gray, None, fx=scale_factor, fy=scale_factor, interpolation=cv2.INTER_CUBIC)
        
        return gray
    except Exception as e:
        logger.error(f"Error preprocessing image: {str(e)}")
        raise

def extract_text_with_tesseract(image):
    """Extract text from image using Tesseract"""
    try:
        # Configure Tesseract parameters for better accuracy
        custom_config = r'--oem 3 --psm 6 -c tessedit_char_whitelist="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@.,()-:/$% "'
        
        # Extract text
        text = pytesseract.image_to_string(
            image,
            config=custom_config,
            lang='eng'  # Explicitly specify English language
        )
        
        # Get detailed OCR data including positions
        ocr_data = pytesseract.image_to_data(image, output_type=pytesseract.Output.DICT)
        
        return text, ocr_data
    except Exception as e:
        logger.error(f"Tesseract OCR failed: {str(e)}")
        raise

def clean_json_text(json_text: str) -> str:
    """Clean and format JSON text for parsing"""
    import re
    
    # Find the first complete JSON object
    start = json_text.find('{')
    end = json_text.rfind('}') + 1
    if start >= 0 and end > start:
        json_text = json_text[start:end]
    
    # Clean up currency format - remove $ and ensure USD suffix
    json_text = re.sub(r'\$?(\d+\.\d{2})(?!\s*USD)', r'\1 USD', json_text)
    
    # Fix quoted null values
    json_text = re.sub(r'"null"', r'null', json_text)
    
    # Fix common JSON formatting issues
    json_text = re.sub(r'}\s*{', '},{', json_text)  # Add comma between objects
    json_text = re.sub(r'}\s*"', '},"', json_text)  # Add comma after closing brace
    json_text = re.sub(r']\s*"', '],"', json_text)  # Add comma after closing bracket
    json_text = re.sub(r'\s+', ' ', json_text)      # Normalize whitespace
    
    # Remove any control characters
    json_text = ''.join(char for char in json_text if ord(char) >= 32 or char in '\n\r\t')
    
    # Try to parse and re-serialize to ensure valid JSON
    try:
        parsed = json.loads(json_text)
        return json.dumps(parsed, indent=4)
    except json.JSONDecodeError:
        return json_text.strip()

class OCRService:
    @staticmethod
    def extract_receipt_data(image_path):
        """Extract receipt data using hybrid approach: Tesseract + Llama"""
        try:
            logger.info(f"Starting OCR process for image: {image_path}")
            
            # Step 1: Preprocess the image
            preprocessed_image = preprocess_image(image_path)
            
            # Step 2: Extract text using Tesseract
            raw_text, ocr_data = extract_text_with_tesseract(preprocessed_image)
            if not raw_text.strip():
                logger.error("No text extracted from the image. Check preprocessing or OCR steps.\n")
                # raise ValueError("OCR failed to extract text.")
            else:
                # Log the extracted text    
                logger.info("=" * 50)
                logger.info("TESSERACT OCR OUTPUT:")
                logger.info("=" * 50)
                logger.info(f"{raw_text}")
                logger.info("=" * 50)

            # Read original image for Llama
            with open(image_path, 'rb') as f:
                image_bytes = f.read()

            # Step 3: Use Llama to interpret the extracted text and image
            logger.info("Calling Llama for contextual understanding...")
            try:
                # Prepare the prompt template
                prompt_template = """IMPORTANT: Return ONLY a JSON object with EXACTLY these field names and structure. No explanations, no markdown, no analysis - just the JSON.

You are an advanced AI tasked with interpreting raw text extracted from a receipt or invoice, along with their image, and organizing it into a clean JSON format. Follow the instructions carefully to ensure accurate and structured data extraction based solely on the image and the raw text.

### Input ###
You will receive raw text extracted from a receipt or invoice using Tesseract. The text may include details about the buyer, vendor, items purchased, and totals. You will also receive the image of the receipt or invoice.

### Instructions ###
1. **Extract Only Visible Information:**
   - Do not make assumptions or add information not explicitly provided in the text.
   - Ignore fields that are missing or unclear. Use `null` for such fields in the JSON.

2. **Organize Data into a JSON Structure: as a minimum include the following fields, but if there are other fields that are present in the text/image, include them as well:**
    - `"purchased_by"`: Information about the buyer or customer.
    - `"vendor"`: Information about the vendor, store, or service provider.
    - `"order_summary"`: An array of items or services purchased, each including:
        - `"description"`: Description of the item or service.
        - `"price"`: The price per unit (formatted as a plain number with "USD").
        - `"quantity"`: The quantity of the item purchased.
        - `"subtotal"`: The calculated subtotal for the item (price × quantity).
        - `"tax"`: The tax rate applied to the item (if available).
    - `"totals"`: Information about the total cost of the transaction, including:
        - `"subtotal"`: The sum of all item subtotals (before taxes and discounts).
        - `"tax"`: The total tax applied to the purchase.
        - `"total"`: The total amount due, including taxes and discounts.
        - `"amount_paid"`: The amount paid by the customer.
        - `"balance_due"`: Any remaining balance due after payment.
    - `"comments"`: Any additional terms, policies, or notes provided in the receipt.

3. **Use Standardized Formatting:**
   - Use "USD" for currency values and "%" for percentages in tax rates.
   - Ensure the JSON is clean and free of special characters, non-standard formatting, or unnecessary explanations.

4. **DO NOT INVENT OR ASSUME:**
   - Avoid adding text, policies, or terms unless explicitly stated.
   - If subtotal, tax, or total fields are unclear or inconsistent, report them as `null`.

### Example Output. ONLY use it as an example to structure your response. ###
{
    "purchased_by": {
        "name": null,
        "email": null,
        "order_id": "US-001",
        "order_time": "11/02/2019",
        "order_type": "In-Person"
    },
    "vendor": {
        "name": "East Repair Inc.",
        "address": {
            "street": "1912 Harvest Lane",
            "city_state_zip": "New York, NY 12210"
        },
        "contact": {
            "phone": null,
            "fax": null,
            "email": null,
            "website": null
        }
    },
    "order_summary": [
        {
            "description": "Front and rear brake cables",
            "price": "100.00 USD",
            "quantity": 1,
            "subtotal": "100.00 USD",
            "tax": null
        },
        {
            "description": "New set of pedal arms",
            "price": "15.00 USD",
            "quantity": 2,
            "subtotal": "30.00 USD",
            "tax": null
        },
        {
            "description": "Labor 3hrs",
            "price": "5.00 USD",
            "quantity": 3,
            "subtotal": "15.00 USD",
            "tax": null
        }
    ],
    "totals": {
        "subtotal": "145.00 USD",
        "tax": "9.06 USD",
        "total": "154.06 USD",
        "amount_paid": null,
        "balance_due": "0.00 USD"
    },
    "comments": "string or null"
}

### Task ###
Analyze the raw text and the image below to extract the data, and return the structured JSON in the format described above. Ensure accuracy by only using the visible text from the input. IMPORTANT: Your response must be a single, valid JSON object only. No markdown, no explanations, no code blocks - just the JSON starting with { and ending with }. 

Raw OCR Text:
"""
                # Combine the prompt template with the raw text
                full_prompt = prompt_template + raw_text

                response = ollama.chat(
                    model='llama3.2-vision',
                    messages=[{
                        'role': 'user',
                        'content': full_prompt,
                        'images': [image_bytes]
                    }],
                    stream=False
                )
                logger.info("Successfully received response from Llama")

                content = response['message']['content']
                logger.info(f"Raw content from Llama: {content}")

                # Clean and parse the JSON
                try:
                    cleaned_json = clean_json_text(content)
                    data = json.loads(cleaned_json)
                    
                    # Post-process the data
                    if isinstance(data, dict):
                        # Ensure all currency values have USD
                        for key in data.get('totals', {}):
                            if data['totals'][key] and isinstance(data['totals'][key], str):
                                if data['totals'][key].replace('.', '').isdigit():
                                    data['totals'][key] = f"{float(data['totals'][key]):.2f} USD"
                        
                        # Ensure all items in order_summary have proper currency format
                        for item in data.get('order_summary', []):
                            for key in ['price', 'discount_amount', 'service_charge', 'subtotal']:
                                if item.get(key) and isinstance(item[key], str):
                                    if item[key].replace('.', '').isdigit():
                                        item[key] = f"{float(item[key]):.2f} USD"
                    
                    logger.info(f"Successfully parsed and processed JSON: {data}")
                    return {'content': data}
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to parse JSON: {str(e)}")
                    logger.error(f"Raw content: {content}")
                    logger.error(f"Cleaned content: {cleaned_json}")
                    return {'content': f"Error parsing JSON: {str(e)}", 'raw_content': content, 'cleaned_content': cleaned_json}

            except Exception as e:
                logger.error(f"Failed to process with Llama: {str(e)}")
                return {'content': f"Processing Error: {str(e)}"}
            
        except Exception as e:
            logger.error(f"OCR process failed: {str(e)}")
            return {'content': f"OCR Error: {str(e)}"}

================
File: services/ocr_service.py
================
import os
import json
import base64
import logging
from openai import OpenAI
from dotenv import load_dotenv
 
# Load environment variables
load_dotenv()

logger = logging.getLogger(__name__)

# Initialize the OpenAI client with error handling
try:
    client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
    if not os.getenv('OPENAI_API_KEY'):
        logger.error("OPENAI_API_KEY not found in environment variables")
except Exception as e:
    logger.error(f"Failed to initialize OpenAI client: {str(e)}")
    raise

def clean_json_text(json_text: str) -> str:
    """Clean and format JSON text for parsing"""
    import re
    
    # Remove markdown code block syntax and headers
    json_text = re.sub(r'\*\*.*?\*\*', '', json_text)
    json_text = re.sub(r'Here is the extracted data.*?structure:', '', json_text)
    json_text = re.sub(r'```json\s*', '', json_text)
    json_text = re.sub(r'```\s*', '', json_text)
    json_text = re.sub(r'Note:.*', '', json_text)
    
    # Find the JSON object
    start = json_text.find('{')
    end = json_text.rfind('}') + 1
    if start >= 0 and end > start:
        json_text = json_text[start:end]
    
    # Only clean up currency format if needed
    json_text = re.sub(r'\$(\d+\.\d{2})(?!\s*USD)', r'\1 USD', json_text)
    
    # Remove any control characters
    json_text = ''.join(char for char in json_text if ord(char) >= 32 or char in '\n\r\t')
    
    return json_text.strip()

class OCRService:
    @staticmethod
    def extract_receipt_data(image_path):
        """Extract receipt data using gpt-4o-mini"""
        try:
            logger.info(f"Processing receipt image: {image_path}")
            
            # Read image file and convert to base64
            try:
                with open(image_path, 'rb') as f:
                    image_bytes = f.read()
                base64_image = base64.b64encode(image_bytes).decode('utf-8')
            except Exception as e:
                logger.error(f"Failed to read image file: {str(e)}")
                raise

            try:
                response = client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[
                        {
                            "role": "user",
                            "content": [
                                {
                                    "type": "text",
                                    "text": """Extract the text from this image and format the output as a JSON object with two parts:
1. The main fields at the root level (use exactly these field names):
   - Vendor
   - Amount
   - Date
   - Payment_Method

2. A 'text' array containing all lines of text from the receipt in order, preserving the original formatting and content.

Example format:
{
    "Vendor": "store name",
    "Amount": "total amount",
    "Date": "receipt date",
    "Payment_Method": "payment type",
    "text": [
        "line 1 of receipt",
        "line 2 of receipt",
        ...
    ]
}

Capture every line of text, including store details, items, prices, subtotals, taxes, and any additional information."""
                                },  
                                {
                                    "type": "image_url",
                                    "image_url": {
                                        "url": f"data:image/jpeg;base64,{base64_image}"
                                    }
                                }
                            ]
                        }
                    ],
                    max_tokens=1000
                )
                
                content = response.choices[0].message.content

                try:
                    # Clean and format the entire response
                    cleaned_json = clean_json_text(content)
                    data = json.loads(cleaned_json)
                    return {'content': data}
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to parse OCR response: {str(e)}")
                    return {'content': f"Error parsing JSON: {str(e)}"}

            except Exception as e:
                logger.error(f"Failed to process image with Vision API: {str(e)}")
                return {'content': f"Vision API Error: {str(e)}"}
            
        except Exception as e:
            logger.error(f"OCR process failed: {str(e)}")
            return {'content': f"OCR Error: {str(e)}"}

================
File: src/index.ts
================
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const port = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

// Basic health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});

================
File: tests/__init__.py
================
import logging

# Configure logging for tests
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

================
File: tests/base.py
================
import logging
import requests
import time
from PIL import Image, ImageDraw
import io
import sys

# Configure logging
logger = logging.getLogger(__name__)

class BaseTest:
    """Base class for API tests"""
    
    BASE_URL = 'http://localhost:3456/api'
    UPLOAD_TIMEOUT = 120  # 2 minutes for upload/OCR
    REQUEST_TIMEOUT = 30  # 30 seconds for other requests

    @classmethod
    def wait_for_server(cls, timeout=30, interval=2):
        """Wait for server to become available"""
        logger.info("Checking server availability...")
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                response = requests.get(f'{cls.BASE_URL}/health')
                if response.status_code == 200:
                    logger.info("Server is available")
                    return True
            except requests.ConnectionError:
                logger.debug(f"Server not ready, retrying in {interval} seconds...")
            time.sleep(interval)
        
        logger.error(f"Server did not become available within {timeout} seconds")
        return False

    @staticmethod
    def create_test_receipt_image():
        """Create a test receipt image"""
        logger.info("Creating test receipt image...")
        
        # Create image
        width, height = 576, 1000
        img = Image.new('RGB', (width, height), color=(250, 250, 250))
        draw = ImageDraw.Draw(img)
        
        # Add content
        y = 50
        draw.text((width//2 - 50, y), "TEST STORE", fill=(0, 0, 0))
        y += 50
        draw.text((50, y), "Date: 2024-01-20", fill=(0, 0, 0))
        y += 50
        
        # Add items
        items = [
            ("Item 1", "$10.99"),
            ("Item 2", "$15.00"),
            ("Item 3", "$17.00")
        ]
        for item, price in items:
            draw.text((50, y), f"{item}{' ' * 20}{price}", fill=(0, 0, 0))
            y += 30
        
        # Add totals
        y += 20
        draw.text((50, y), f"Subtotal{' ' * 20}$42.99", fill=(0, 0, 0))
        y += 30
        draw.text((50, y), f"Tax{' ' * 25}$3.44", fill=(0, 0, 0))
        y += 30
        draw.text((50, y), f"Total{' ' * 23}$46.43", fill=(0, 0, 0))
        
        # Convert to bytes
        img_bytes = io.BytesIO()
        img.save(img_bytes, format='PNG')
        img_bytes.seek(0)
        
        return img_bytes

================
File: tests/config.py
================
import os

# Test configuration class - used by other tests
class TestConfig:
    """Test configuration"""
    def __init__(self):
        # Use in-memory SQLite for tests
        self.db_path = ':memory:'
        # Use temporary directory for test uploads
        self.upload_folder = os.path.join('tests', 'test_uploads')
        
        # Single source of truth for expense categories
        self.expense_categories = [
            "Advertising",
            "Car and Truck Expenses",
            "Commissions and Fees",
            "Contract Labor",
            "Depletion",
            "Depreciation and Section 179 Expense Deduction",
            "Employee Benefit Programs",
            "Insurance (Other Than Health)",
            "Interest",
            "Legal and Professional Services",
            "Office Expenses",
            "Pension and Profit-Sharing Plans",
            "Rent or Lease",
            "Repairs and Maintenance",
            "Supplies",
            "Taxes and Licenses",
            "Travel",
            "Meals",
            "Utilities",
            "Wages",
            "Other Expenses"
        ]
        
        # Payment methods
        self.payment_methods = [
            "Credit Card",
            "Debit Card",
            "Cash",
            "Check",
            "Wire Transfer",
            "Other"
        ]
        
        # Receipt statuses
        self.receipt_statuses = [
            "Pending",
            "Approved",
            "Rejected"
        ]

# Create config instance used by other tests
config = TestConfig()

================
File: tests/conftest_integration.py
================
import pytest
import logging
import os

# Configure logging
logging.basicConfig(level=logging.INFO)

# Set testing environment variable
os.environ['TESTING'] = 'true'

# Create test directories
os.makedirs('test_uploads', exist_ok=True)
os.makedirs('data', exist_ok=True)

@pytest.fixture(scope='session', autouse=True)
def setup_test_env():
    """Set up test environment"""
    yield
    # Clean up after all tests
    import shutil
    if os.path.exists('test_uploads'):
        shutil.rmtree('test_uploads')
    if os.path.exists('data'):
        shutil.rmtree('data')

================
File: tests/conftest.py
================
import pytest
from dotenv import load_dotenv
import os
import sys
import logging
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, scoped_session
from flask import Flask, g
from werkzeug.exceptions import HTTPException

# Load environment variables
load_dotenv()
print(os.getenv('TEST_DATABASE_URL'))

# Add backend directory to Python path
backend_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, backend_dir)

# Import after path setup
from models.database import Base
from backend.config import config
from api.routes import api_bp

# Configure logging
logging.basicConfig(level=logging.INFO)

# Create test directories
os.makedirs(config.upload_folder, exist_ok=True)

@pytest.fixture(scope='session')
def engine():
    """Create test database engine"""
    database_url = os.getenv('TEST_DATABASE_URL', 'sqlite:///:memory:')
    return create_engine(database_url, echo=False)

@pytest.fixture(scope='session')
def tables(engine):
    """Create all database tables"""
    Base.metadata.create_all(engine)
    yield
    Base.metadata.drop_all(engine)

@pytest.fixture
def db_session(engine):
    """Create a new database session for a test"""
    connection = engine.connect()
    
    # Start a new transaction
    transaction = connection.begin()
    
    # Configure the session
    Session = sessionmaker(bind=connection)
    session = Session()

    # Ensure we're starting with a clean slate
    session.execute(text('DELETE FROM receipts'))
    session.commit()

    yield session

    # Rollback everything and close
    session.close()
    transaction.rollback()
    connection.close()

@pytest.fixture
def client(engine, tables, db_session):
    """Create Flask test client"""
    app = Flask(__name__)
    app.config['TESTING'] = True
    app.config['UPLOAD_FOLDER'] = config.upload_folder
    app.config['DATABASE_URL'] = os.getenv('TEST_DATABASE_URL', 'sqlite:///:memory:')
    
    @app.before_request
    def before_request():
        g.db_session = db_session
    
    # Register error handlers
    from api.errors import APIError, handle_api_error, handle_http_error, handle_generic_error
    app.register_error_handler(APIError, handle_api_error)
    app.register_error_handler(HTTPException, handle_http_error)
    app.register_error_handler(Exception, handle_generic_error)
    
    # Register blueprint
    app.register_blueprint(api_bp, url_prefix='/api')
    
    with app.test_client() as client:
        with app.app_context():
            yield client

@pytest.fixture(scope='session', autouse=True)
def cleanup():
    """Clean up after all tests"""
    yield
    # Clean up test uploads
    import shutil
    if os.path.exists(config.upload_folder):
        shutil.rmtree(config.upload_folder)

================
File: tests/test_api_integration.py
================
import unittest
import requests
import io
from PIL import Image, ImageDraw

class TestReceiptAPI(unittest.TestCase):
    """Integration tests for Receipt REST API"""
    
    BASE_URL = 'http://localhost:3456/api'

    def create_test_image(self):
        """Create a test receipt image"""
        # Create image
        width, height = 576, 1000
        img = Image.new('RGB', (width, height), color=(250, 250, 250))
        draw = ImageDraw.Draw(img)
        
        # Add content
        y = 50
        draw.text((width//2 - 50, y), "TEST STORE", fill=(0, 0, 0))
        y += 50
        draw.text((50, y), "Date: 2024-01-20", fill=(0, 0, 0))
        y += 50
        
        # Add items
        items = [
            ("Item 1", "$10.99"),
            ("Item 2", "$15.00"),
            ("Item 3", "$17.00")
        ]
        for item, price in items:
            draw.text((50, y), f"{item}{' ' * 20}{price}", fill=(0, 0, 0))
            y += 30
        
        # Add totals
        y += 20
        draw.text((50, y), f"Subtotal{' ' * 20}$42.99", fill=(0, 0, 0))
        y += 30
        draw.text((50, y), f"Tax{' ' * 25}$3.44", fill=(0, 0, 0))
        y += 30
        draw.text((50, y), f"Total{' ' * 23}$46.43", fill=(0, 0, 0))
        
        # Convert to bytes
        img_bytes = io.BytesIO()
        img.save(img_bytes, format='PNG')
        img_bytes.seek(0)
        return img_bytes

    def test_upload_receipt(self):
        """Test receipt upload endpoint"""
        # Upload a test image
        test_image = self.create_test_image()
        response = requests.post(
            f'{self.BASE_URL}/upload',
            files={'file': ('test.png', test_image, 'image/png')}
        )
        
        # Verify response
        self.assertEqual(response.status_code, 200)
        data = response.json()
        
        # Verify response has required fields
        required_fields = {'id', 'image_path', 'vendor', 'amount', 'date', 'payment_method', 'category'}
        self.assertTrue(all(field in data for field in required_fields))
        
        return data['id']

    def test_get_receipts(self):
        """Test get all receipts endpoint"""
        response = requests.get(f'{self.BASE_URL}/receipts')
        
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertIsInstance(data, list)

    def test_get_receipt(self):
        """Test get single receipt endpoint"""
        # First create a receipt
        receipt_id = self.test_upload_receipt()
        
        # Get the receipt
        response = requests.get(f'{self.BASE_URL}/receipts/{receipt_id}')
        
        self.assertEqual(response.status_code, 200)
        data = response.json()
        self.assertEqual(data['id'], receipt_id)

    def test_update_receipt(self):
        """Test update receipt endpoint"""
        # First create a receipt
        receipt_id = self.test_upload_receipt()
        
        # Update it
        update_data = {
            'vendor': 'Updated Store',
            'amount': '99.99',
            'category': 'Office Expenses'
        }
        
        response = requests.patch(
            f'{self.BASE_URL}/receipts/{receipt_id}/update',
            json=update_data
        )
        
        self.assertEqual(response.status_code, 200)
        data = response.json()
        
        # Verify updates were applied
        for field, value in update_data.items():
            self.assertEqual(data['updated_fields'][field], value)

    def test_delete_receipt(self):
        """Test delete receipt endpoint"""
        # First create a receipt
        receipt_id = self.test_upload_receipt()
        
        # Delete it
        response = requests.delete(f'{self.BASE_URL}/receipts/{receipt_id}')
        self.assertEqual(response.status_code, 200)
        
        # Verify it's gone
        response = requests.get(f'{self.BASE_URL}/receipts/{receipt_id}')
        self.assertEqual(response.status_code, 404)

    def test_error_cases(self):
        """Test error responses"""
        # Test 404 on non-existent receipt
        response = requests.get(f'{self.BASE_URL}/receipts/99999')
        self.assertEqual(response.status_code, 404)
        self.assertTrue(response.json()['error'])
        self.assertEqual(response.json()['message'], "Receipt not found")
        
        # Test 400 on upload with no file
        response = requests.post(f'{self.BASE_URL}/upload', files={})
        self.assertEqual(response.status_code, 400)
        self.assertTrue(response.json()['error'])
        self.assertIn('message', response.json())

================
File: tests/test_api_options.py
================
import pytest
from backend.config import config

def test_get_options(client):
    """Test options endpoint returns correct configuration options"""
    response = client.get('/api/options')
    assert response.status_code == 200
    
    data = response.json
    # Verify all required fields are present
    assert 'categories' in data
    assert 'payment_methods' in data
    assert 'statuses' in data
    assert 'vendors' in data
    
    # Verify configuration values are correct
    assert set(data['categories']) == set(config.expense_categories)
    assert set(data['payment_methods']) == set(config.payment_methods)
    assert set(data['statuses']) == set(config.receipt_statuses)

================
File: tests/test_api.py
================
import pytest
import io
from PIL import Image, ImageDraw
import json
from datetime import datetime, timedelta

def create_test_receipt_image():
    """Create a test receipt image"""
    # Create image
    width, height = 576, 1000
    img = Image.new('RGB', (width, height), color=(250, 250, 250))
    draw = ImageDraw.Draw(img)
    
    # Add content
    y = 50
    draw.text((width//2 - 50, y), "TEST STORE", fill=(0, 0, 0))
    y += 50
    draw.text((50, y), "Date: 2024-01-20", fill=(0, 0, 0))
    y += 50
    
    # Add items
    items = [
        ("Item 1", "$10.99"),
        ("Item 2", "$15.00"),
        ("Item 3", "$17.00")
    ]
    for item, price in items:
        draw.text((50, y), f"{item}{' ' * 20}{price}", fill=(0, 0, 0))
        y += 30
    
    # Add totals
    y += 20
    draw.text((50, y), f"Subtotal{' ' * 20}$42.99", fill=(0, 0, 0))
    y += 30
    draw.text((50, y), f"Tax{' ' * 25}$3.44", fill=(0, 0, 0))
    y += 30
    draw.text((50, y), f"Total{' ' * 23}$46.43", fill=(0, 0, 0))
    
    # Convert to bytes
    img_bytes = io.BytesIO()
    img.save(img_bytes, format='PNG')
    img_bytes.seek(0)
    
    return img_bytes

def test_upload_receipt_unit(client):
    """Unit test for receipt upload endpoint"""
    # Debug: Print all registered routes
    print("\nRegistered routes:")
    for rule in client.application.url_map.iter_rules():
        print(f"{rule.endpoint}: {rule.rule}")
    
    test_image = create_test_receipt_image()
    response = client.post(
        '/api/upload',
        data={'file': (test_image, 'test_receipt.png', 'image/png')}
    )
    
    assert response.status_code == 200
    data = json.loads(response.data)
    assert 'id' in data
    assert 'image_path' in data
    assert 'content' in data
    return data['id']

def test_get_receipts_unit(client):
    """Unit test for get all receipts endpoint"""
    # Temporary debug - you can remove after confirming
    print("\nAvailable routes:")
    for rule in client.application.url_map.iter_rules():
        print(f"{rule.endpoint}: {rule.rule}")
        
    response = client.get('/api/receipts')
    assert response.status_code == 200
    data = json.loads(response.data)
    assert isinstance(data, list)

def test_get_receipt_unit(client):
    """Unit test for get single receipt endpoint"""
    receipt_id = test_upload_receipt_unit(client)
    response = client.get(f'/api/receipts/{receipt_id}')
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['id'] == receipt_id

def test_update_receipt_unit(client):
    """Unit test for update receipt endpoint"""
    receipt_id = test_upload_receipt_unit(client)
    
    update_data = {
        'content': {
            'store_name': 'Updated Store',
            'date': '2024-01-20',
            'items': [
                {'name': 'Test Item 1', 'quantity': 1, 'price': 19.99},
                {'name': 'Test Item 2', 'quantity': 2, 'price': 29.99}
            ],
            'subtotal': 79.97,
            'tax': 6.40,
            'total_amount': 86.37
        }
    }
    
    response = client.patch(
        f'/api/receipts/{receipt_id}/update',
        json=update_data
    )
    
    assert response.status_code == 200
#    data = json.loads(response.data) # seems like a redundant check as content should not be returned in the response
#    assert data['content'] == update_data['content']

def test_delete_receipt_unit(client):
    """Unit test for delete receipt endpoint"""
    receipt_id = test_upload_receipt_unit(client)

    # Delete the receipt
    response = client.delete(f'/api/receipts/{receipt_id}')
    assert response.status_code == 200

    # Verify deletion by checking that the receipt no longer exists
    response = client.get(f'/api/receipts/{receipt_id}')
    assert response.status_code == 404  # Now we expect a 404 status code
    assert response.json['error'] == True
    assert response.json['message'] == "Receipt not found"

def test_update_receipt_validation(client):
    """Test field validation rules"""
    receipt_id = test_upload_receipt_unit(client)
    
    # Test invalid vendor
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'vendor': 'x' * 101  # Too long
    })
    assert response.status_code == 400
    assert response.json['error'] == True
    assert 'message' in response.json
    assert 'details' in response.json
    assert 'vendor' in response.json['details']
    
    # Test invalid amount
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'amount': '1000000.00'  # Too large
    })
    assert response.status_code == 400
    assert 'error' in response.json
    assert 'details' in response.json
    assert 'amount' in response.json['details']
    
    # Test future date
    future_date = (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d')
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'date': future_date
    })
    assert response.status_code == 400
    assert 'error' in response.json
    assert 'details' in response.json
    assert 'date' in response.json['details']
    
    # Test invalid status
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'invalid_status'
    })
    assert response.status_code == 400
    assert 'error' in response.json
    assert 'details' in response.json
    assert 'status' in response.json['details']

def test_update_receipt_success(client):
    """Test successful field updates"""
    receipt_id = test_upload_receipt_unit(client)  # Create test receipt
    
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'vendor': 'New Vendor',
        'amount': '150.00',
        'status': 'approved'
    })
    
    assert response.status_code == 200
    assert response.json['success'] is True
    assert 'vendor' in response.json['updated_fields']
    assert 'amount' in response.json['updated_fields']
    assert 'status' in response.json['updated_fields']
    
    # Verify status change from default 'pending' to 'approved'
    assert response.json['updated_fields']['status'] == 'approved'

def test_update_receipt_errors(client):
    """Test various error conditions"""
    # Test non-existent receipt
    response = client.patch('/api/receipts/99999/update', json={
        'vendor': 'New Vendor'
    })
    assert response.status_code == 404
    assert response.json['error'] == True
    assert response.json['message'] == "Receipt not found"
    
    # Test non-JSON request
    receipt_id = test_upload_receipt_unit(client)
    response = client.patch(f'/api/receipts/{receipt_id}/update', data='not json')
    assert response.status_code == 400
    assert response.json['error'] == True
    assert 'message' in response.json

def test_partial_update_receipt(client):
    """Test updating subset of fields"""
    receipt_id = test_upload_receipt_unit(client)
    
    # Verify initial status is 'pending'
    response = client.get(f'/api/receipts/{receipt_id}')
    assert response.status_code == 200
    assert response.json['status'] == 'pending'
    
    # Update only status
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'approved'
    })
    
    assert response.status_code == 200
    assert len(response.json['updated_fields']) == 1
    assert response.json['updated_fields']['status'] == 'approved'

def test_status_transitions(client):
    """Test status transition rules"""
    receipt_id = test_upload_receipt_unit(client)
    
    # Verify initial status is 'pending'
    response = client.get(f'/api/receipts/{receipt_id}')
    assert response.status_code == 200
    assert response.json['status'] == 'pending'
    
    # Valid transition: pending → approved
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'APPROVED'  # Test case insensitive
    })
    assert response.status_code == 200
    assert response.json['updated_fields']['status'] == 'approved'
    
    # Invalid transition: approved → pending
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'pending'
    })
    assert response.status_code == 200
    assert response.json['updated_fields']['status'] == 'pending'
    
    # Valid transition: approved → rejected
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'rejected'
    })
    assert response.status_code == 200
    assert response.json['updated_fields']['status'] == 'rejected'
    
    # Valid transition: rejected → approved
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'approved'
    })
    assert response.status_code == 200
    assert response.json['updated_fields']['status'] == 'approved'

================
File: tests/test_categorization.py
================
import pytest
from services.categorization_service import CategorizationService
from tests.config import config
from unittest.mock import patch, MagicMock

def test_categorize_receipt_valid_category():
    """Test categorization with a valid category response"""
    test_content = {
        'Vendor': 'Office Depot',
        'text': ['Paper', 'Pens', 'Stapler']
    }
    
    # Mock OpenAI response with a valid category
    mock_response = MagicMock()
    mock_response.choices = [
        MagicMock(message=MagicMock(content=config.expense_categories[0]))
    ]
    
    with patch('services.categorization_service.client.chat.completions.create', return_value=mock_response):
        category = CategorizationService.categorize_receipt(test_content)
        assert category in config.expense_categories

def test_categorize_receipt_invalid_category():
    """Test categorization with an invalid category response"""
    test_content = {
        'Vendor': 'Some Store',
        'text': ['Item 1', 'Item 2']
    }
    
    # Mock OpenAI response with an invalid category
    mock_response = MagicMock()
    mock_response.choices = [
        MagicMock(message=MagicMock(content="Invalid Category"))
    ]
    
    with patch('services.categorization_service.client.chat.completions.create', return_value=mock_response):
        category = CategorizationService.categorize_receipt(test_content)
        assert category == "Other Expenses"  # Should default to Other Expenses

def test_categorize_receipt_api_error():
    """Test categorization when API call fails"""
    test_content = {
        'Vendor': 'Some Store',
        'text': ['Item 1', 'Item 2']
    }
    
    # Mock API error
    with patch('services.categorization_service.client.chat.completions.create', side_effect=Exception("API Error")):
        category = CategorizationService.categorize_receipt(test_content)
        assert category == "Other Expenses"  # Should default to Other Expenses

def test_categorize_receipt_prompt_content():
    """Test that the prompt includes all categories"""
    test_content = {
        'Vendor': 'Test Store',
        'text': ['Test Item']
    }
    
    mock_create = MagicMock()
    
    with patch('services.categorization_service.client.chat.completions.create', mock_create):
        CategorizationService.categorize_receipt(test_content)
        
        # Check that all categories are included in the prompt
        call_args = mock_create.call_args[1]
        messages = call_args['messages']
        prompt = messages[0]['content']
        
        for category in config.expense_categories:
            assert category in prompt

def test_categorize_receipt_empty_content():
    """Test categorization with empty content"""
    test_content = {}
    
    mock_response = MagicMock()
    mock_response.choices = [
        MagicMock(message=MagicMock(content=config.expense_categories[0]))
    ]
    
    with patch('services.categorization_service.client.chat.completions.create', return_value=mock_response):
        category = CategorizationService.categorize_receipt(test_content)
        assert category in config.expense_categories

def test_categorize_receipt_none_content():
    """Test categorization with None content"""
    # Test that None input returns default category
    category = CategorizationService.categorize_receipt(None)
    assert category == "Other Expenses"

================
File: tests/test_config.py
================
import os
import pytest
from backend.config import config  # Import the config object directly

class ConfigTests:
    """Tests for configuration settings"""
    
    def test_database_path(self):
        """Test that test config uses in-memory database"""
        assert config.db_path == ':memory:'
        
    def test_upload_folder(self):
        """Test upload folder configuration"""
        assert config.upload_folder == 'test_uploads'
            
    def test_expense_categories(self):
        """Test expense categories configuration"""
        # Test that expense categories are defined
        assert hasattr(config, 'expense_categories')
        assert isinstance(config.expense_categories, list)
        assert len(config.expense_categories) > 0
        
        # Test that required categories are present
        required_categories = [
            "Advertising",
            "Travel",
            "Meals",
            "Other Expenses"
        ]
        for category in required_categories:
            assert category in config.expense_categories, f"Required category '{category}' not found"
        
        # Test that categories are strings and properly formatted
        for category in config.expense_categories:
            assert isinstance(category, str), f"Category '{category}' is not a string"
            assert len(category.strip()) == len(category), f"Category '{category}' has leading/trailing whitespace"
            assert category[0].isupper(), f"Category '{category}' should start with uppercase letter"

    def test_payment_methods(self):
        """Test payment methods configuration"""
        # Test that required methods are present
        required_methods = ["Credit Card", "Cash", "Check"]
        for method in required_methods:
            assert method in config.payment_methods, f"Required payment method '{method}' not found"
            
        # Test for duplicates
        assert len(config.payment_methods) == len(set(config.payment_methods))

    def test_receipt_statuses(self):
        """Test receipt statuses configuration"""
        # Test required statuses
        required_statuses = {"Pending", "Approved", "Rejected"}
        assert set(config.receipt_statuses) == required_statuses
        
        # Test for duplicates
        assert len(config.receipt_statuses) == len(set(config.receipt_statuses))

================
File: tests/test_models.py
================
import pytest
from sqlalchemy import inspect
from models.database import engine, Receipt

def test_receipt_model_configuration():
    """Test that Receipt model is configured correctly"""
    # Get model metadata
    receipt_table = Receipt.__table__

    # Test status column configuration
    status_column = receipt_table.columns.get('status')
    assert status_column is not None
    assert status_column.type.length == 20
    assert not status_column.nullable
    assert status_column.default.arg == 'pending'

    # Test required columns exist
    required_columns = {'id', 'image_path', 'content', 'status'}
    actual_columns = set(receipt_table.columns.keys())
    assert required_columns.issubset(actual_columns)

================
File: tests/test_receipt_updates.py
================
import pytest
from models.database import Receipt, get_db
from backend.config import config

def test_update_receipt_fields(client):
    """Test updating receipt fields"""
    # Create a test receipt
    with get_db() as db:
        receipt = Receipt(
            image_path="test.jpg",
            vendor="Test Vendor",
            amount="10.00",
            date="2023-12-16",
            payment_method="CASH",
            category="Other",
            content={"test": "data"}
        )
        db.add(receipt)
        db.commit()
        receipt_id = receipt.id

    # Test updating fields
    update_data = {
        "vendor": "New Vendor",
        "amount": "25.50",
        "category": "Office Expenses"
    }

    response = client.patch(f'/api/receipts/{receipt_id}/update', json=update_data)
    assert response.status_code == 200

    # Verify the updates were applied
    with get_db() as db:
        updated_receipt = db.query(Receipt).get(receipt_id)
        assert updated_receipt.vendor == "New Vendor"
        assert updated_receipt.amount == "25.50"
        assert updated_receipt.category == "Office Expenses"

    # Clean up
    with get_db() as db:
        db.query(Receipt).filter_by(id=receipt_id).delete()
        db.commit()

def test_update_invalid_receipt(client):
    """Test updating non-existent receipt"""
    response = client.patch('/api/receipts/99999/update', json={"vendor": "Test"})
    assert response.status_code == 404
    assert response.json['error'] == True
    assert response.json['message'] == "Receipt not found"

def test_partial_update_receipt(client):
    """Test updating only some fields of a receipt"""
    with get_db() as db:
        receipt = Receipt(
            image_path="test.jpg",
            vendor="Original Vendor",
            amount="10.00",
            date="2023-12-16",
            payment_method="CASH",
            category="Other Expenses",
            content={"test": "data"}
        )
        db.add(receipt)
        db.commit()
        receipt_id = receipt.id

    # Update only vendor
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={"vendor": "New Vendor"})
    assert response.status_code == 200

    # Verify only vendor changed, other fields remained same
    with get_db() as db:
        updated_receipt = db.query(Receipt).get(receipt_id)
        assert updated_receipt.vendor == "New Vendor"
        assert updated_receipt.amount == "10.00"  # unchanged
        assert updated_receipt.category == "Other Expenses"  # unchanged

    # Clean up
    with get_db() as db:
        db.query(Receipt).filter_by(id=receipt_id).delete()
        db.commit()

def test_update_invalid_fields(client):
    """Test updating with invalid field values"""
    with get_db() as db:
        receipt = Receipt(
            image_path="test.jpg",
            content={"test": "data"}
        )
        db.add(receipt)
        db.commit()
        receipt_id = receipt.id

    # Test invalid amount format
    response = client.patch(f'/api/receipts/{receipt_id}/update', 
                          json={"amount": "invalid"})
    assert response.status_code == 400
    assert response.json['error'] == True
    assert 'message' in response.json
    assert 'details' in response.json
    assert 'amount' in response.json['details']

    # Clean up
    with get_db() as db:
        db.query(Receipt).filter_by(id=receipt_id).delete()
        db.commit()

def test_validate_category(client):
    """Test category validation in receipt updates"""
    # Create a test receipt
    response = client.post('/api/upload', data={
        'file': (open('tests/test_receipt_debug.png', 'rb'), 'test_receipt.png')
    })
    assert response.status_code == 200
    receipt_id = response.json['id']
    
    # Test valid category
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'category': config.expense_categories[0]
    })
    assert response.status_code == 200
    
    # Test invalid category
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'category': 'Invalid Category'
    })
    assert response.status_code == 400
    assert 'category' in response.json['details']

def test_validate_payment_method(client):
    """Test payment method validation in receipt updates"""
    # Create a test receipt
    response = client.post('/api/upload', data={
        'file': (open('tests/test_receipt_debug.png', 'rb'), 'test_receipt.png')
    })
    assert response.status_code == 200
    receipt_id = response.json['id']
    
    # Test valid payment method
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'payment_method': config.payment_methods[0]
    })
    assert response.status_code == 200
    
    # Test invalid payment method
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'payment_method': 'Invalid Method'
    })
    assert response.status_code == 400
    assert 'payment_method' in response.json['details']

def test_validate_status(client):
    """Test status validation and transitions in receipt updates"""
    # Create a test receipt
    response = client.post('/api/upload', data={
        'file': (open('tests/test_receipt_debug.png', 'rb'), 'test_receipt.png')
    })
    assert response.status_code == 200
    receipt_id = response.json['id']
    
    # Test valid status transition: pending -> approved
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': config.receipt_statuses[1]  # 'Approved'
    })
    assert response.status_code == 200
    
    # Test invalid status transition: approved -> approved (no change)
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': config.receipt_statuses[1]  # 'Approved'
    })
    assert response.status_code == 400
    assert 'status' in response.json['details']
    
    # Test invalid status value
    response = client.patch(f'/api/receipts/{receipt_id}/update', json={
        'status': 'invalid_status'
    })
    assert response.status_code == 400
    assert 'status' in response.json['details']

================
File: tests/test_upload.py
================
import requests
import os
import logging
from PIL import Image, ImageDraw, ImageFont
import io
import random
import sys

# Force logging to stdout with DEBUG level
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    force=True,  # Force override any existing logger
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

# Disable other loggers
logging.getLogger('urllib3').setLevel(logging.WARNING)
logging.getLogger('PIL').setLevel(logging.WARNING)

logger = logging.getLogger('test_upload')
logger.setLevel(logging.DEBUG)

# Test that logging works
logger.debug("Logging initialized")

BASE_URL = 'http://localhost:3456/api'

def create_test_receipt_image():
    """Create a realistic receipt image with noise"""
    logger.info("Creating test receipt image...")
    
    # Create a tall receipt image (typical receipt dimensions)
    width = 576  # Standard receipt width (72mm at 203dpi)
    height = 1000
    img = Image.new('RGB', (width, height), color=(250, 250, 250))  # Slightly off-white
    d = ImageDraw.Draw(img)
    
    # Try to use a monospace font
    try:
        font_paths = [
            '/System/Library/Fonts/Courier.dfont',  # macOS
            '/usr/share/fonts/truetype/liberation/LiberationMono-Regular.ttf',  # Linux
            'C:\\Windows\\Fonts\\cour.ttf'  # Windows
        ]
        
        font = None
        for path in font_paths:
            if os.path.exists(path):
                font = ImageFont.truetype(path, size=24)
                logger.info(f"Using font from: {path}")
                break
        
        if font is None:
            logger.warning("No suitable font found, using default font")
    except Exception as e:
        logger.error(f"Font error: {e}")
        font = None
    
    # Draw receipt content
    y = 50
    # Header
    d.text((width//2 - 50, y), "TEST STORE", fill=(0, 0, 0), font=font)
    y += 40
    d.text((width//2 - 80, y), "123 Main Street", fill=(0, 0, 0), font=font)
    y += 30
    d.text((width//2 - 80, y), "City, State 12345", fill=(0, 0, 0), font=font)
    y += 50
    
    # Transaction details
    d.text((50, y), "Date: 2024-01-20", fill=(0, 0, 0), font=font)
    y += 30
    d.text((50, y), "Receipt #: 1234", fill=(0, 0, 0), font=font)
    y += 50
    
    # Items
    d.text((50, y), "Item 1" + "." * 20 + "$10.99", fill=(0, 0, 0), font=font)
    y += 30
    d.text((50, y), "Item 2" + "." * 20 + "$15.00", fill=(0, 0, 0), font=font)
    y += 30
    d.text((50, y), "Item 3" + "." * 20 + "$17.00", fill=(0, 0, 0), font=font)
    y += 50
    
    # Totals
    d.text((50, y), "Subtotal" + "." * 20 + "$42.99", fill=(0, 0, 0), font=font)
    y += 30
    d.text((50, y), "Tax" + "." * 25 + "$3.44", fill=(0, 0, 0), font=font)
    y += 30
    d.text((50, y), "Total" + "." * 23 + "$46.43", fill=(0, 0, 0), font=font)
    
    # Save to file for inspection
    debug_path = os.path.join(os.path.dirname(__file__), 'test_receipt_debug.png')
    img.save(debug_path, format='PNG', quality=100)
    logger.info(f"Saved debug image to: {debug_path}")
    
    # Save to bytes for API
    img_byte_arr = io.BytesIO()
    img.save(img_byte_arr, format='PNG', quality=100)
    img_byte_arr.seek(0)
    return img_byte_arr

def test_upload():
    """Test receipt upload"""
    logger.info("\n=== Testing Upload API ===")
    
    try:
        # Create and prepare the test image
        img_data = create_test_receipt_image()
        logger.info("Test image created successfully")
        
        # Prepare the upload request
        files = {'file': ('test_receipt.png', img_data, 'image/png')}
        logger.info("Sending upload request to server...")
        
        # Make the request
        response = requests.post(f'{BASE_URL}/upload', files=files)
        logger.info(f"Upload response status code: {response.status_code}")
        
        # Parse and check the response
        response_data = response.json()
        logger.info(f"Upload response data: {response_data}")
        
        # Detailed response analysis
        assert response.status_code == 200
        assert 'content' in response_data
        logger.info("Upload successful!")
        if response_data.get('content') is None:
            logger.warning("OCR processing failed - content is None")
        else:
            logger.info("OCR processing successful")
            logger.info(f"Extracted content: {response_data['content']}")
    except Exception as e:
        logger.error(f"Test failed with error: {str(e)}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")

if __name__ == '__main__':
    # Test that logging is working
    logger.info("Starting upload test...")
    
    test_upload()
    
    sys.exit(0)

================
File: __init__.py
================
# Empty file to make the directory a Python package

================
File: app.py
================
from flask import Flask, jsonify
from flask_cors import CORS
from api.routes import api_bp
# from backend.api.routes import api_bp # Import the API blueprint
from config import config
import logging
from werkzeug.middleware.proxy_fix import ProxyFix
from werkzeug.exceptions import HTTPException
from api.errors import APIError, handle_api_error, handle_http_error, handle_generic_error

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

app = Flask(__name__)
app.register_blueprint(api_bp, url_prefix='/api') # Register API blueprint with /api prefix

# Configure CORS with timeout
CORS(app, resources={
    r"/api/*": {
        "origins": ["http://localhost:3000"],
        "methods": ["GET", "POST", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type"]
    }
})

app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

# Configure upload folder
app.config['UPLOAD_FOLDER'] = config.upload_folder
app.config['UPLOAD_TIMEOUT'] = 120
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size
app.config['PROPAGATE_EXCEPTIONS'] = True  # Enable full error reporting

# Register error handlers
app.register_error_handler(APIError, handle_api_error)
app.register_error_handler(HTTPException, handle_http_error)
app.register_error_handler(Exception, handle_generic_error)

# Register blueprints
# app.register_blueprint(api_bp, url_prefix='/api')

@app.route('/api/health')
def health_check():
    """Health check endpoint"""
    return jsonify({'status': 'ok'})

@app.errorhandler(Exception)
def handle_exception(e):
    # Log the exception details
    app.logger.error(f"Unhandled Exception: {str(e)}", exc_info=True)
    
    # Return a sanitized error response
    response = {
        "error": "An unexpected error occurred. Please try again later."
    }
    return jsonify(response), 500

if __name__ == '__main__':
    app.run(
        host='0.0.0.0', 
        port=3456, 
        debug=True,
        threaded=True
    )

================
File: clean_receipts.py
================
from models.database import SessionLocal, Receipt
import os

def clean_receipt_paths():
    db = SessionLocal()
    try:
        # Get all receipts
        receipts = db.query(Receipt).all()
        
        for receipt in receipts:
            if receipt.image_path and '/' in receipt.image_path:
                # Extract just the filename from the full path
                old_path = receipt.image_path
                filename = os.path.basename(old_path)
                
                print(f"Updating receipt {receipt.id}:")
                print(f"  Old path: {old_path}")
                print(f"  New path: {filename}")
                
                # Update the path in the database
                receipt.image_path = filename
        
        # Commit the changes
        db.commit()
        print("\nDatabase updated successfully!")
        
    except Exception as e:
        print(f"Error: {str(e)}")
        db.rollback()
    finally:
        db.close()

if __name__ == '__main__':
    clean_receipt_paths()

================
File: config.py
================
import os

class Config:
    """Base configuration"""
    def __init__(self):
        self.db_path = os.path.join('data', 'receipts.db')
        self.upload_folder = os.path.join('Receipts', 'uploads')
        
        # Single source of truth for expense categories
        self.expense_categories = [
            "Advertising",
            "Car and Truck Expenses",
            "Commissions and Fees",
            "Contract Labor",
            "Depletion",
            "Depreciation and Section 179 Expense Deduction",
            "Employee Benefit Programs",
            "Insurance (Other Than Health)",
            "Interest",
            "Legal and Professional Services",
            "Office Expenses",
            "Pension and Profit-Sharing Plans",
            "Rent or Lease",
            "Repairs and Maintenance",
            "Supplies",
            "Taxes and Licenses",
            "Travel",
            "Meals",
            "Utilities",
            "Wages",
            "Other Expenses"
        ]
        
        # Payment methods
        self.payment_methods = [
            "Credit Card",
            "Debit Card",
            "Cash",
            "Check",
            "Wire Transfer",
            "Other"
        ]
        
        # Receipt statuses
        self.receipt_statuses = [
            "Pending",
            "Approved",
            "Rejected"
        ]

class TestConfig(Config):
    """Test configuration"""
    def __init__(self):
        super().__init__()  # Call parent init to get the categories and other settings
        self.db_path = ':memory:'  # Use in-memory SQLite for tests
        self.upload_folder = 'test_uploads'

# Use test config if TESTING environment variable is set
config = TestConfig() if os.getenv('TESTING') else Config()

================
File: init_db.py
================
from models.database import Base, get_engine

def init_db():
    Base.metadata.drop_all(bind=get_engine())
    Base.metadata.create_all(bind=get_engine())

if __name__ == '__main__':
    init_db()
    print("Database initialized")

================
File: pytest.ini
================
[pytest]
filterwarnings =
    ignore:urllib3 v2 only supports OpenSSL:urllib3.exceptions.NotOpenSSLWarning 
pythonpath = .
testpaths = tests
python_files = test_*.py

================
File: requirements.txt
================
flask==2.3.3
flask-cors==4.0.0
SQLAlchemy==2.0.21
Werkzeug==2.3.7
Pillow==10.0.1
python-dotenv==1.0.0
pytest==7.4.2
openai==1.3.5
httpx==0.24.1
httpcore==0.17.3
requests==2.31.0
pydantic==2.4.2
python-multipart==0.0.6
gunicorn==21.2.0
pytest-cov==4.1.0
black==23.9.1
mypy==1.5.1
isort==5.12.0
flake8==6.1.0
alembic==1.12.0
pylint==3.0.0
structlog==23.1.0
sentry-sdk==1.31.0
python-jose==3.3.0
bcrypt==4.0.1
pytest-mock==3.11.1
pytest-env==1.0.1

================
File: run_tests.py
================
import unittest
import sys
from tests.test_api import TestReceipts

def run_all_tests():
    """Run all test suites"""
    # Create test suite
    suite = unittest.TestSuite()
    
    # Add test cases
    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestReceipts))
    
    # Run tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Return appropriate exit code
    return 0 if result.wasSuccessful() else 1

if __name__ == '__main__':
    sys.exit(run_all_tests())

================
File: backend/requirements.txt
================
flask==2.3.3
flask-cors==4.0.0
SQLAlchemy==2.0.21
Werkzeug==2.3.7
Pillow==10.0.1
python-dotenv==1.0.0
pytest==7.4.2
openai==1.3.5
httpx==0.24.1
httpcore==0.17.3
requests==2.31.0
pydantic==2.4.2
python-multipart==0.0.6
gunicorn==21.2.0
pytest-cov==4.1.0
black==23.9.1
mypy==1.5.1
isort==5.12.0
flake8==6.1.0
alembic==1.12.0
pylint==3.0.0
structlog==23.1.0
sentry-sdk==1.31.0
python-jose==3.3.0
bcrypt==4.0.1
pytest-mock==3.11.1
pytest-env==1.0.1

================
File: backend/run_tests.py
================
import unittest
import sys
from tests.test_api import TestReceipts

def run_all_tests():
    """Run all test suites"""
    # Create test suite
    suite = unittest.TestSuite()
    
    # Add test cases
    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestReceipts))
    
    # Run tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Return appropriate exit code
    return 0 if result.wasSuccessful() else 1

if __name__ == '__main__':
    sys.exit(run_all_tests())

================
File: frontend/components/common/DialogWrapper.tsx
================
import { Dialog, DialogTitle, DialogContent, IconButton } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';

interface DialogWrapperProps {
    title: string;
    open: boolean;
    onClose: () => void;
    children: React.ReactNode;
}

export const DialogWrapper = ({ title, open, onClose, children }: DialogWrapperProps) => (
    <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
        <DialogTitle sx={{ m: 0, p: 2, display: 'flex', justifyContent: 'space-between' }}>
            {title}
            <IconButton onClick={onClose}><CloseIcon /></IconButton>
        </DialogTitle>
        <DialogContent>
            {children}
        </DialogContent>
    </Dialog>
);

================
File: frontend/components/common/ErrorMessage.tsx
================
import { Alert, Box } from '@mui/material';

interface ErrorMessageProps {
  message: string;
}

export default function ErrorMessage({ message }: ErrorMessageProps) {
  return (
    <Box sx={{ my: 2 }}>
      <Alert severity="error">{message}</Alert>
    </Box>
  );
}

================
File: frontend/components/common/index.ts
================
export * from './ErrorMessage';
export * from './LoadingSpinner';
export * from './DialogWrapper';
export * from '../ReceiptTable';

================
File: frontend/components/common/LoadingSpinner.tsx
================
import { Box, CircularProgress, type SxProps } from '@mui/material';

interface LoadingSpinnerProps {
  minHeight?: string | number;
  sx?: SxProps;
}

export default function LoadingSpinner({ minHeight = '200px', sx }: LoadingSpinnerProps) {
  return (
    <Box
      display="flex"
      justifyContent="center"
      alignItems="center"
      minHeight={minHeight}
      sx={sx}
    >
      <CircularProgress />
    </Box>
  );
}

================
File: frontend/components/Documents/DocumentFilters.tsx
================
import React, { useState, useEffect } from 'react';
import {
    Box,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    Typography,
    TextField,
    Select,
    MenuItem,
    FormControl,
    InputLabel,
    Chip,
    Button,
    Menu,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import TuneIcon from '@mui/icons-material/Tune';
import RestartAltIcon from '@mui/icons-material/RestartAlt';
import { DocumentType } from '@/types';
import { DocumentFilter } from '@/types/filters';

interface FilterField {
    type: 'number-range' | 'date-range' | 'multi-select';
    label: string;
    field: string;
    options?: string[]; // For multi-select
}

interface FilterOptions {
    categories: string[];
    payment_methods: string[];
    statuses: string[];
    vendors: string[];
}

const FILTER_CONFIG: Record<DocumentType, FilterField[]> = {
    'W-2': [
        { type: 'multi-select', label: 'Employer', field: 'employer' },
        { type: 'number-range', label: 'Wages', field: 'wageRange' },
        { type: 'number-range', label: 'Withholding', field: 'withHoldingRange' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ],
    '1099': [
        { type: 'multi-select', label: 'Employer', field: 'employer' },
        { type: 'number-range', label: 'Amount', field: 'amountRange' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ],
    'Expenses': [
        { type: 'multi-select', label: 'Vendor', field: 'vendor' },
        { type: 'number-range', label: 'Amount', field: 'amountRange' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Payment Method', field: 'paymentMethods' },
        { type: 'multi-select', label: 'Category', field: 'categories' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ],
    'Donations': [
        { type: 'multi-select', label: 'Charity', field: 'charityName' },
        { type: 'number-range', label: 'Amount', field: 'amountRange' },
        { type: 'multi-select', label: 'Type', field: 'donationType' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ]
};

interface DocumentFiltersProps {
    type: DocumentType;
    filters: DocumentFilter;
    onFilterChange: (filters: DocumentFilter) => void;
    variant?: 'default' | 'toolbar';
}

export const DocumentFilters: React.FC<DocumentFiltersProps> = ({
    type,
    filters,
    onFilterChange,
    variant = 'default'
}) => {
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const [filterOptions, setFilterOptions] = useState<FilterOptions>({
        categories: [],
        payment_methods: [],
        statuses: [],
        vendors: []
    });

    useEffect(() => {
        // Fetch filter options from the backend
        const fetchOptions = async () => {
            try {
                const response = await fetch('/api/options');
                if (!response.ok) {
                    throw new Error('Failed to fetch options');
                }
                const data = await response.json();
                setFilterOptions(data);
            } catch (error) {
                console.error('Error fetching filter options:', error);
            }
        };

        fetchOptions();
    }, []);

    const getOptionsForField = (field: string): string[] => {
        switch (field) {
            case 'categories':
                return filterOptions.categories;
            case 'paymentMethods':
                return filterOptions.payment_methods;
            case 'status':
                return filterOptions.statuses;
            case 'vendor':
                return filterOptions.vendors;
            default:
                return [];
        }
    };

    const handleNumberRangeChange = (field: string, bound: 'min' | 'max', value: string) => {
        const numValue = value ? Number(value) : undefined;
        onFilterChange({
            ...filters,
            [field]: {
                ...(filters[field as keyof DocumentFilter] as any || {}),
                [bound]: numValue
            }
        });
    };

    const handleDateRangeChange = (field: string, bound: 'start' | 'end', value: string) => {
        onFilterChange({
            ...filters,
            [field]: {
                ...(filters[field as keyof DocumentFilter] as any || {}),
                [bound]: value || undefined
            }
        });
    };

    const handleMultiSelectChange = (field: string, values: string[]) => {
        onFilterChange({
            ...filters,
            [field]: values
        });
    };

    const handleRemoveFilter = (field: keyof DocumentFilter, value?: string) => {
        const newFilters = { ...filters };
        
        if (value && Array.isArray(newFilters[field])) {
            const currentValues = newFilters[field] as string[];
            newFilters[field] = currentValues.filter(v => v !== value) as any;
            if ((newFilters[field] as string[]).length === 0) {
                delete newFilters[field];
            }
        } else {
            delete newFilters[field];
        }
        onFilterChange(newFilters);
    };

    const handleResetFilters = () => {
        onFilterChange({});
    };

    const renderActiveFilters = () => {
        return (
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>
                {FILTER_CONFIG[type].map(field => {
                    const value = filters[field.field as keyof DocumentFilter];
                    if (!value) return null;

                    switch (field.type) {
                        case 'multi-select':
                            return (Array.isArray(value) ? value : []).map(v => (
                                <Chip
                                    key={`${field.field}-${v}`}
                                    label={`${field.label}: ${v}`}
                                    onDelete={() => handleRemoveFilter(field.field as keyof DocumentFilter, v)}
                                    size="small"
                                />
                            ));
                        case 'number-range': {
                            const range = value as { min?: number; max?: number };
                            if (!range.min && !range.max) return null;
                            return (
                                <Chip
                                    key={field.field}
                                    label={`${field.label}: ${range.min || '0'} - ${range.max || '∞'}`}
                                    onDelete={() => handleRemoveFilter(field.field as keyof DocumentFilter)}
                                    size="small"
                                />
                            );
                        }
                        case 'date-range': {
                            const dates = value as { start?: string; end?: string };
                            if (!dates.start && !dates.end) return null;
                            return (
                                <Chip
                                    key={field.field}
                                    label={`${field.label}: ${dates.start || '∞'} - ${dates.end || '∞'}`}
                                    onDelete={() => handleRemoveFilter(field.field as keyof DocumentFilter)}
                                    size="small"
                                />
                            );
                        }
                        default:
                            return null;
                    }
                })}
            </Box>
        );
    };

    const renderFilterField = (field: FilterField) => {
        const filterValue = filters[field.field as keyof DocumentFilter];

        switch (field.type) {
            case 'number-range': {
                const range = filterValue as { min?: number; max?: number } || {};
                return (
                    <Box sx={{ display: 'flex', gap: 2 }}>
                        <TextField
                            label={`Min ${field.label}`}
                            type="number"
                            size="small"
                            value={range.min || ''}
                            onChange={(e) => handleNumberRangeChange(field.field, 'min', e.target.value)}
                        />
                        <TextField
                            label={`Max ${field.label}`}
                            type="number"
                            size="small"
                            value={range.max || ''}
                            onChange={(e) => handleNumberRangeChange(field.field, 'max', e.target.value)}
                        />
                    </Box>
                );
            }

            case 'date-range': {
                const dates = filterValue as { start?: string; end?: string } || {};
                return (
                    <Box sx={{ display: 'flex', gap: 2 }}>
                        <TextField
                            label="Start Date"
                            type="date"
                            size="small"
                            InputLabelProps={{ shrink: true }}
                            value={dates.start || ''}
                            onChange={(e) => handleDateRangeChange(field.field, 'start', e.target.value)}
                        />
                        <TextField
                            label="End Date"
                            type="date"
                            size="small"
                            InputLabelProps={{ shrink: true }}
                            value={dates.end || ''}
                            onChange={(e) => handleDateRangeChange(field.field, 'end', e.target.value)}
                        />
                    </Box>
                );
            }

            case 'multi-select':
                return (
                    <FormControl size="small" sx={{ minWidth: 200 }}>
                        <InputLabel>{field.label}</InputLabel>
                        <Select
                            multiple
                            value={(filterValue as string[]) || []}
                            onChange={(e) => handleMultiSelectChange(field.field, e.target.value as string[])}
                            label={field.label}
                        >
                            {getOptionsForField(field.field).map((option) => (
                                <MenuItem key={option} value={option}>
                                    {option}
                                </MenuItem>
                            ))}
                        </Select>
                    </FormControl>
                );
        }
    };

    if (variant === 'toolbar') {
        return (
            <>
                <Button
                    startIcon={<TuneIcon />}
                    onClick={(e) => setAnchorEl(e.currentTarget)}
                    variant="outlined"
                    size="small"
                    endIcon={Object.keys(filters).length > 0 && 
                        <Chip 
                            label={Object.keys(filters).length} 
                            size="small" 
                            color="primary"
                        />
                    }
                >
                    Filters
                </Button>
                <Menu
                    anchorEl={anchorEl}
                    open={Boolean(anchorEl)}
                    onClose={() => setAnchorEl(null)}
                    PaperProps={{
                        sx: { width: 400, maxHeight: '80vh' }
                    }}
                >
                    <Box sx={{ p: 2 }}>
                        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                            {FILTER_CONFIG[type].map(field => (
                                <Box key={field.field}>
                                    {renderFilterField(field)}
                                </Box>
                            ))}
                        </Box>
                        {renderActiveFilters()}
                    </Box>
                </Menu>
            </>
        );
    }

    return (
        <Box sx={{ mb: 2 }}>
            <Accordion>
                <AccordionSummary
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                        bgcolor: 'background.default',
                        '&:hover': { bgcolor: 'action.hover' }
                    }}
                >
                    <Box sx={{ 
                        display: 'flex', 
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        width: '100%',
                        pr: 2
                    }}>
                        <Box sx={{ 
                            display: 'flex', 
                            alignItems: 'center', 
                            gap: 1 
                        }}>
                            <TuneIcon />
                            <Typography>Filters</Typography>
                        </Box>
                        
                        {Object.keys(filters).length > 0 && (
                            <Button
                                size="small"
                                startIcon={<RestartAltIcon />}
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleResetFilters();
                                }}
                                sx={{ ml: 2 }}
                            >
                                Reset Filters
                            </Button>
                        )}
                    </Box>
                </AccordionSummary>
                <AccordionDetails>
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                        {FILTER_CONFIG[type].map(field => (
                            <Box key={field.field}>
                                {renderFilterField(field)}
                            </Box>
                        ))}
                    </Box>
                </AccordionDetails>
            </Accordion>
            {renderActiveFilters()}
        </Box>
    );
};

================
File: frontend/components/Documents/DocumentsFilters.tsx
================
import React from 'react';
import { 
    Box, 
    TextField, 
    Select, 
    MenuItem, 
    Button,
    InputLabel,
    FormControl,
    SelectChangeEvent,
} from '@mui/material';
import { DocumentStatus } from '@/types';

interface DocumentsFiltersProps {
    statusFilter: DocumentStatus;
    searchQuery: string;
    onStatusChange: (status: DocumentStatus) => void;
    onSearchChange: (query: string) => void;
    onReset: () => void;
}

export const DocumentsFilters: React.FC<DocumentsFiltersProps> = ({
    statusFilter,
    searchQuery,
    onStatusChange,
    onSearchChange,
    onReset,
}) => {
    const handleStatusChange = (event: SelectChangeEvent) => {
        onStatusChange(event.target.value as DocumentStatus);
    };

    return (
        <Box 
            sx={{ 
                display: 'flex', 
                gap: 2, 
                mb: 3,
                flexDirection: { xs: 'column', sm: 'row' },
                alignItems: { xs: 'stretch', sm: 'center' },
            }}
        >
            <FormControl 
                sx={{ 
                    minWidth: { xs: '100%', sm: 200 } 
                }}
            >
                <InputLabel id="status-filter-label">Status</InputLabel>
                <Select
                    labelId="status-filter-label"
                    value={statusFilter}
                    label="Status"
                    onChange={handleStatusChange}
                    size="small"
                >
                    <MenuItem value="all">All</MenuItem>
                    <MenuItem value="pending">Pending</MenuItem>
                    <MenuItem value="approved">Approved</MenuItem>
                </Select>
            </FormControl>

            <TextField
                placeholder="Search in Documents..."
                value={searchQuery}
                onChange={(e) => onSearchChange(e.target.value)}
                size="small"
                sx={{ 
                    flex: 1,
                    minWidth: { xs: '100%', sm: 300 }
                }}
            />

            <Button
                variant="outlined"
                onClick={onReset}
                sx={{ 
                    minWidth: { xs: '100%', sm: 'auto' }
                }}
            >
                Reset Filters
            </Button>
        </Box>
    );
};

================
File: frontend/components/Documents/DocumentsTable.tsx
================
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    IconButton,
    TableSortLabel,
    Box,
    Typography,
    Tooltip,
    CircularProgress,
    Checkbox,
    Alert,
    Snackbar,
    Fade,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogContentText,
    DialogActions,
    Button,
} from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import EditIcon from '@mui/icons-material/Edit';
import VisibilityIcon from '@mui/icons-material/Visibility';
import DeleteIcon from '@mui/icons-material/Delete';
import { 
    DocumentType, 
    DocumentStatus, 
    Document,
    W2Document,
    Form1099Document,
    ExpenseDocument,
    DonationDocument
} from '@/types';
import { documentsApi } from '@/lib/api/documents';
import { useRouter } from 'next/router';
import { ImageViewer } from '@/components/ImageViewer';
import { DocumentFilter } from '@/types/filters';
import { DocumentFilters } from './DocumentFilters';
import { useSearch } from '@/contexts/SearchContext';
import { EditableCell } from './EditableCell';
import { updateDocument } from '@/lib/api/documents';
import { format, parse, isValid } from 'date-fns';
import { enUS } from 'date-fns/locale';

type ColumnId<T> = keyof T;

interface Column<T extends Document = Document> {
  id: ColumnId<T>;
  label: string;
  minWidth?: number;
  align?: 'left' | 'right' | 'center';
  format?: (value: any) => string;
  editable?: boolean;
  editType?: 'text' | 'date' | 'amount' | 'select';
  options?: string[];
}

type DocumentColumns = {
  'W-2': Column<W2Document>[];
  '1099': Column<Form1099Document>[];
  'Expenses': Column<ExpenseDocument>[];
  'Donations': Column<DonationDocument>[];
};

const COLUMNS: DocumentColumns = {
  'W-2': [
    { id: 'employer', label: 'Employer', minWidth: 170 },
    { 
      id: 'wages',
      label: 'Wages',
      minWidth: 100,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { 
      id: 'fedWithholding',
      label: 'Fed Withholding',
      minWidth: 130,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { id: 'status', label: 'Status', minWidth: 100, align: 'center' }
  ],
  '1099': [
    { id: 'employer', label: 'Payer', minWidth: 170 },
    { 
      id: 'nonEmpCompensation',
      label: 'Amount',
      minWidth: 100,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { id: 'status', label: 'Status', minWidth: 100, align: 'center' }
  ],
  'Expenses': [
    { 
      id: 'vendor',
      label: 'Vendor',
      minWidth: 170,
      editable: true,
      editType: 'text'
    },
    { 
      id: 'amount',
      label: 'Amount',
      minWidth: 100,
      align: 'right',
      editable: true,
      editType: 'amount',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { 
      id: 'date',
      label: 'Date',
      minWidth: 100,
      editable: true,
      editType: 'date',
      format: (value: string) => new Date(value).toLocaleDateString()
    },
    { 
      id: 'payment_method',
      label: 'Payment Method',
      minWidth: 130,
      editable: true,
      editType: 'select',
      options: ['credit_card', 'debit_card', 'cash', 'check', 'other']
    },
    { 
      id: 'expenseType',
      label: 'Expense Category',
      minWidth: 150,
      editable: false
    },
    { 
      id: 'status',
      label: 'Status',
      minWidth: 100,
      align: 'center',
      editable: false
    }
  ],
  'Donations': [
    { id: 'charityName', label: 'Charity', minWidth: 170 },
    { 
      id: 'amount',
      label: 'Amount',
      minWidth: 100,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { id: 'donationType', label: 'Type', minWidth: 100 },
    { id: 'date', label: 'Date', minWidth: 100 },
    { id: 'status', label: 'Status', minWidth: 100, align: 'center' }
  ],
};

interface DocumentsTableProps {
    type: DocumentType;
    filters: DocumentFilter;
    onFilterChange: (newFilters: DocumentFilter) => void;
}

// Add this type for sorting
type SortComparator = (a: Document, b: Document) => number;

// Add this helper function at the top of the file
const isValidDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date instanceof Date && !isNaN(date.getTime());
};

const TableToolbar = ({ 
    type,
    numSelected, 
    onSelectAll, 
    onDelete,
    filters,
    onFilterChange,
    availableOptions
}: { 
    type: DocumentType;
    numSelected: number;
    onSelectAll: (event: React.ChangeEvent<HTMLInputElement>) => void;
    onDelete: () => void;
    filters: DocumentFilter;
    onFilterChange: (filters: DocumentFilter) => void;
    availableOptions: Record<string, string[]>;
}) => (
    <Box
        sx={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            borderBottom: 1,
            borderColor: 'divider',
            bgcolor: numSelected > 0 ? 'action.selected' : 'background.paper',
            px: 2,
            py: 1,
        }}
    >
        {/* Left side: Selection and bulk actions */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <Checkbox
                indeterminate={numSelected > 0}
                checked={numSelected > 0}
                onChange={onSelectAll}
            />
            {numSelected > 0 ? (
                <>
                    <Typography>
                        {numSelected} selected
                    </Typography>
                    <Tooltip title="Delete">
                        <IconButton 
                            onClick={onDelete}
                            size="small"
                        >
                            <DeleteIcon />
                        </IconButton>
                    </Tooltip>
                </>
            ) : (
                <Typography variant="h6" component="div">
                    {type}
                </Typography>
            )}
        </Box>

        {/* Right side: Filters */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
            <DocumentFilters
                type={type}
                filters={filters}
                onFilterChange={onFilterChange}
                availableOptions={availableOptions}
                variant="toolbar" // New prop to render in compact mode
            />
        </Box>
    </Box>
);

export const DocumentsTable: React.FC<DocumentsTableProps> = ({
    type,
    filters,
    onFilterChange,
}) => {
    const router = useRouter();
    const [documents, setDocuments] = useState<Document[]>([]);
    const [loading, setLoading] = useState(true);
    const [orderBy, setOrderBy] = useState<string>('');
    const [order, setOrder] = useState<'asc' | 'desc'>('asc');
    const [error, setError] = useState<string | null>(null);
    const [availableOptions, setAvailableOptions] = useState<Record<string, string[]>>({});
    const { searchQuery } = useSearch();
    const [selected, setSelected] = useState<number[]>([]);
    const [deleteSnackbar, setDeleteSnackbar] = useState({
        open: false,
        message: ''
    });
    const [showBulkDeleteConfirm, setShowBulkDeleteConfirm] = useState(false);
    const [isDeleting, setIsDeleting] = useState(false);
    const [bulkActionStatus, setBulkActionStatus] = useState<{
        show: boolean;
        message: string;
        type: 'success' | 'error';
    }>({ show: false, message: '', type: 'success' });

    useEffect(() => {
        fetchDocuments();
    }, [type]);

    useEffect(() => {
        // Set default sorting when type changes
        if (type === 'Expenses') {
            setOrderBy('date');
            setOrder('desc');
        } else {
            setOrderBy('');
            setOrder('asc');
        }
    }, [type]);

    useEffect(() => {
        if (documents.length > 0) {
            const options: Record<string, Set<string>> = {};
            
            documents.forEach(doc => {
                if (doc.type === 'Expenses') {
                    // Collect vendors
                    if (doc.vendor) {
                        options.vendor = options.vendor || new Set();
                        options.vendor.add(doc.vendor);
                    }
                    // Collect payment methods
                    if (doc.payment_method) {
                        options.paymentMethods = options.paymentMethods || new Set();
                        options.paymentMethods.add(doc.payment_method);
                    }
                    // Collect categories
                    if (doc.expenseType) {
                        options.categories = options.categories || new Set();
                        options.categories.add(doc.expenseType);
                    }
                }
                // Add similar collectors for other document types
            });

            // Convert Sets to arrays
            const finalOptions = Object.entries(options).reduce((acc, [key, value]) => {
                acc[key] = Array.from(value).sort();
                return acc;
            }, {} as Record<string, string[]>);

            setAvailableOptions(finalOptions);
        }
    }, [documents]);

    useEffect(() => {
        setSelected([]);
    }, [type]);

    const fetchDocuments = async () => {
        setLoading(true);
        setError(null);
        try {
            const docs = await documentsApi.getDocuments(type);
            console.log('DocumentsTable.fetchDocuments: Received documents:', docs);
            setDocuments(docs);
        } catch (error) {
            console.error('Error fetching documents:', error);
            setError('Failed to load documents. Please try again.');
        } finally {
            setLoading(false);
        }
    };

    const handleApprove = async (documentId: string) => {
        try {
            await documentsApi.approveDocument(documentId, type);
            await fetchDocuments(); // Refresh the list after approval
        } catch (error) {
            console.error('Error approving document:', error);
            // You might want to add error handling UI here
        }
    };

    const handleEdit = (documentId: string) => {
        // For now, just log the action
        console.log('Edit document:', documentId);
    };

    const handleSort = useCallback((columnId: string) => {
        const isAsc = orderBy === columnId && order === 'asc';
        setOrder(isAsc ? 'desc' : 'asc');
        setOrderBy(columnId);
    }, [orderBy, order]);

    const getFilteredDocuments = () => {
        let filtered = documents;

        // Apply type-specific filters
        switch (type) {
            case 'W-2':
                const w2Filters = filters as W2Filter;
                if (w2Filters.employer?.length) {
                    filtered = filtered.filter(doc => 
                        doc.type === 'W-2' && 
                        w2Filters.employer?.includes(doc.employer)
                    );
                }
                if (w2Filters.wageRange) {
                    const { min, max } = w2Filters.wageRange;
                    filtered = filtered.filter(doc => {
                        if (doc.type !== 'W-2') return false;
                        return (!min || doc.wages >= min) && (!max || doc.wages <= max);
                    });
                }
                if (w2Filters.withHoldingRange) {
                    const { min, max } = w2Filters.withHoldingRange;
                    filtered = filtered.filter(doc => {
                        if (doc.type !== 'W-2') return false;
                        return (!min || doc.fedWithholding >= min) && (!max || doc.fedWithholding <= max);
                    });
                }
                break;

            case '1099':
                const form1099Filters = filters as Form1099Filter;
                if (form1099Filters.employer?.length) {
                    filtered = filtered.filter(doc => 
                        doc.type === '1099' && 
                        form1099Filters.employer?.includes(doc.employer)
                    );
                }
                if (form1099Filters.amountRange) {
                    const { min, max } = form1099Filters.amountRange;
                    filtered = filtered.filter(doc => {
                        if (doc.type !== '1099') return false;
                        return (!min || doc.nonEmpCompensation >= min) && 
                               (!max || doc.nonEmpCompensation <= max);
                    });
                }
                break;

            case 'Donations':
                const donationFilters = filters as DonationFilter;
                if (donationFilters.charityName?.length) {
                    filtered = filtered.filter(doc => 
                        doc.type === 'Donations' && 
                        donationFilters.charityName?.includes(doc.charityName)
                    );
                }
                if (donationFilters.donationType?.length) {
                    filtered = filtered.filter(doc =>
                        doc.type === 'Donations' &&
                        donationFilters.donationType?.includes(doc.donationType)
                    );
                }
                if (donationFilters.amountRange) {
                    const { min, max } = donationFilters.amountRange;
                    filtered = filtered.filter(doc => {
                        if (doc.type !== 'Donations') return false;
                        return (!min || doc.amount >= min) && (!max || doc.amount <= max);
                    });
                }
                break;

            case 'Expenses':
                const expenseFilters = filters as ExpenseFilter;
                
                // Filter by vendor
                if (expenseFilters.vendor?.length) {
                    filtered = filtered.filter(doc => 
                        doc.type === 'Expenses' && 
                        expenseFilters.vendor?.includes(doc.vendor)
                    );
                }

                // Filter by amount range
                if (expenseFilters.amountRange) {
                    const { min, max } = expenseFilters.amountRange;
                    filtered = filtered.filter(doc => {
                        if (doc.type !== 'Expenses') return false;
                        const amount = typeof doc.amount === 'string' 
                            ? parseFloat(doc.amount.replace(/[^0-9.-]+/g, ''))
                            : doc.amount;
                        return (!min || amount >= min) && (!max || amount <= max);
                    });
                }

                // Filter by date range
                if (expenseFilters.dateRange) {
                    const { start, end } = expenseFilters.dateRange;
                    filtered = filtered.filter(doc => {
                        if (doc.type !== 'Expenses') return false;
                        if (!isValidDate(doc.date)) return false;
                        const date = new Date(doc.date).getTime();
                        return (!start || date >= new Date(start).getTime()) && 
                               (!end || date <= new Date(end).getTime());
                    });
                }

                // Filter by payment method
                if (expenseFilters.paymentMethods?.length) {
                    filtered = filtered.filter(doc =>
                        doc.type === 'Expenses' &&
                        doc.payment_method &&
                        expenseFilters.paymentMethods?.includes(doc.payment_method)
                    );
                }

                // Filter by category
                if (expenseFilters.categories?.length) {
                    filtered = filtered.filter(doc =>
                        doc.type === 'Expenses' &&
                        doc.expenseType &&
                        expenseFilters.categories?.includes(doc.expenseType)
                    );
                }
                break;
        }

        // Apply global search
        if (searchQuery) {
            const query = searchQuery.toLowerCase();
            filtered = filtered.filter(doc => {
                const searchableValues = Object.values(doc)
                    .filter(value => typeof value === 'string' || typeof value === 'number')
                    .map(value => String(value).toLowerCase());
                return searchableValues.some(value => value.includes(query));
            });
        }

        return filtered;
    };

    // Add sorting logic
    const getSortedDocuments = useCallback(() => {
        const filtered = getFilteredDocuments();
        if (!orderBy) return filtered;

        return [...filtered].sort((a, b) => {
            let aValue = a[orderBy as keyof typeof a];
            let bValue = b[orderBy as keyof typeof b];

            // Handle special cases for expense documents
            if (a.type === 'Expenses' && b.type === 'Expenses') {
                // Handle amount sorting
                if (orderBy === 'amount') {
                    aValue = typeof aValue === 'string' 
                        ? parseFloat(aValue.replace(/[^0-9.-]+/g, ''))
                        : aValue;
                    bValue = typeof bValue === 'string' 
                        ? parseFloat(bValue.replace(/[^0-9.-]+/g, ''))
                        : bValue;
                }

                // Handle date sorting
                if (orderBy === 'date') {
                    const aValid = isValidDate(aValue as string);
                    const bValid = isValidDate(bValue as string);

                    // If both dates are invalid, maintain their original order
                    if (!aValid && !bValid) return 0;

                    // In ascending order: invalid dates go to the end
                    // In descending order: invalid dates go to the beginning
                    if (!aValid) return order === 'asc' ? 1 : -1;
                    if (!bValid) return order === 'asc' ? -1 : 1;

                    // Both dates are valid, compare them
                    const aTime = new Date(aValue as string).getTime();
                    const bTime = new Date(bValue as string).getTime();
                    return order === 'asc' ? aTime - bTime : bTime - aTime;
                }
            }

            // Handle null/undefined values
            if (aValue === null || aValue === undefined) return 1;
            if (bValue === null || bValue === undefined) return -1;
            if (aValue === bValue) return 0;

            // Handle numeric values
            if (typeof aValue === 'number' && typeof bValue === 'number') {
                return order === 'asc' ? aValue - bValue : bValue - aValue;
            }

            // Handle string values
            const aString = String(aValue).toLowerCase();
            const bString = String(bValue).toLowerCase();
            
            return order === 'asc' 
                ? aString.localeCompare(bString)
                : bString.localeCompare(aString);
        });
    }, [getFilteredDocuments, orderBy, order]);

    const renderActions = (document: Document) => {
        if (document.type === 'Expenses') {
            return (
                <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
                    <Tooltip title="View Receipt">
                        <IconButton
                            size="small"
                            onClick={(e) => {
                                e.stopPropagation(); // Prevent row click
                                handleEdit(document.id);
                            }}
                        >
                            <VisibilityIcon fontSize="small" />
                        </IconButton>
                    </Tooltip>
                    <Tooltip title="Edit">
                        <IconButton
                            size="small"
                            onClick={(e) => {
                                e.stopPropagation(); // Prevent row click
                                handleEdit(document.id);
                            }}
                        >
                            <EditIcon fontSize="small" />
                        </IconButton>
                    </Tooltip>
                </Box>
            );
        }

        return (
            <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
                <Tooltip title="Approve">
                    <IconButton
                        size="small"
                        onClick={() => handleApprove(document.id)}
                        disabled={document.status === 'approved'}
                    >
                        <CheckCircleIcon fontSize="small" />
                    </IconButton>
                </Tooltip>
                <Tooltip title="Edit">
                    <IconButton
                        size="small"
                        onClick={() => handleEdit(document.id)}
                    >
                        <EditIcon fontSize="small" />
                    </IconButton>
                </Tooltip>
            </Box>
        );
    };

    const filteredDocuments = useMemo(() => 
        getFilteredDocuments(), 
        [documents, getFilteredDocuments, searchQuery]
    );

    const sortedDocuments = useMemo(() => 
        getSortedDocuments(), 
        [getFilteredDocuments, orderBy, order, getSortedDocuments]
    );

    const handleSelectAllClick = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.checked) {
            const newSelected = documents.map(doc => doc.id);
            setSelected(newSelected);
            return;
        }
        setSelected([]);
    };

    const handleClick = (id: number) => {
        const selectedIndex = selected.indexOf(id);
        let newSelected: number[] = [];

        if (selectedIndex === -1) {
            newSelected = newSelected.concat(selected, id);
        } else if (selectedIndex === 0) {
            newSelected = newSelected.concat(selected.slice(1));
        } else if (selectedIndex === selected.length - 1) {
            newSelected = newSelected.concat(selected.slice(0, -1));
        } else if (selectedIndex > 0) {
            newSelected = newSelected.concat(
                selected.slice(0, selectedIndex),
                selected.slice(selectedIndex + 1),
            );
        }

        setSelected(newSelected);
    };

    const handleBulkDelete = async () => {
        if (!selected.length) return;
        
        setIsDeleting(true);
        try {
            await documentsApi.deleteDocuments(selected);
            
            // Only clear selection and refresh if delete was successful
            setSelected([]);
            await fetchDocuments();
            
            setBulkActionStatus({
                show: true,
                message: 'Successfully deleted selected items',
                type: 'success'
            });
            setShowBulkDeleteConfirm(false);
        } catch (error) {
            console.error('Bulk delete error:', error);
            setBulkActionStatus({
                show: true,
                message: error instanceof Error ? error.message : 'Failed to delete selected items',
                type: 'error'
            });
        } finally {
            setIsDeleting(false);
        }
    };

    const renderCell = (document: Document, column: Column) => {
        const value = document[column.id];
        
        if (document.type === 'Expenses' && column.editable) {
            const expenseDoc = document as ExpenseDocument;
            const columnKey = column.id as keyof ExpenseDocument;
            
            // Format the initial value for dates
            let initialValue = expenseDoc[columnKey];
            if (column.editType === 'date') {
                console.log('DocumentsTable.renderCell: Processing date field:', {
                    originalValue: initialValue,
                    type: typeof initialValue,
                    columnKey
                });
            }
            
            return (
                <EditableCell
                    key={column.id}
                    value={initialValue}
                    type={column.editType as 'text' | 'date' | 'amount' | 'select'}
                    options={column.options}
                    align={column.align}
                    format={column.format}
                    onSave={async (newValue: string) => {
                        try {
                            console.log('DocumentsTable.onSave: Updating field:', {
                                documentId: document.id,
                                field: columnKey,
                                oldValue: initialValue,
                                newValue,
                                type: column.editType
                            });
                            
                            // Format the value based on type before sending to API
                            const formattedValue = column.editType === 'amount' 
                                ? parseFloat(newValue.replace(/[^\d.-]/g, ''))
                                : newValue;
                            
                            console.log('DocumentsTable.onSave: Sending to API:', {
                                documentId: document.id,
                                updates: { [columnKey]: formattedValue }
                            });
                            
                            const updates = { [columnKey]: formattedValue };
                            const updatedDoc = await updateDocument(document.id, updates);
                            
                            console.log('DocumentsTable.onSave: Received API response:', {
                                documentId: document.id,
                                updatedDoc
                            });
                            
                            // Update all fields in the document with the response
                            setDocuments(prevDocs =>
                                prevDocs.map(doc =>
                                    doc.id === document.id 
                                        ? { ...doc, ...updatedDoc }
                                        : doc
                                )
                            );
                        } catch (error) {
                            console.error('DocumentsTable.onSave: Update failed:', {
                                error,
                                documentId: document.id,
                                field: columnKey,
                                value: newValue
                            });
                            throw error;
                        }
                    }}
                />
            );
        }

        return (
            <TableCell key={column.id} align={column.align}>
                {column.format && value !== undefined ? column.format(value) : value}
            </TableCell>
        );
    };

    if (loading) {
        return (
            <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                <CircularProgress />
            </Box>
        );
    }

    if (error) {
        return (
            <Paper 
                variant="outlined" 
                sx={{ 
                    p: 4, 
                    textAlign: 'center',
                    color: 'error.main'
                }}
            >
                <Typography>{error}</Typography>
            </Paper>
        );
    }

    if (documents.length === 0) {
        return (
            <Paper 
                variant="outlined" 
                sx={{ 
                    p: 4, 
                    textAlign: 'center',
                    color: 'text.secondary'
                }}
            >
                <Typography>
                    No {type} documents found
                </Typography>
            </Paper>
        );
    }

    return (
        <>
            <DocumentFilters
                type={type}
                filters={filters}
                onFilterChange={onFilterChange}
                availableOptions={availableOptions}
            />
            <Paper>
                <TableToolbar 
                    type={type}
                    numSelected={selected.length}
                    onSelectAll={handleSelectAllClick}
                    onDelete={handleBulkDelete}
                    filters={filters}
                    onFilterChange={onFilterChange}
                    availableOptions={availableOptions}
                />
                <TableContainer>
                    <Table stickyHeader size="small">
                        <TableHead>
                            <TableRow>
                                <TableCell padding="checkbox" />
                                {COLUMNS[type].map((column) => (
                                    <TableCell
                                        key={column.id}
                                        align={column.align}
                                        style={{ minWidth: column.minWidth }}
                                    >
                                        <TableSortLabel
                                            active={orderBy === column.id}
                                            direction={orderBy === column.id ? order : 'asc'}
                                            onClick={() => handleSort(column.id)}
                                            sx={{
                                                '& .MuiTableSortLabel-icon': {
                                                    opacity: orderBy === column.id ? 1 : 0.5
                                                }
                                            }}
                                        >
                                            {column.label}
                                        </TableSortLabel>
                                    </TableCell>
                                ))}
                                <TableCell align="right">Actions</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {sortedDocuments.map((document) => (
                                <TableRow 
                                    hover 
                                    key={document.id}
                                    selected={selected.includes(document.id)}
                                    sx={{ 
                                        '&:hover': {
                                            bgcolor: 'action.hover',
                                        }
                                    }}
                                >
                                    <TableCell padding="checkbox">
                                        <Checkbox
                                            checked={selected.includes(document.id)}
                                            onChange={() => handleClick(document.id)}
                                        />
                                    </TableCell>
                                    {COLUMNS[type].map((column) => renderCell(document, column))}
                                    <TableCell align="right">
                                        {renderActions(document)}
                                    </TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                </TableContainer>
            </Paper>

            <Snackbar
                open={deleteSnackbar.open}
                autoHideDuration={6000}
                onClose={() => setDeleteSnackbar({ ...deleteSnackbar, open: false })}
                message={deleteSnackbar.message}
            />

            <Dialog
                open={showBulkDeleteConfirm}
                onClose={() => setShowBulkDeleteConfirm(false)}
            >
                <DialogTitle>Confirm Delete</DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Are you sure you want to delete {selected.length} selected items?
                    </DialogContentText>
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setShowBulkDeleteConfirm(false)}>
                        Cancel
                    </Button>
                    <Button 
                        onClick={handleBulkDelete}
                        color="error"
                        disabled={isDeleting}
                    >
                        {isDeleting ? 'Deleting...' : 'Delete'}
                    </Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={bulkActionStatus.show}
                autoHideDuration={6000}
                onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
            >
                <Alert 
                    severity={bulkActionStatus.type}
                    onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
                >
                    {bulkActionStatus.message}
                </Alert>
            </Snackbar>
        </>
    );
};

================
File: frontend/components/Documents/DocumentsTabs.tsx
================
import React from 'react';
import { Tabs, Tab, Box } from '@mui/material';
import { DocumentType } from '@/types';

interface DocumentsTabsProps {
    activeTab: DocumentType;
    onTabChange: (tab: DocumentType) => void;
}

const TABS: { value: DocumentType; label: string }[] = [
    { value: 'W-2', label: 'W-2' },
    { value: '1099', label: '1099' },
    { value: 'Expenses', label: 'Expenses' },
    { value: 'Donations', label: 'Donations' },
];

export const DocumentsTabs: React.FC<DocumentsTabsProps> = ({ 
    activeTab, 
    onTabChange 
}) => {
    return (
        <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
            <Tabs 
                value={activeTab}
                onChange={(_, newValue) => onTabChange(newValue)}
                variant="scrollable"
                scrollButtons="auto"
                aria-label="document type tabs"
                sx={{
                    '& .MuiTab-root': {
                        fontSize: '1rem',
                        fontWeight: 600,
                        textTransform: 'none',
                        minWidth: 100,
                    }
                }}
            >
                {TABS.map(tab => (
                    <Tab 
                        key={tab.value}
                        value={tab.value}
                        label={tab.label}
                        id={`tab-${tab.value}`}
                        aria-controls={`tabpanel-${tab.value}`}
                    />
                ))}
            </Tabs>
        </Box>
    );
};

================
File: frontend/components/Documents/DocumentUploadArea.tsx
================
import React, { useCallback, useState } from 'react';
import { Box, Typography, LinearProgress, Alert } from '@mui/material';
import { useDropzone } from 'react-dropzone';
import CloudUploadIcon from '@mui/icons-material/CloudUpload';
import { DocumentType } from '@/types';
import { documentsApi } from '@/lib/api/documents';

interface DocumentUploadAreaProps {
    activeTab: DocumentType;
    onUploadComplete?: () => void;
}

export const DocumentUploadArea: React.FC<DocumentUploadAreaProps> = ({ 
    activeTab,
    onUploadComplete 
}) => {
    const [isUploading, setIsUploading] = useState(false);
    const [uploadError, setUploadError] = useState<string | null>(null);

    const onDrop = useCallback(async (acceptedFiles: File[]) => {
        if (acceptedFiles.length === 0) return;

        setIsUploading(true);
        setUploadError(null);

        try {
            const file = acceptedFiles[0];
            await documentsApi.uploadDocument(file, activeTab);
            if (onUploadComplete) {
                onUploadComplete();
            }
        } catch (error) {
            setUploadError('Failed to upload document. Please try again.');
            console.error('Upload error:', error);
        } finally {
            setIsUploading(false);
        }
    }, [activeTab, onUploadComplete]);

    const { getRootProps, getInputProps, isDragActive } = useDropzone({
        onDrop,
        accept: {
            'image/jpeg': ['.jpg', '.jpeg'],
            'image/png': ['.png'],
            'application/pdf': ['.pdf']
        },
        multiple: false,
        disabled: isUploading
    });

    return (
        <Box 
            {...getRootProps()}
            sx={{
                p: 3,
                mb: 3,
                border: '2px dashed',
                borderColor: theme => 
                    isDragActive 
                        ? 'primary.main' 
                        : uploadError 
                            ? 'error.main' 
                            : 'divider',
                borderRadius: 1,
                bgcolor: theme =>
                    isDragActive
                        ? 'primary.light'
                        : uploadError
                            ? 'error.light'
                            : 'background.default',
                cursor: isUploading ? 'wait' : 'pointer',
                transition: 'all 0.2s ease',
                textAlign: 'center',
                position: 'relative'
            }}
        >
            <input {...getInputProps()} />

            {isUploading && (
                <LinearProgress 
                    sx={{ 
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        borderTopLeftRadius: 'inherit',
                        borderTopRightRadius: 'inherit'
                    }}
                />
            )}

            <Box sx={{ 
                display: 'flex', 
                flexDirection: 'column', 
                alignItems: 'center',
                gap: 2
            }}>
                <CloudUploadIcon 
                    sx={{ 
                        fontSize: 48,
                        color: theme => 
                            isDragActive 
                                ? 'primary.main' 
                                : 'text.secondary'
                    }} 
                />
                
                <Typography variant="h6" component="div">
                    {isDragActive
                        ? `Drop your ${activeTab} document here`
                        : isUploading
                            ? 'Uploading...'
                            : `Drag and drop your ${activeTab} document here`}
                </Typography>

                <Typography variant="body2" color="text.secondary">
                    or click to select files (PDF, JPEG, PNG)
                </Typography>
            </Box>

            {uploadError && (
                <Alert 
                    severity="error" 
                    sx={{ mt: 2 }}
                    onClose={() => setUploadError(null)}
                >
                    {uploadError}
                </Alert>
            )}
        </Box>
    );
};

================
File: frontend/components/Documents/DocumentUploadFab.tsx
================
import React, { useState } from 'react';
import { 
    Fab, 
    Dialog,
    DialogTitle,
    DialogContent,
    IconButton,
    Box,
    useTheme,
    useMediaQuery
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import CloseIcon from '@mui/icons-material/Close';
import { DocumentUploadArea } from './DocumentUploadArea';
import { DocumentType } from '@/types';

export const DocumentUploadFab: React.FC = () => {
    const [isOpen, setIsOpen] = useState(false);
    const theme = useTheme();
    const fullScreen = useMediaQuery(theme.breakpoints.down('sm'));

    return (
        <>
            <Fab
                color="primary"
                aria-label="upload document"
                onClick={() => setIsOpen(true)}
                sx={{
                    position: 'fixed',
                    bottom: 24,
                    right: 24,
                }}
            >
                <AddIcon />
            </Fab>

            <Dialog
                open={isOpen}
                onClose={() => setIsOpen(false)}
                fullScreen={fullScreen}
                maxWidth="md"
                fullWidth
            >
                <DialogTitle sx={{ 
                    m: 0, 
                    p: 2, 
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }}>
                    Upload Document
                    <IconButton
                        aria-label="close"
                        onClick={() => setIsOpen(false)}
                        sx={{ color: 'text.secondary' }}
                    >
                        <CloseIcon />
                    </IconButton>
                </DialogTitle>
                <DialogContent>
                    <Box sx={{ pt: 2 }}>
                        <DocumentUploadArea activeTab={'W-2' as DocumentType} />
                    </Box>
                </DialogContent>
            </Dialog>
        </>
    );
};

================
File: frontend/components/Documents/EditableCell.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import {
  TextField,
  TableCell,
  ClickAwayListener,
  Select,
  MenuItem,
  InputAdornment,
  Box,
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { format, parse, isValid } from 'date-fns';
import { enUS } from 'date-fns/locale';

interface EditableCellProps {
  value: string | number;
  type: 'text' | 'date' | 'amount' | 'select';
  onSave: (newValue: string) => Promise<void>;
  options?: string[];
  disabled?: boolean;
  align?: 'left' | 'right' | 'center';
  format?: (value: any) => string;
}

export const EditableCell: React.FC<EditableCellProps> = ({
  value,
  type,
  onSave,
  options = [],
  disabled = false,
  align = 'left',
  format: formatValue,
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(value.toString());
  const [error, setError] = useState<string | null>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    setEditValue(value.toString());
  }, [value]);

  const handleClick = () => {
    if (!disabled) {
      console.log('EditableCell: Starting edit mode:', { type, value });
      setIsEditing(true);
    }
  };

  const exitEditMode = () => {
    setIsEditing(false);
    setEditValue(value.toString());
    setError(null);
  };

  const handleSave = async () => {
    if (!isEditing) return;
    
    try {
      if (type === 'date') {
        console.log('EditableCell.handleSave: Processing date value:', {
          editValue,
          type: typeof editValue
        });
        
        // If the value is empty, don't process it
        if (!editValue.trim()) {
          console.log('EditableCell.handleSave: Empty date value, skipping');
          await onSave('');
          setError(null);
          exitEditMode();
          return;
        }

        // Try to parse the date
        const date = parse(editValue.trim(), 'yyyy-MM-dd', new Date(), { locale: enUS });
        console.log('EditableCell.handleSave: Parsed date:', {
          date,
          isValid: isValid(date)
        });

        if (!isValid(date)) {
          console.error('EditableCell.handleSave: Invalid date format:', editValue);
          throw new Error('Please use YYYY-MM-DD format');
        }

        // Format the date for saving
        const formattedDate = format(date, 'yyyy-MM-dd', { locale: enUS });
        console.log('EditableCell.handleSave: Sending formatted date:', formattedDate);
        
        await onSave(formattedDate);
        console.log('EditableCell.handleSave: Date saved successfully');
        setError(null);
      } else if (type === 'amount') {
        const amount = parseFloat(editValue.replace(/[^\d.-]/g, ''));
        if (isNaN(amount)) {
          throw new Error('Invalid amount format');
        }
        await onSave(amount.toString());
        setError(null);
      } else {
        await onSave(editValue);
        setError(null);
      }
      exitEditMode();
    } catch (err) {
      console.error('EditableCell.handleSave: Error saving value:', {
        error: err,
        type,
        value: editValue
      });
      setError(err instanceof Error ? err.message : 'An error occurred');
      return;
    }
  };

  const handleDateChange = (newValue: Date | null) => {
    console.log('EditableCell.handleDateChange: New date selected:', {
      newValue,
      isValid: newValue && isValid(newValue)
    });

    if (newValue && isValid(newValue)) {
      const formattedDate = format(newValue, 'yyyy-MM-dd', { locale: enUS });
      console.log('EditableCell.handleDateChange: Formatted date:', formattedDate);
      setEditValue(formattedDate);
      setError(null);
    } else {
      console.log('EditableCell.handleDateChange: Invalid or null date');
      setEditValue('');
      setError('Please select a valid date');
    }
  };

  const parseDate = (dateStr: string) => {
    console.log('EditableCell.parseDate: Input:', {
      value: dateStr,
      type: typeof dateStr
    });
    
    try {
      if (!dateStr || dateStr === 'Invalid Date') {
        console.log('EditableCell.parseDate: Empty or Invalid Date string');
        return null;
      }
      const trimmedDate = dateStr.trim();
      console.log('EditableCell.parseDate: Trimmed:', trimmedDate);
      
      const date = parse(trimmedDate, 'yyyy-MM-dd', new Date(), { locale: enUS });
      console.log('EditableCell.parseDate: Parsed result:', {
        date,
        isValid: isValid(date)
      });
      
      return isValid(date) ? date : null;
    } catch (e) {
      console.error('EditableCell.parseDate: Error:', e);
      return null;
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSave();
    } else if (e.key === 'Escape') {
      exitEditMode();
    }
  };

  if (!isEditing) {
    return (
      <TableCell
        align={align}
        onClick={handleClick}
        sx={{ 
          cursor: disabled ? 'default' : 'pointer',
          padding: '16px',
          '&:hover': {
            backgroundColor: disabled ? 'transparent' : 'action.hover',
          }
        }}
      >
        {formatValue ? formatValue(value) : value}
      </TableCell>
    );
  }

  return (
    <TableCell 
      align={align} 
      padding="none"
      sx={{
        position: 'relative',
        '& .MuiInputBase-root': {
          backgroundColor: 'background.paper',
        }
      }}
    >
      <ClickAwayListener onClickAway={handleSave}>
        <Box sx={{ p: 1 }}>
          {type === 'date' ? (
            <LocalizationProvider dateAdapter={AdapterDateFns}>
              <DatePicker
                value={parseDate(editValue)}
                onChange={handleDateChange}
                format="yyyy-MM-dd"
                slotProps={{
                  textField: {
                    error: !!error,
                    helperText: error || 'Use format: YYYY-MM-DD',
                    onKeyDown: handleKeyDown,
                    size: "small",
                    fullWidth: true,
                    inputRef: inputRef,
                    sx: { backgroundColor: 'background.paper' }
                  }
                }}
              />
            </LocalizationProvider>
          ) : type === 'amount' ? (
            <TextField
              value={editValue}
              onChange={(e) => setEditValue(e.target.value)}
              onKeyDown={handleKeyDown}
              error={!!error}
              helperText={error}
              size="small"
              fullWidth
              inputRef={inputRef}
              InputProps={{
                startAdornment: <InputAdornment position="start">$</InputAdornment>,
              }}
              sx={{ backgroundColor: 'background.paper' }}
            />
          ) : type === 'select' ? (
            <Select
              value={editValue}
              onChange={(e) => setEditValue(e.target.value)}
              onKeyDown={handleKeyDown}
              size="small"
              fullWidth
              sx={{ backgroundColor: 'background.paper' }}
            >
              {options.map((option) => (
                <MenuItem key={option} value={option}>
                  {option}
                </MenuItem>
              ))}
            </Select>
          ) : (
            <TextField
              value={editValue}
              onChange={(e) => setEditValue(e.target.value)}
              onKeyDown={handleKeyDown}
              error={!!error}
              helperText={error}
              size="small"
              fullWidth
              inputRef={inputRef}
              sx={{ backgroundColor: 'background.paper' }}
            />
          )}
        </Box>
      </ClickAwayListener>
    </TableCell>
  );
};

================
File: frontend/components/Documents/ExpenseFilters.tsx
================
import React, { useState, useEffect } from 'react';
import {
    Box,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    Typography,
    TextField,
    Select,
    MenuItem,
    FormControl,
    InputLabel,
    Chip,
    IconButton,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import FilterListIcon from '@mui/icons-material/FilterList';
import CloseIcon from '@mui/icons-material/Close';

export interface ExpenseFilter {
    vendor?: string[];
    amountRange?: {
        min?: number;
        max?: number;
    };
    dateRange?: {
        start?: string;
        end?: string;
    };
    paymentMethods?: string[];
    categories?: string[];
    status?: string[];
}

interface FilterOptions {
    categories: string[];
    payment_methods: string[];
    statuses: string[];
    vendors: string[];
}

interface ExpenseFiltersProps {
    filters: ExpenseFilter;
    onFilterChange: (filters: ExpenseFilter) => void;
}

export const ExpenseFilters: React.FC<ExpenseFiltersProps> = ({
    filters,
    onFilterChange,
}) => {
    const [filterOptions, setFilterOptions] = useState<FilterOptions>({
        categories: [],
        payment_methods: [],
        statuses: [],
        vendors: []
    });

    useEffect(() => {
        // Fetch filter options from the backend
        const fetchOptions = async () => {
            try {
                const response = await fetch('/api/options');
                if (!response.ok) {
                    throw new Error('Failed to fetch options');
                }
                const data = await response.json();
                setFilterOptions(data);
            } catch (error) {
                console.error('Error fetching filter options:', error);
            }
        };

        fetchOptions();
    }, []);

    const handleRemoveFilter = (type: keyof ExpenseFilter, value?: string) => {
        const newFilters = { ...filters };
        if (value && Array.isArray(newFilters[type])) {
            newFilters[type] = (newFilters[type] as string[]).filter(v => v !== value);
            if ((newFilters[type] as string[]).length === 0) {
                delete newFilters[type];
            }
        } else {
            delete newFilters[type];
        }
        onFilterChange(newFilters);
    };

    return (
        <Box sx={{ mb: 2 }}>
            <Accordion>
                <AccordionSummary
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                        bgcolor: 'background.default',
                        '&:hover': { bgcolor: 'action.hover' }
                    }}
                >
                    <Box sx={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 1 
                    }}>
                        <FilterListIcon />
                        <Typography>Filters</Typography>
                    </Box>
                </AccordionSummary>
                <AccordionDetails>
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                        {/* Amount Range */}
                        <Box sx={{ display: 'flex', gap: 2 }}>
                            <TextField
                                label="Min Amount"
                                type="number"
                                size="small"
                                value={filters.amountRange?.min || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    amountRange: {
                                        ...filters.amountRange,
                                        min: e.target.value ? Number(e.target.value) : undefined
                                    }
                                })}
                            />
                            <TextField
                                label="Max Amount"
                                type="number"
                                size="small"
                                value={filters.amountRange?.max || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    amountRange: {
                                        ...filters.amountRange,
                                        max: e.target.value ? Number(e.target.value) : undefined
                                    }
                                })}
                            />
                        </Box>

                        {/* Date Range */}
                        <Box sx={{ display: 'flex', gap: 2 }}>
                            <TextField
                                label="Start Date"
                                type="date"
                                size="small"
                                InputLabelProps={{ shrink: true }}
                                value={filters.dateRange?.start || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    dateRange: {
                                        ...filters.dateRange,
                                        start: e.target.value || undefined
                                    }
                                })}
                            />
                            <TextField
                                label="End Date"
                                type="date"
                                size="small"
                                InputLabelProps={{ shrink: true }}
                                value={filters.dateRange?.end || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    dateRange: {
                                        ...filters.dateRange,
                                        end: e.target.value || undefined
                                    }
                                })}
                            />
                        </Box>

                        {/* Multi-select filters */}
                        <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                            {/* Vendor Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Vendor</InputLabel>
                                <Select
                                    multiple
                                    value={filters.vendor || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        vendor: e.target.value as string[]
                                    })}
                                    label="Vendor"
                                >
                                    {filterOptions.vendors.map((vendor) => (
                                        <MenuItem key={vendor} value={vendor}>
                                            {vendor}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>

                            {/* Payment Method Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Payment Method</InputLabel>
                                <Select
                                    multiple
                                    value={filters.paymentMethods || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        paymentMethods: e.target.value as string[]
                                    })}
                                    label="Payment Method"
                                >
                                    {filterOptions.payment_methods.map((method) => (
                                        <MenuItem key={method} value={method}>
                                            {method}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>

                            {/* Category Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Category</InputLabel>
                                <Select
                                    multiple
                                    value={filters.categories || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        categories: e.target.value as string[]
                                    })}
                                    label="Category"
                                >
                                    {filterOptions.categories.map((category) => (
                                        <MenuItem key={category} value={category}>
                                            {category}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>

                            {/* Status Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Status</InputLabel>
                                <Select
                                    multiple
                                    value={filters.status || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        status: e.target.value as string[]
                                    })}
                                    label="Status"
                                >
                                    {filterOptions.statuses.map((status) => (
                                        <MenuItem key={status} value={status}>
                                            {status}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Box>
                    </Box>
                </AccordionDetails>
            </Accordion>

            {/* Active Filters Display */}
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>
                {Object.entries(filters).map(([key, value]) => {
                    if (Array.isArray(value)) {
                        return value.map((v) => (
                            <Chip
                                key={`${key}-${v}`}
                                label={`${key}: ${v}`}
                                onDelete={() => handleRemoveFilter(key as keyof ExpenseFilter, v)}
                                size="small"
                            />
                        ));
                    }
                    if (key === 'amountRange' && value) {
                        const { min, max } = value;
                        if (min || max) {
                            return (
                                <Chip
                                    key="amount"
                                    label={`Amount: ${min || '0'} - ${max || '∞'}`}
                                    onDelete={() => handleRemoveFilter('amountRange')}
                                    size="small"
                                />
                            );
                        }
                    }
                    if (key === 'dateRange' && value) {
                        const { start, end } = value;
                        if (start || end) {
                            return (
                                <Chip
                                    key="date"
                                    label={`Date: ${start || '∞'} - ${end || '∞'}`}
                                    onDelete={() => handleRemoveFilter('dateRange')}
                                    size="small"
                                />
                            );
                        }
                    }
                    return null;
                })}
            </Box>
        </Box>
    );
};

================
File: frontend/components/GlobalHeader/GlobalHeader.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import Link from 'next/link';
import { 
    AppBar,
    Toolbar,
    Typography,
    InputBase,
    Box,
    IconButton,
    Paper,
    useMediaQuery,
    useTheme,
    TextField
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import HelpOutlineIcon from '@mui/icons-material/HelpOutline';
import { styled } from '@mui/material/styles';
import { SearchResult } from '@/types';
import { useSearch } from '@/contexts/SearchContext';

const SearchInput = styled(InputBase)(({ theme }) => ({
    marginLeft: theme.spacing(1),
    flex: 1,
}));

const SearchResults = styled(Paper)(({ theme }) => ({
    position: 'absolute',
    top: '100%',
    left: 0,
    right: 0,
    zIndex: 1,
    marginTop: theme.spacing(1),
    maxHeight: '400px',
    overflow: 'auto'
}));

const ResultGroup = styled(Box)(({ theme }) => ({
    padding: theme.spacing(1, 2)
}));

const GroupHeader = styled(Typography)(({ theme }) => ({
    color: theme.palette.text.secondary,
    fontSize: '0.75rem',
    fontWeight: 600,
    textTransform: 'uppercase',
    marginBottom: theme.spacing(1)
}));

const SearchResultItem = styled(Box)(({ theme }) => ({
    display: 'flex',
    alignItems: 'center',
    padding: theme.spacing(1),
    cursor: 'pointer',
    '&:hover': {
        backgroundColor: theme.palette.action.hover
    }
}));

const TaxDisplay = styled(Typography)(({ theme }) => ({
    fontSize: '1.125rem',
    fontWeight: 600,
    letterSpacing: '0.5px',
    textTransform: 'uppercase',
    color: theme.palette.primary.main,
    display: 'flex',
    alignItems: 'center',
    gap: theme.spacing(1),
    '& .amount': {
        fontWeight: 700,
        color: theme.palette.success.main
    }
}));

// Add children to the component props
interface GlobalHeaderProps {
    children?: React.ReactNode;
}

const GlobalHeader: React.FC<GlobalHeaderProps> = ({ children }) => {
    const { searchQuery, setSearchQuery } = useSearch();
    const [showSearchResults, setShowSearchResults] = useState(false);
    const [isSearchExpanded, setIsSearchExpanded] = useState(false);
    const searchRef = useRef<HTMLDivElement>(null);
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const defaultSearchResults: SearchResult[] = [
        { id: '1', type: 'W-2', name: 'Google Inc', group: 'W-2 Employers' },
        { id: '2', type: '1099', name: 'Freelance Client', group: '1099 Payers' },
        { id: '3', type: 'expense', name: 'Office Supplies', group: 'Vendors' },
        { id: '4', type: 'donation', name: 'Red Cross', group: 'Charities' },
    ];

    const [searchResults, setSearchResults] = useState([...defaultSearchResults]);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (searchRef.current && !searchRef.current.contains(event.target as Node)) {
                setShowSearchResults(false);
                if (isMobile) setIsSearchExpanded(false);
            }
        };

        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [isMobile]);

    const handleSearchFocus = () => {
        setShowSearchResults(true);
        setIsSearchExpanded(true);
    };

    const handleSearchClick = () => {
        if (isMobile && !isSearchExpanded) {
            setIsSearchExpanded(true);
        }
    };

    const groupedResults = searchResults.reduce((acc, result) => ({
        ...acc,
        [result.group]: [...(acc[result.group] || []), result]
    }), {} as Record<string, SearchResult[]>);

    return (
        <AppBar 
            position="fixed" 
            color="default" 
            elevation={1}
            sx={{ 
                zIndex: theme => theme.zIndex.drawer + 1,
                borderRadius: 0,
                '& .MuiToolbar-root': {
                    borderRadius: 0,
                }
            }}
        >
            <Toolbar>
                {children}
                <Typography
                    variant="h6"
                    component={Link}
                    href="/"
                    sx={{ 
                        textDecoration: 'none',
                        color: 'inherit',
                        flexGrow: 0,
                        display: isMobile && isSearchExpanded ? 'none' : 'block'
                    }}
                >
                    ten40
                </Typography>

                <Box sx={{ 
                    flexGrow: 1, 
                    display: 'flex', 
                    justifyContent: 'center',
                    visibility: (isMobile && isSearchExpanded) ? 'hidden' : 'visible',
                    py: 1
                }}>
                    <TaxDisplay>
                        CURRENT TAX: <span className="amount">+$500</span>
                    </TaxDisplay>
                </Box>

                <Box sx={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: 2,
                    ml: 'auto'
                }}>
                    <Box 
                        ref={searchRef}
                        sx={{ 
                            position: 'relative',
                            width: isSearchExpanded ? '100%' : 'auto',
                            maxWidth: '300px',
                            transition: 'width 0.2s ease-in-out'
                        }}
                    >
                        {(!isMobile || isSearchExpanded) && (
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <SearchIcon sx={{ color: 'text.secondary', mr: 1 }} />
                                <SearchInput
                                    placeholder="Search..."
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                    onFocus={handleSearchFocus}
                                    onClick={handleSearchClick}
                                    sx={{ width: isSearchExpanded ? '100%' : '200px' }}
                                />
                            </Box>
                        )}
                        {showSearchResults && (
                            <SearchResults elevation={3}>
                                {Object.entries(groupedResults).map(([group, results]) => (
                                    <ResultGroup key={group}>
                                        <GroupHeader>{group}</GroupHeader>
                                        {results.map((result) => (
                                            <SearchResultItem key={result.id}>
                                                <Typography variant="body2" color="text.secondary" sx={{ mr: 1 }}>
                                                    {result.type}
                                                </Typography>
                                                <Typography variant="body2">
                                                    {result.name}
                                                </Typography>
                                            </SearchResultItem>
                                        ))}
                                    </ResultGroup>
                                ))}
                            </SearchResults>
                        )}
                    </Box>

                    {(!isMobile || !isSearchExpanded) && (
                        <IconButton
                            onClick={() => {/* TODO: Implement help panel */}}
                            title="Get Help"
                            size="small"
                            sx={{ ml: 1 }}
                        >
                            <HelpOutlineIcon />
                        </IconButton>
                    )}
                </Box>
            </Toolbar>
        </AppBar>
    );
};

export default GlobalHeader;

================
File: frontend/components/Layout/Layout.tsx
================
import React, { useState } from 'react';
import { Box, IconButton, useMediaQuery, useTheme } from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import { LeftNav } from '../LeftNav/LeftNav';
import GlobalHeader from '../GlobalHeader/GlobalHeader';

interface LayoutProps {
    children: React.ReactNode;
}

const DRAWER_WIDTH = 250;
const HEADER_HEIGHT = 64;

export const Layout: React.FC<LayoutProps> = ({ children }) => {
    const [mobileOpen, setMobileOpen] = useState(false);
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const handleDrawerToggle = () => {
        setMobileOpen(!mobileOpen);
    };

    return (
        <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
            <GlobalHeader>
                {isMobile && (
                    <IconButton
                        color="inherit"
                        aria-label="open drawer"
                        edge="start"
                        onClick={handleDrawerToggle}
                        sx={{ mr: 2, display: { sm: 'none' } }}
                    >
                        <MenuIcon />
                    </IconButton>
                )}
            </GlobalHeader>
            
            <Box sx={{ display: 'flex', flex: 1 }}>
                <LeftNav 
                    mobileOpen={mobileOpen} 
                    onMobileClose={() => setMobileOpen(false)} 
                />
                
                <Box
                    component="main"
                    sx={{
                        flexGrow: 1,
                        minHeight: `calc(100vh - ${HEADER_HEIGHT}px)`,
                        mt: `${HEADER_HEIGHT}px`,
                        width: '100%',
                        position: 'relative',
                        pl: { sm: `${DRAWER_WIDTH}px` },
                    }}
                >
                    {children}
                </Box>
            </Box>
        </Box>
    );
};

================
File: frontend/components/LeftNav/LeftNav.tsx
================
import React from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import {
    Drawer,
    List,
    ListItem,
    ListItemButton,
    ListItemIcon,
    ListItemText,
    useTheme,
    useMediaQuery,
    IconButton,
    Box,
} from '@mui/material';
import { styled } from '@mui/material/styles';
import DashboardIcon from '@mui/icons-material/Dashboard';
import DescriptionIcon from '@mui/icons-material/Description';
import ReceiptIcon from '@mui/icons-material/Receipt';
import PersonIcon from '@mui/icons-material/Person';
import CloseIcon from '@mui/icons-material/Close';

const DRAWER_WIDTH = 250;
const HEADER_HEIGHT = 64; // Standard MUI AppBar height

interface NavItem {
    path: string;
    label: string;
    icon: React.ReactNode;
}

const NAV_ITEMS: NavItem[] = [
    { path: '/dashboard', label: 'Dashboard', icon: <DashboardIcon /> },
    { path: '/documents', label: 'Documents', icon: <DescriptionIcon /> },
    { path: '/1040', label: '1040', icon: <ReceiptIcon /> },
    { path: '/profile', label: 'Profile', icon: <PersonIcon /> },
];

const StyledDrawer = styled(Drawer)(({ theme }) => ({
    width: DRAWER_WIDTH,
    flexShrink: 0,
    '& .MuiDrawer-paper': {
        width: DRAWER_WIDTH,
        boxSizing: 'border-box',
        borderRight: `1px solid ${theme.palette.divider}`,
        backgroundColor: theme.palette.background.paper,
        height: `calc(100% - ${HEADER_HEIGHT}px)`,
        top: HEADER_HEIGHT,
    },
}));

interface LeftNavProps {
    mobileOpen: boolean;
    onMobileClose: () => void;
}

export const LeftNav: React.FC<LeftNavProps> = ({ mobileOpen, onMobileClose }) => {
    const router = useRouter();
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const isSelected = (path: string, currentPath: string) => {
        if (path === '/documents') {
            return currentPath === path || currentPath.startsWith('/receipt/');
        }
        return currentPath === path;
    };

    const drawer = (
        <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
            {isMobile && (
                <Box sx={{ 
                    display: 'flex', 
                    justifyContent: 'flex-end', 
                    p: 1,
                    borderBottom: 1,
                    borderColor: 'divider'
                }}>
                    <IconButton onClick={onMobileClose} size="small">
                        <CloseIcon />
                    </IconButton>
                </Box>
            )}
            <List sx={{ flex: 1, pt: isMobile ? 0 : 2 }}>
                {NAV_ITEMS.map(({ path, label, icon }) => (
                    <ListItem key={path} disablePadding>
                        <ListItemButton
                            component={Link}
                            href={path}
                            selected={isSelected(path, router.pathname)}
                            onClick={isMobile ? onMobileClose : undefined}
                            sx={{
                                py: 1.5,
                                px: 2,
                                '&.Mui-selected': {
                                    bgcolor: 'primary.light',
                                    color: 'primary.main',
                                    '&:hover': {
                                        bgcolor: 'primary.light',
                                    },
                                    '& .MuiListItemIcon-root': {
                                        color: 'primary.main',
                                    },
                                },
                            }}
                        >
                            <ListItemIcon sx={{ minWidth: 40 }}>
                                {icon}
                            </ListItemIcon>
                            <ListItemText 
                                primary={label}
                                primaryTypographyProps={{
                                    fontSize: '0.9375rem',
                                    fontWeight: 600,
                                }}
                            />
                        </ListItemButton>
                    </ListItem>
                ))}
            </List>
        </Box>
    );

    return (
        <>
            {/* Desktop permanent drawer */}
            {!isMobile && (
                <StyledDrawer
                    variant="permanent"
                    open
                >
                    {drawer}
                </StyledDrawer>
            )}

            {/* Mobile temporary drawer */}
            {isMobile && (
                <Drawer
                    variant="temporary"
                    open={mobileOpen}
                    onClose={onMobileClose}
                    ModalProps={{
                        keepMounted: true,
                    }}
                    sx={{
                        display: { xs: 'block', sm: 'none' },
                        '& .MuiDrawer-paper': { 
                            width: DRAWER_WIDTH,
                            boxSizing: 'border-box',
                            top: HEADER_HEIGHT,
                            height: `calc(100% - ${HEADER_HEIGHT}px)`,
                        },
                    }}
                >
                    {drawer}
                </Drawer>
            )}
        </>
    );
};

================
File: frontend/components/ErrorBoundary.tsx
================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Alert, Button, Box } from '@mui/material';

interface Props {
    children: ReactNode;
}

interface State {
    hasError: boolean;
    error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
    public state: State = {
        hasError: false,
        error: null
    };

    public static getDerivedStateFromError(error: Error): State {
        return { hasError: true, error };
    }

    public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.error('Uncaught error:', error, errorInfo);
    }

    public render() {
        if (this.state.hasError) {
            return (
                <Box sx={{ p: 2 }}>
                    <Alert 
                        severity="error"
                        action={
                            <Button 
                                color="inherit" 
                                size="small"
                                onClick={() => window.location.reload()}
                            >
                                Reload Page
                            </Button>
                        }
                    >
                        Something went wrong. Please try again.
                    </Alert>
                </Box>
            );
        }

        return this.props.children;
    }
}

================
File: frontend/components/ImageViewer.tsx
================
import React from 'react';
import { Box, useMediaQuery, Theme } from '@mui/material';
import { DialogWrapper } from './common/DialogWrapper';

interface ImageViewerProps {
    imagePath: string;
    onClose: () => void;
}

export const ImageViewer: React.FC<ImageViewerProps> = ({ imagePath, onClose }) => {
    const isSmallScreen = useMediaQuery((theme: Theme) => theme.breakpoints.down('sm'));

    return (
        <DialogWrapper
            title="Receipt Image"
            open={true}
            onClose={onClose}
        >
            <Box sx={{ bgcolor: 'black', p: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                    <img 
                        src={`/api/images/${imagePath}`}
                        alt="Receipt"
                        style={{
                            maxWidth: '100%',
                            maxHeight: isSmallScreen ? '90vh' : 'calc(90vh - 100px)',
                            objectFit: 'contain'
                        }}
                    />
                </Box>
            </Box>
        </DialogWrapper>
    );
};

================
File: frontend/components/JsonViewer.tsx
================
import React from 'react';
import { Paper, Box } from '@mui/material';
import { DialogWrapper } from './common/DialogWrapper';

interface JsonViewerProps {
    data: any;
    onClose: () => void;
}

export const JsonViewer: React.FC<JsonViewerProps> = ({ data, onClose }) => {
    return (
        <DialogWrapper
            title="Receipt Data"
            open={true}
            onClose={onClose}
        >
            <Paper 
                sx={{ 
                    p: 2, 
                    bgcolor: 'grey.100',
                    maxHeight: '60vh',
                    overflow: 'auto'
                }}
            >
                <pre style={{ margin: 0, fontSize: '0.875rem' }}>
                    {JSON.stringify(data, null, 2)}
                </pre>
            </Paper>
        </DialogWrapper>
    );
};

================
File: frontend/components/ReceiptDetail.tsx
================
import { useState, useEffect } from 'react';
import { Box, Typography, Paper, Grid, Skeleton } from '@mui/material';
import { fetchReceipt } from '../lib/api/documents';
import ErrorMessage from './common/ErrorMessage';
import { Receipt } from '../types';

interface ReceiptDetailProps {
  receiptId: string | string[] | undefined;
}

export default function ReceiptDetail({ receiptId }: ReceiptDetailProps) {
  const [receipt, setReceipt] = useState<Receipt | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadReceipt = async () => {
      if (!receiptId) return;
      
      try {
        setLoading(true);
        const data = await fetchReceipt(receiptId.toString());
        setReceipt(data);
      } catch (err) {
        setError('Failed to load receipt details');
        console.error('Error loading receipt:', err);
      } finally {
        setLoading(false);
      }
    };

    loadReceipt();
  }, [receiptId]);

  if (loading) {
    return <ReceiptSkeleton />;
  }

  if (error) {
    return <ErrorMessage message={error} />;
  }

  if (!receipt) {
    return <ErrorMessage message="Receipt not found" />;
  }

  return (
    <Paper elevation={2}>
      <Box p={3}>
        <Grid container spacing={3}>
          <Grid item xs={12} md={6}>
            <Typography variant="h5" gutterBottom>
              Receipt Details
            </Typography>
            <Typography>
              <strong>Date:</strong> {new Date(receipt.date).toLocaleDateString()}
            </Typography>
            <Typography>
              <strong>Total Amount:</strong> ${receipt.totalAmount.toFixed(2)}
            </Typography>
            <Typography>
              <strong>Vendor:</strong> {receipt.vendor}
            </Typography>
            <Typography>
              <strong>Category:</strong> {receipt.category}
            </Typography>
          </Grid>
          <Grid item xs={12} md={6}>
            {receipt.imageUrl && (
              <Box
                component="img"
                src={receipt.imageUrl}
                alt="Receipt"
                sx={{
                  maxWidth: '100%',
                  height: 'auto',
                  borderRadius: 1
                }}
              />
            )}
          </Grid>
        </Grid>
      </Box>
    </Paper>
  );
}

const ReceiptSkeleton = () => (
  <Paper elevation={2}>
    <Box p={3}>
      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          <Skeleton variant="text" width="60%" height={40} />
          <Skeleton variant="text" width="40%" />
          <Skeleton variant="text" width="40%" />
          <Skeleton variant="text" width="40%" />
        </Grid>
        <Grid item xs={12} md={6}>
          <Skeleton variant="rectangular" width="100%" height={300} />
        </Grid>
      </Grid>
    </Box>
  </Paper>
);

================
File: frontend/components/ReceiptList.tsx
================
import React, { useState, useEffect } from 'react';
import { 
    Container, 
    Typography, 
    Paper, 
    Table, 
    TableBody, 
    TableCell, 
    TableContainer, 
    TableHead, 
    TableRow,
    Button,
    Box,
    IconButton,
    CircularProgress,
    Tooltip,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    DialogContentText,
    Checkbox,
    Alert,
    Snackbar
} from '@mui/material';
import UploadIcon from '@mui/icons-material/Upload';
import VisibilityIcon from '@mui/icons-material/Visibility';
import DataObjectIcon from '@mui/icons-material/DataObject';
import DeleteIcon from '@mui/icons-material/Delete';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import { JsonViewer } from '@/components/JsonViewer';
import { ImageViewer } from '@/components/ImageViewer';
import { UploadArea } from './UploadArea';

interface Receipt {
    id: number;
    image_path: string;
    vendor: string;
    amount: string;
    date: string;
    payment_method: string;
    category: string;
    content: any;
}

type SortField = 'vendor' | 'amount' | 'date' | 'payment_method' | 'category';
type SortDirection = 'asc' | 'desc';

export const ReceiptList = () => {
    const [receipts, setReceipts] = useState<Receipt[]>([]);
    const [selectedImage, setSelectedImage] = useState<string | null>(null);
    const [selectedJson, setSelectedJson] = useState<any | null>(null);
    const [isUploading, setIsUploading] = useState(false);
    const [uploadError, setUploadError] = useState<string | null>(null);
    const [deleteConfirmOpen, setDeleteConfirmOpen] = useState<number | null>(null);
    const [isDeleting, setIsDeleting] = useState(false);
    const [sortField, setSortField] = useState<SortField>('date');
    const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
    const [selectedReceipts, setSelectedReceipts] = useState<number[]>([]);
    const [showBulkDeleteConfirm, setShowBulkDeleteConfirm] = useState(false);
    const [bulkActionStatus, setBulkActionStatus] = useState<{
        show: boolean;
        message: string;
        type: 'success' | 'error';
    }>({ show: false, message: '', type: 'success' });

    const fetchReceipts = async () => {
        try {
            const response = await fetch('/api/receipts');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            setReceipts(data);
        } catch (error) {
            console.error('Error fetching receipts:', error);
        }
    };

    useEffect(() => {
        fetchReceipts();
    }, []);

    const handleFileUpload = async (file: File) => {
        console.log('Starting file upload for:', file.name);
        
        // Check file type
        if (!file.type.match(/^image\/(jpeg|png)$/)) {
            const error = 'Invalid file type. Please upload a JPEG or PNG image.';
            console.error(error);
            setUploadError(error);
            return;
        }

        if (file.size > 15 * 1024 * 1024) {
            const error = 'File size too large. Maximum size is 15MB.';
            console.error(error);
            setUploadError(error);
            return;
        }

        setIsUploading(true);
        setUploadError(null);
        const formData = new FormData();
        formData.append('file', file);

        try {
            console.log('Sending request to /api/upload');
            
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            console.log('Upload response status:', response.status);
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Upload failed: ${response.statusText}. ${errorText}`);
            }

            const data = await response.json();
            console.log('Upload response:', data);

            await fetchReceipts();
        } catch (error) {
            const message = error instanceof Error ? error.message : 'Upload failed';
            console.error('Upload error:', error);
            setUploadError(message);
        } finally {
            setIsUploading(false);
        }
    };

    const handleDeleteConfirm = async () => {
        if (deleteConfirmOpen === null) return;

        setIsDeleting(true);
        try {
            const response = await fetch(`/api/receipts/${deleteConfirmOpen}`, {
                method: 'DELETE'
            });

            if (!response.ok) {
                throw new Error(`Failed to delete receipt: ${response.statusText}`);
            }

            await fetchReceipts();
        } catch (error) {
            console.error('Delete error:', error);
        } finally {
            setIsDeleting(false);
            setDeleteConfirmOpen(null);
        }
    };

    const sortReceipts = (receipts: Receipt[]): Receipt[] => {
        return [...receipts].sort((a, b) => {
            const aValue = a[sortField];
            const bValue = b[sortField];
            
            const comparison = sortDirection === 'asc' 
                ? String(aValue).localeCompare(String(bValue))
                : String(bValue).localeCompare(String(aValue));
            
            return comparison;
        });
    };

    const handleSort = (field: SortField) => {
        if (field === sortField) {
            setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
        } else {
            setSortField(field);
            setSortDirection('asc');
        }
    };

    const SortIcon = ({ field }: { field: SortField }) => {
        if (sortField !== field) return (
            <KeyboardArrowUpIcon 
                sx={{ 
                    width: 16, 
                    height: 16, 
                    color: 'text.disabled' 
                }} 
            />
        );
        return sortDirection === 'asc' 
            ? <KeyboardArrowUpIcon sx={{ width: 16, height: 16 }} />
            : <KeyboardArrowDownIcon sx={{ width: 16, height: 16 }} />;
    };

    const handleSelectAll = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.checked) {
            setSelectedReceipts(receipts.map(receipt => receipt.id));
        } else {
            setSelectedReceipts([]);
        }
    };

    const handleSelectOne = (id: number) => {
        setSelectedReceipts(prev => {
            if (prev.includes(id)) {
                return prev.filter(receiptId => receiptId !== id);
            } else {
                return [...prev, id];
            }
        });
    };

    const handleBulkDelete = async () => {
        setShowBulkDeleteConfirm(false);
        setIsDeleting(true);
        try {
            const results = await Promise.all(
                selectedReceipts.map(id =>
                    fetch(`/api/receipts/${id}`, { method: 'DELETE' })
                    .then(response => ({ id, success: response.ok }))
                )
            );

            const failedDeletes = results.filter(r => !r.success).length;
            
            if (failedDeletes > 0) {
                setBulkActionStatus({
                    show: true,
                    message: `Failed to delete ${failedDeletes} receipts`,
                    type: 'error'
                });
            } else {
                setBulkActionStatus({
                    show: true,
                    message: 'Successfully deleted selected receipts',
                    type: 'success'
                });
            }
            
            // Clear selections and refresh list regardless of success
            setSelectedReceipts([]);
            await fetchReceipts();
            
        } catch (error) {
            console.error('Bulk delete error:', error);
            setBulkActionStatus({
                show: true,
                message: 'Error deleting receipts',
                type: 'error'
            });
            // Still refresh to ensure UI is in sync
            await fetchReceipts();
        } finally {
            setIsDeleting(false);
        }
    };

    return (
        <Container 
            maxWidth={false} 
            disableGutters 
            sx={{ 
                height: '100%',
                maxWidth: '100%',
                boxSizing: 'border-box',
                px: { xs: 2, sm: 3, md: 4 },
                py: { xs: 2, sm: 3 },
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
            }}
        >
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Receipt Organizer
            </Typography>

            <Box sx={{ 
                width: '100%',
                display: 'flex',
                flexDirection: 'column',
                gap: { xs: 2, sm: 4 }
            }}>
                <TableContainer component={Paper}>
                    <UploadArea 
                        onUpload={handleFileUpload} 
                        isUploading={isUploading}
                        error={uploadError}
                    />
                </TableContainer>

                {selectedReceipts.length > 0 && (
                    <Box sx={{ 
                        width: '100%',
                        p: 2,
                        bgcolor: 'primary.light', 
                        borderRadius: 1,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 2
                    }}>
                        <Typography sx={{ color: 'white' }}>
                            {selectedReceipts.length} items selected
                        </Typography>
                        <Button
                            variant="contained"
                            color="error"
                            onClick={() => setShowBulkDeleteConfirm(true)}
                            disabled={isDeleting}
                            size="small"
                        >
                            Delete Selected
                        </Button>
                    </Box>
                )}

                <TableContainer component={Paper} variant="outlined">
                    <Table size="small">
                        <TableHead>
                            <TableRow
                                sx={{
                                    bgcolor: 'grey.50',  // Light grey background
                                    '& th': {  // Target all header cells
                                        borderBottom: '2px solid',
                                        borderColor: 'grey.200',
                                        fontWeight: 600,
                                        color: 'grey.700'
                                    }
                                }}
                            >
                                <TableCell padding="checkbox">
                                    <Checkbox
                                        indeterminate={
                                            selectedReceipts.length > 0 && 
                                            selectedReceipts.length < receipts.length
                                        }
                                        checked={
                                            receipts.length > 0 && 
                                            selectedReceipts.length === receipts.length
                                        }
                                        onChange={handleSelectAll}
                                    />
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('vendor')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Vendor
                                        <SortIcon field="vendor" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('amount')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Amount
                                        <SortIcon field="amount" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('date')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Date
                                        <SortIcon field="date" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('payment_method')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Payment Method
                                        <SortIcon field="payment_method" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('category')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Category
                                        <SortIcon field="category" />
                                    </Box>
                                </TableCell>
                                <TableCell align="left">Actions</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {sortReceipts(receipts).map((receipt) => (
                                <TableRow 
                                    key={receipt.id} 
                                    hover
                                    onClick={() => setSelectedImage(receipt.image_path)}
                                    sx={{ 
                                        cursor: 'pointer',
                                        '&:hover': {
                                            bgcolor: 'action.hover',
                                        }
                                    }}
                                >
                                    <TableCell 
                                        padding="checkbox"
                                        onClick={(e) => e.stopPropagation()}
                                    >
                                        <Checkbox
                                            checked={selectedReceipts.includes(receipt.id)}
                                            onChange={() => handleSelectOne(receipt.id)}
                                        />
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.vendor}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.amount}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.date}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.payment_method}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.category}
                                    </TableCell>
                                    <TableCell 
                                        align="left"
                                        sx={{ 
                                            width: { xs: '140px', sm: '220px' },
                                            pr: { xs: 1, sm: 2 }
                                        }}
                                    >
                                        <Box 
                                            sx={{ 
                                                display: 'flex', 
                                                gap: { xs: 1, sm: 1.5 },
                                                justifyContent: 'flex-start'
                                            }}
                                            onClick={(e) => e.stopPropagation()}
                                        >
                                            <Tooltip title="View Receipt">
                                                <IconButton
                                                    size="small"
                                                    onClick={() => setSelectedImage(receipt.image_path)}
                                                    sx={{ 
                                                        color: 'text.secondary',
                                                        '&:hover': { color: '#2196f3' }
                                                    }}
                                                >
                                                    <VisibilityIcon sx={{ fontSize: 20 }} />
                                                </IconButton>
                                            </Tooltip>
                                            <Tooltip title="View Data">
                                                <IconButton
                                                    size="small"
                                                    onClick={() => setSelectedJson(receipt.content)}
                                                    sx={{ 
                                                        color: 'text.secondary',
                                                        '&:hover': { color: '#2196f3' }
                                                    }}
                                                >
                                                    <DataObjectIcon sx={{ fontSize: 20 }} />
                                                </IconButton>
                                            </Tooltip>
                                            <Tooltip title="Delete">
                                                <IconButton
                                                    size="small"
                                                    onClick={() => setDeleteConfirmOpen(receipt.id)}
                                                    sx={{ 
                                                        color: 'text.secondary',
                                                        '&:hover': { color: '#f44336' }
                                                    }}
                                                >
                                                    <DeleteIcon sx={{ fontSize: 20 }} />
                                                </IconButton>
                                            </Tooltip>
                                        </Box>
                                    </TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                </TableContainer>
            </Box>

            {selectedImage && (
                <ImageViewer
                    imagePath={selectedImage}
                    onClose={() => setSelectedImage(null)}
                />
            )}
            {selectedJson && (
                <JsonViewer
                    data={selectedJson}
                    onClose={() => setSelectedJson(null)}
                />
            )}

            <Dialog
                open={deleteConfirmOpen !== null}
                onClose={() => setDeleteConfirmOpen(null)}
            >
                <DialogTitle>
                    Confirm Delete
                </DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Are you sure you want to delete this receipt? This action cannot be undone.
                    </DialogContentText>
                </DialogContent>
                <DialogActions>
                    <Button
                        onClick={() => setDeleteConfirmOpen(null)}
                        color="inherit"
                    >
                        Cancel
                    </Button>
                    <Button
                        onClick={handleDeleteConfirm}
                        color="error"
                        variant="contained"
                        disabled={isDeleting}
                    >
                        {isDeleting ? 'Deleting...' : 'Delete'}
                    </Button>
                </DialogActions>
            </Dialog>

            <Dialog
                open={showBulkDeleteConfirm}
                onClose={() => setShowBulkDeleteConfirm(false)}
            >
                <DialogTitle>
                    Confirm Delete
                </DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Are you sure you want to delete {selectedReceipts.length} selected receipts? 
                        This action cannot be undone.
                    </DialogContentText>
                </DialogContent>
                <DialogActions>
                    <Button
                        onClick={() => setShowBulkDeleteConfirm(false)}
                        color="inherit"
                    >
                        Cancel
                    </Button>
                    <Button
                        onClick={handleBulkDelete}
                        color="error"
                        variant="contained"
                        disabled={isDeleting}
                    >
                        {isDeleting ? 'Deleting...' : 'Delete'}
                    </Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={bulkActionStatus.show}
                autoHideDuration={6000}
                onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
            >
                <Alert 
                    severity={bulkActionStatus.type}
                    onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
                >
                    {bulkActionStatus.message}
                </Alert>
            </Snackbar>
        </Container>
    );
};

export default ReceiptList;

================
File: frontend/components/ReceiptTable.tsx
================
import React from 'react';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    IconButton,
    Box,
    Tooltip
} from '@mui/material';
import VisibilityIcon from '@mui/icons-material/Visibility';
import DataObjectIcon from '@mui/icons-material/DataObject';
import DeleteIcon from '@mui/icons-material/Delete';
import { Receipt } from '@/types';

interface ReceiptTableProps {
    receipts: Receipt[];
    onViewImage: (imagePath: string) => void;
    onViewJson: (content: any) => void;
    onDelete: (id: number) => void;
}

export const ReceiptTable: React.FC<ReceiptTableProps> = ({
    receipts,
    onViewImage,
    onViewJson,
    onDelete
}) => {
    return (
        <TableContainer component={Paper}>
            <Table size="small">
                <TableHead>
                    <TableRow>
                        <TableCell>Vendor</TableCell>
                        <TableCell>Amount</TableCell>
                        <TableCell>Date</TableCell>
                        <TableCell>Payment Method</TableCell>
                        <TableCell>Category</TableCell>
                        <TableCell align="right">Actions</TableCell>
                    </TableRow>
                </TableHead>
                <TableBody>
                    {receipts.map((receipt) => (
                        <TableRow key={receipt.id}>
                            <TableCell>{receipt.vendor}</TableCell>
                            <TableCell>{receipt.amount}</TableCell>
                            <TableCell>{receipt.date}</TableCell>
                            <TableCell>{receipt.payment_method}</TableCell>
                            <TableCell>{receipt.category}</TableCell>
                            <TableCell align="right">
                                <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
                                    {receipt.image_path && (
                                        <Tooltip title="View Receipt">
                                            <IconButton
                                                size="small"
                                                onClick={() => onViewImage(receipt.image_path!)}
                                            >
                                                <VisibilityIcon fontSize="small" />
                                            </IconButton>
                                        </Tooltip>
                                    )}
                                    {receipt.content && (
                                        <Tooltip title="View Data">
                                            <IconButton
                                                size="small"
                                                onClick={() => onViewJson(receipt.content)}
                                            >
                                                <DataObjectIcon fontSize="small" />
                                            </IconButton>
                                        </Tooltip>
                                    )}
                                    <Tooltip title="Delete">
                                        <IconButton
                                            size="small"
                                            onClick={() => onDelete(receipt.id)}
                                        >
                                            <DeleteIcon fontSize="small" />
                                        </IconButton>
                                    </Tooltip>
                                </Box>
                            </TableCell>
                        </TableRow>
                    ))}
                </TableBody>
            </Table>
        </TableContainer>
    );
};

================
File: frontend/components/ReceiptUploader.tsx
================
import React, { useCallback, useState, useEffect } from 'react';
import { 
    Box, 
    Typography, 
    LinearProgress, 
    Button,
    styled
} from '@mui/material';
import UploadIcon from '@mui/icons-material/Upload';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import ErrorIcon from '@mui/icons-material/Error';
import { ReceiptTable } from './common';
import { ImageViewer } from './ImageViewer';
import { JsonViewer } from './JsonViewer';
import { Receipt } from '@/types';

const HiddenInput = styled('input')({
    display: 'none'
});

export const ReceiptUploader: React.FC = () => {
    const [isDragging, setIsDragging] = useState(false);
    const [uploadProgress, setUploadProgress] = useState(0);
    const [uploadStatus, setUploadStatus] = useState<'idle' | 'uploading' | 'success' | 'error'>('idle');
    const [fileName, setFileName] = useState("");
    const [receipts, setReceipts] = useState<Receipt[]>([]);
    const [selectedImage, setSelectedImage] = useState<string | null>(null);
    const [selectedJson, setSelectedJson] = useState<any | null>(null);
    const [uploadError, setUploadError] = useState<string | null>(null);
    const [deleteConfirmOpen, setDeleteConfirmOpen] = useState<number | null>(null);

    // Fetch receipts on component mount
    useEffect(() => {
        fetchReceipts();
    }, []);

    const fetchReceipts = async () => {
        try {
            const response = await fetch('/api/receipts');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            setReceipts(data);
        } catch (error) {
            console.error('Error fetching receipts:', error);
        }
    };

    const handleDragEnter = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    }, []);

    const handleDragLeave = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    }, []);

    const handleDragOver = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
    }, []);

    const validateFile = (file: File) => {
        const validTypes = ['image/jpeg', 'image/png'];
        if (!validTypes.includes(file.type)) {
            setUploadError('Only JPEG and PNG files are supported');
            setUploadStatus('error');
            return false;
        }
        return true;
    };

    const handleDrop = useCallback(async (e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
        
        const files = e.dataTransfer.files;
        if (files.length) {
            const file = files[0];
            if (validateFile(file)) {
                await handleUpload(file);
            }
        }
    }, []);

    const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file && validateFile(file)) {
            await handleUpload(file);
        }
    };

    const handleUpload = async (file: File) => {
        setFileName(file.name);
        setUploadStatus('uploading');
        setUploadProgress(0);
        setUploadError(null);

        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error(`Upload failed: ${response.statusText}`);
            }

            setUploadStatus('success');
            setUploadProgress(100);
            await fetchReceipts(); // Refresh the list after successful upload
        } catch (error) {
            console.error('Upload error:', error);
            setUploadStatus('error');
            setUploadError(error instanceof Error ? error.message : 'Upload failed');
        }
    };

    return (
        <>
            <Box
                sx={{
                    position: 'relative',
                    width: '100%',
                    height: '256px', // equivalent to h-64
                    borderRadius: 2,
                    border: '2px dashed',
                    borderColor: theme => {
                        if (uploadStatus === "success") return 'success.main';
                        if (uploadStatus === "error") return 'error.main';
                        return isDragging ? 'primary.main' : 'divider';
                    },
                    bgcolor: theme => {
                        if (uploadStatus === "success") return 'success.light';
                        if (uploadStatus === "error") return 'error.light';
                        return isDragging ? 'primary.light' : 'grey.50';
                    },
                    transition: 'all 0.2s ease-in-out',
                    cursor: 'pointer'
                }}
                onDragEnter={handleDragEnter}
                onDragOver={handleDragOver}
                onDragLeave={handleDragLeave}
                onDrop={handleDrop}
                role="button"
                tabIndex={0}
                aria-label="Upload receipt"
            >
                <Box
                    sx={{
                        position: 'absolute',
                        inset: 0,
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        justifyContent: 'center',
                        p: 3,
                        textAlign: 'center'
                    }}
                >
                    <Box sx={{ 
                        mb: 2,
                        color: theme => {
                            if (uploadStatus === "success") return 'success.main';
                            if (uploadStatus === "error") return 'error.main';
                            return isDragging ? 'primary.main' : 'text.secondary';
                        }
                    }}>
                        {uploadStatus === "success" ? <CheckCircleIcon sx={{ fontSize: 48 }} />
                            : uploadStatus === "error" ? <ErrorIcon sx={{ fontSize: 48 }} />
                            : <UploadIcon sx={{ fontSize: 48 }} />
                        }
                    </Box>

                    <Typography 
                        variant="h6" 
                        sx={{ mb: 1, color: 'text.primary' }}
                    >
                        {uploadStatus === "success" ? "Upload Complete!"
                            : uploadStatus === "error" ? "Upload Failed"
                            : "Drag and drop your receipt here"}
                    </Typography>

                    <Typography 
                        variant="body2" 
                        sx={{ mb: 2, color: 'text.secondary' }}
                    >
                        {uploadStatus === "error" ? uploadError
                            : "Or click to browse files (JPEG, PNG)"}
                    </Typography>

                    {uploadStatus === 'idle' && (
                        <label>
                            <HiddenInput
                                type="file"
                                accept="image/jpeg,image/png"
                                onChange={handleFileSelect}
                            />
                            <Button
                                variant="contained"
                                component="span"
                                startIcon={<UploadIcon />}
                            >
                                Browse Files
                            </Button>
                        </label>
                    )}
                </Box>
            </Box>

            {uploadStatus === 'uploading' && (
                <Box sx={{ mt: 2 }}>
                    <Box sx={{ 
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        mb: 1 
                    }}>
                        <Typography variant="body2" color="text.secondary">
                            {fileName}
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                            {uploadProgress}%
                        </Typography>
                    </Box>
                    <LinearProgress 
                        variant="determinate" 
                        value={uploadProgress}
                        sx={{ height: 8, borderRadius: 1 }}
                    />
                </Box>
            )}

            <Box sx={{ mt: 4 }}>
                <ReceiptTable 
                    receipts={receipts}
                    onViewImage={setSelectedImage}
                    onViewJson={setSelectedJson}
                    onDelete={setDeleteConfirmOpen}
                />
            </Box>

            {selectedImage && (
                <ImageViewer
                    imagePath={selectedImage}
                    onClose={() => setSelectedImage(null)}
                />
            )}
            
            {selectedJson && (
                <JsonViewer
                    data={selectedJson}
                    onClose={() => setSelectedJson(null)}
                />
            )}
        </>
    );
};

export default ReceiptUploader;

================
File: frontend/components/UploadArea.tsx
================
import React from 'react';
import { 
    Paper, 
    Box, 
    Typography, 
    Button, 
    LinearProgress, 
    Alert 
} from '@mui/material';
import UploadIcon from '@mui/icons-material/Upload';
import { useDropzone } from 'react-dropzone';

interface UploadAreaProps {
    onUpload: (file: File) => Promise<void>;
    isUploading: boolean;
    error?: string | null;
}

export const UploadArea: React.FC<UploadAreaProps> = ({ onUpload, isUploading, error }) => {
    const { getRootProps, getInputProps, isDragActive } = useDropzone({
        accept: {
            'image/jpeg': ['.jpg', '.jpeg'],
            'image/png': ['.png']
        },
        multiple: false,
        disabled: isUploading,
        onDrop: async (acceptedFiles) => {
            if (acceptedFiles?.[0]) {
                await onUpload(acceptedFiles[0]);
            }
        }
    });

    return (
        <Paper 
            {...getRootProps()}
            variant="outlined" 
            sx={{ 
                p: { xs: 1.5, sm: 2, md: 4 },
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: { xs: 1, sm: 2 },
                borderStyle: 'dashed',
                position: 'relative',
                cursor: 'pointer',
                borderColor: isDragActive ? 'primary.main' : 'divider',
                bgcolor: isDragActive ? 'action.hover' : 'background.paper',
                transition: 'all 0.2s ease',
                '&:hover': {
                    borderColor: 'primary.main',
                    bgcolor: 'action.hover'
                }
            }}
        >
            <input {...getInputProps()} />
            
            {isUploading && (
                <LinearProgress 
                    sx={{ 
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        borderTopLeftRadius: 'inherit',
                        borderTopRightRadius: 'inherit'
                    }}
                />
            )}
            
            <Box 
                sx={{ 
                    bgcolor: 'action.hover',
                    borderRadius: '50%',
                    p: { xs: 1.5, sm: 2 },
                    display: 'flex'
                }}
            >
                <UploadIcon />
            </Box>

            <Button
                variant="contained"
                component="span"
                startIcon={<UploadIcon />}
                disabled={isUploading}
                sx={{
                    width: { xs: '100%', sm: 'auto' },
                    minHeight: { xs: 40, sm: 36 },
                    fontSize: { xs: '0.8125rem', sm: '0.875rem' }
                }}
            >
                {isUploading ? 'Uploading...' : 'Upload Receipt'}
            </Button>

            <Typography 
                variant="body2" 
                color="text.secondary"
                align="center"
                sx={{ 
                    fontSize: { xs: '0.75rem', sm: '0.875rem' }
                }}
            >
                {isDragActive 
                    ? 'Drop the receipt here...'
                    : isUploading 
                        ? 'Processing your receipt...' 
                        : 'Supported formats: JPEG, PNG'
                }
            </Typography>

            {error && (
                <Alert 
                    severity="error" 
                    sx={{ 
                        width: '100%',
                        mt: { xs: 1, sm: 2 }
                    }}
                >
                    {error}
                </Alert>
            )}
        </Paper>
    );
};

================
File: frontend/config/index.ts
================
export const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3456';

export const CONFIG = {
    API: {
        BASE_URL: API_BASE_URL,
        TIMEOUT: parseInt(process.env.NEXT_PUBLIC_API_TIMEOUT || '120000', 10)
    }
} as const;

================
File: frontend/contexts/AppContext.tsx
================
import React, { createContext, useContext } from 'react';
import { useSearch } from '../hooks/useSearch';
import { useDocumentManagement } from '../hooks/useDocumentManagement';
import { Receipt } from '@/types';

interface AppContextType {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  documents: {
    uploadReceipt: (file: File) => Promise<Receipt>;
    getReceipts: () => Promise<Receipt[]>;
    deleteReceipt: (id: number) => Promise<void>;
    fetchReceipt: (id: string | string[]) => Promise<Receipt>;
  };
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AppContextProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const search = useSearch();
  const documents = useDocumentManagement();

  const value = {
    ...search,
    documents
  };

  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useAppContext must be used within an AppContextProvider');
  }
  return context;
};

================
File: frontend/contexts/index.ts
================
export * from './SearchContext';

================
File: frontend/contexts/SearchContext.tsx
================
import React, { createContext, useContext, useState } from 'react';

interface SearchContextType {
    searchQuery: string;
    setSearchQuery: (query: string) => void;
}

const SearchContext = createContext<SearchContextType | undefined>(undefined);

export const SearchProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [searchQuery, setSearchQuery] = useState('');

    return (
        <SearchContext.Provider value={{ searchQuery, setSearchQuery }}>
            {children}
        </SearchContext.Provider>
    );
};

export const useSearch = () => {
    const context = useContext(SearchContext);
    if (context === undefined) {
        throw new Error('useSearch must be used within a SearchProvider');
    }
    return context;
};

================
File: frontend/hooks/useDocumentManagement.ts
================
import { useCallback } from 'react';
import { documentsApi } from '../lib/api/documents';
import { Receipt } from '@/types';

interface DocumentManagement {
  uploadReceipt: (file: File) => Promise<Receipt>;
  getReceipts: () => Promise<Receipt[]>;
  deleteReceipt: (id: number) => Promise<void>;
  fetchReceipt: (id: string | string[]) => Promise<Receipt>;
}

export const useDocumentManagement = (): DocumentManagement => {
  const uploadReceipt = useCallback(async (file: File) => {
    const response = await documentsApi.uploadDocument(file, 'Expenses');
    return response as Receipt;
  }, []);

  const getReceipts = useCallback(async () => {
    const documents = await documentsApi.getDocuments('Expenses');
    return documents.map(doc => doc.originalReceipt as Receipt).filter(Boolean);
  }, []);

  const deleteReceipt = useCallback(async (id: number) => {
    try {
        await documentsApi.deleteDocument(id.toString());
    } catch (error) {
        console.error('Delete error:', error);
        throw new Error('Failed to delete receipt. Please try again.');
    }
  }, []);

  const fetchReceipt = useCallback(async (id: string | string[]) => {
    const receiptId = Array.isArray(id) ? id[0] : id;
    return documentsApi.fetchReceipt(receiptId);
  }, []);

  return {
    uploadReceipt,
    getReceipts,
    deleteReceipt,
    fetchReceipt
  };
};

================
File: frontend/hooks/useSearch.ts
================
import { useState, useCallback } from 'react';

export const useSearch = () => {
  const [searchQuery, setSearchQuery] = useState('');

  const handleSearch = useCallback((query: string) => {
    setSearchQuery(query);
  }, []);

  return {
    searchQuery,
    setSearchQuery: handleSearch
  };
};

================
File: frontend/lib/api/documents.ts
================
import { Document, DocumentType, Receipt } from '@/types';
import { API_BASE_URL } from '@/config';
import { format, parse, isValid } from 'date-fns';
import { enUS } from 'date-fns/locale';

// Mock data for testing (excluding Expenses)
const mockDocuments: Document[] = [
    {
        id: '1',
        type: 'W-2',
        employer: 'Tech Corp',
        wages: 85000,
        fedWithholding: 15000,
        status: 'pending',
        uploadDate: '2024-01-15'
    },
    {
        id: '2',
        type: '1099',
        employer: 'Freelance Inc',
        nonEmpCompensation: 25000,
        status: 'approved',
        uploadDate: '2024-02-01'
    },
    {
        id: '4',
        type: 'Donations',
        date: '2024-01-30',
        charityName: 'Local Food Bank',
        donationType: 'Cash',
        amount: 1000,
        status: 'approved',
        uploadDate: '2024-02-01'
    }
];

const transformDate = (dateStr: string): string => {
    if (!dateStr || dateStr === 'N/A' || dateStr.toLowerCase() === 'n/a') {
        console.log('documentsApi.transformDate: Empty or N/A date:', dateStr);
        return '';
    }
    
    console.log('documentsApi.transformDate: Processing date:', dateStr);
    
    try {
        // Clean up the date string first
        const cleanDate = dateStr.replace(/['"]/g, '').trim();
        if (!cleanDate) {
            console.log('documentsApi.transformDate: Empty date after cleanup');
            return '';
        }

        // Array of possible date formats to try
        const formats = [
            'MM/dd/yy',
            'MM/dd/yyyy',
            'dd MMM \'yy HH:mm a',
            'dd MMM yyyy HH:mm a',
            'yyyy-MM-dd',
            'MM-dd-yyyy',
            'dd-MM-yyyy',
            'dd MMM yyyy',
            'MMM dd yyyy',
            'dd/MM/yyyy',
            'dd/MM/yy'
        ];

        // Try each format
        for (const fmt of formats) {
            try {
                const date = parse(cleanDate, fmt, new Date(), { locale: enUS });
                if (isValid(date)) {
                    const result = format(date, 'yyyy-MM-dd', { locale: enUS });
                    console.log('documentsApi.transformDate: Successfully parsed date:', {
                        input: dateStr,
                        cleaned: cleanDate,
                        format: fmt,
                        result
                    });
                    return result;
                }
            } catch (e) {
                // Continue to next format if this one fails
                continue;
            }
        }
        
        console.warn('documentsApi.transformDate: Could not parse date with any format:', {
            original: dateStr,
            cleaned: cleanDate
        });
        return '';
    } catch (e) {
        console.error('documentsApi.transformDate: Error transforming date:', {
            error: e,
            input: dateStr
        });
        return '';
    }
};

export const documentsApi = {
    async getDocuments(type: DocumentType) {
        // For Expenses, use the existing receipts API
        if (type === 'Expenses') {
            const response = await fetch('/api/receipts');
            if (!response.ok) {
                throw new Error('Failed to fetch expenses');
            }
            const receipts = await response.json();
            console.log('documentsApi.getDocuments: Raw receipts from API:', receipts);
            
            // Transform receipt data to match Document interface
            return receipts.map((receipt: any) => {
                console.log('documentsApi.getDocuments: Processing receipt:', receipt);
                const transformed = {
                    id: receipt.id.toString(),
                    type: 'Expenses' as const,
                    vendor: receipt.vendor,
                    amount: receipt.amount,
                    date: transformDate(receipt.date),
                    payment_method: receipt.payment_method || 'Unknown',
                    expenseType: receipt.category || 'Uncategorized',
                    status: receipt.status || 'pending',
                    uploadDate: transformDate(receipt.date),
                    image_path: receipt.image_path,
                    content: receipt.content,
                    originalReceipt: receipt
                };
                console.log('documentsApi.getDocuments: Transformed receipt:', transformed);
                return transformed;
            });
        }

        // For other document types, use mock data
        await new Promise(resolve => setTimeout(resolve, 500));
        return mockDocuments.filter(doc => doc.type === type);
    },

    async uploadDocument(file: File, type: DocumentType) {
        // For Expenses, use the existing upload API
        if (type === 'Expenses') {
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to upload expense');
            }

            return await response.json();
        }

        // For other document types, use mock upload
        await new Promise(resolve => setTimeout(resolve, 1500));
        return { success: true };
    },

    async approveDocument(id: string, type: DocumentType) {
        // Mock approval for all document types for now
        await new Promise(resolve => setTimeout(resolve, 500));
        console.log(`Mocked approval for ${type} document ${id}`);
        return { success: true };
    },

    async deleteDocument(id: string) {
        try {
            // Use the correct API endpoint without the base URL since it's handled by Next.js
            const response = await fetch(`/api/receipts/${id}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
            });

            if (!response.ok) {
                throw new Error(`Failed to delete document: ${response.statusText}`);
            }

            return;
        } catch (error) {
            console.error('Error deleting document:', error);
            throw new Error('Failed to delete the selected items. Please try again.');
        }
    },

    async deleteDocuments(ids: string[]) {
        try {
            await Promise.all(
                ids.map(id => this.deleteDocument(id))
            );
        } catch (error) {
            console.error('Error deleting documents:', error);
            throw error;
        }
    }
};

export async function fetchReceipt(id: string): Promise<Receipt> {
  const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/receipts/${id}`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch receipt');
  }
  
  return response.json();
} 

export const updateDocument = async (
  receiptId: number,
  updates: Partial<Document>
): Promise<Document> => {
  const response = await fetch(`/api/receipts/${receiptId}/update`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(updates),
  });

  if (!response.ok) {
    const error = await response.json();
    console.error("Update failed:", error);
    throw new Error(error.message || `Failed to update document: ${error.details ? JSON.stringify(error.details) : 'Unknown error'}`);
  }

  const data = await response.json();
  return data.receipt;
};

================
File: frontend/lib/api.ts
================
import { CONFIG } from '@/config';

export const api = {
    async uploadReceipt(file: File) {
        const formData = new FormData();
        formData.append('file', file);

        const response = await fetch('/api/upload', {
            method: 'POST',
            body: formData,
            signal: AbortSignal.timeout(CONFIG.TIMEOUTS.UPLOAD)
        });

        if (!response.ok) {
            throw new Error(`Upload failed: ${response.statusText}`);
        }

        return response.json();
    },

    async getReceipts() {
        const response = await fetch('/api/receipts');
        if (!response.ok) {
            throw new Error(`Failed to fetch receipts: ${response.statusText}`);
        }
        return response.json();
    },

    async deleteReceipt(id: number) {
        const response = await fetch(`/api/receipts/${id}`, {
            method: 'DELETE'
        });
        if (!response.ok) {
            throw new Error(`Failed to delete receipt: ${response.statusText}`);
        }
        return response.json();
    },

    async fetchReceipt(id: string) {
        const response = await fetch(`/api/receipts/${id}`);
        
        if (!response.ok) {
            throw new Error('Failed to fetch receipt');
        }
        
        return response.json();
    }
};

================
File: frontend/lib/createEmotionCache.ts
================
import createCache from '@emotion/cache';

export default function createEmotionCache() {
  return createCache({ key: 'css', prepend: true });
}

================
File: frontend/pages/receipt/[id].tsx
================
import { useRouter } from 'next/router';
import ReceiptDetail from '../../components/ReceiptDetail';
import { Box } from '@mui/material';
import LoadingSpinner from '../../components/common/LoadingSpinner';

export default function ReceiptPage() {
  const router = useRouter();
  
  // Wait for the router to be ready and have query parameters
  if (!router.isReady) {
    return <LoadingSpinner />;
  }

  const { id } = router.query;

  return (
    <Box sx={{ p: 3 }}>
      <ReceiptDetail receiptId={id} />
    </Box>
  );
}

================
File: frontend/pages/_app.tsx
================
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import type { AppProps } from 'next/app';
import { ErrorBoundary } from '../components/ErrorBoundary';
import { Layout } from '../components/Layout/Layout';
import { theme } from '../styles/theme';
import { CacheProvider } from '@emotion/react';
import createEmotionCache from '../lib/createEmotionCache';
import { SearchProvider } from '../contexts/SearchContext';
import { AppContextProvider } from '../contexts/AppContext';

function MyApp({ Component, pageProps }: AppProps) {
    const clientSideEmotionCache = createEmotionCache();

    return (
        <CacheProvider value={clientSideEmotionCache}>
            <ThemeProvider theme={theme}>
                <SearchProvider>
                    <AppContextProvider>
                        <ErrorBoundary>
                            <Layout>
                                <Component {...pageProps} />
                            </Layout>
                        </ErrorBoundary>
                    </AppContextProvider>
                </SearchProvider>
            </ThemeProvider>
        </CacheProvider>
    );
}

export default MyApp;

================
File: frontend/pages/1040.tsx
================
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';

const Form1040Page: React.FC = () => {
    return (
        <Box sx={{ 
            height: '100%',
            width: '100%',
            position: 'absolute',
            top: 0,
            left: 0,
            overflow: 'auto',
            px: { xs: 2, sm: 3, md: 4 },
            py: { xs: 2, sm: 3 },
        }}>
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Form 1040
            </Typography>
            <Paper sx={{ p: 4 }}>
                <Typography>
                    Your Form 1040 preparation area. This feature is coming soon.
                </Typography>
            </Paper>
        </Box>
    );
};

export default Form1040Page;

================
File: frontend/pages/dashboard.tsx
================
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';

const DashboardPage: React.FC = () => {
    return (
        <Box sx={{ 
            height: '100%',
            width: '100%',
            position: 'absolute',
            top: 0,
            left: 0,
            overflow: 'auto',
            px: { xs: 2, sm: 3, md: 4 },
            py: { xs: 2, sm: 3 },
        }}>
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Dashboard
            </Typography>
            <Paper sx={{ p: 4 }}>
                <Typography>
                    Welcome to your tax dashboard. This feature is coming soon.
                </Typography>
            </Paper>
        </Box>
    );
};

export default DashboardPage;

================
File: frontend/pages/documents.tsx
================
import React, { useState } from 'react';
import { Box, Container } from '@mui/material';
import { DocumentsTabs } from '@/components/Documents/DocumentsTabs';
import { DocumentsTable } from '@/components/Documents/DocumentsTable';
import { DocumentUploadArea } from '@/components/Documents/DocumentUploadArea';
import { DocumentUploadFab } from '@/components/Documents/DocumentUploadFab';
import { DocumentType } from '@/types';
import { DocumentFilter } from '@/types/filters';

const DocumentsPage: React.FC = () => {
    const [activeTab, setActiveTab] = useState<DocumentType>('W-2');
    const [refreshTrigger, setRefreshTrigger] = useState(0);
    
    // Persistent filters for each document type
    const [filters, setFilters] = useState<Record<DocumentType, DocumentFilter>>({
        'W-2': {},
        '1099': {},
        'Expenses': {},
        'Donations': {}
    });

    const handleTabChange = (tab: DocumentType) => {
        setActiveTab(tab);
    };

    const handleFilterChange = (newFilters: DocumentFilter) => {
        setFilters(prev => ({
            ...prev,
            [activeTab]: newFilters
        }));
    };

    const handleUploadComplete = () => {
        setRefreshTrigger(prev => prev + 1);
    };

    return (
        <Box 
            sx={{ 
                height: '100%',
                width: '100%',
                position: 'absolute',
                top: 0,
                left: 0,
                overflow: 'auto'
            }}
        >
            <Container maxWidth={false} sx={{ py: 3 }}>
                <DocumentsTabs 
                    activeTab={activeTab}
                    onTabChange={handleTabChange}
                />

                <DocumentUploadArea 
                    activeTab={activeTab}
                    onUploadComplete={handleUploadComplete}
                />

                <DocumentsTable 
                    type={activeTab}
                    filters={filters[activeTab]}
                    onFilterChange={handleFilterChange}
                    key={refreshTrigger}
                />

                <DocumentUploadFab />
            </Container>
        </Box>
    );
};

export default DocumentsPage;

================
File: frontend/pages/index.tsx
================
import { useEffect } from 'react';
import { useRouter } from 'next/router';

export default function HomePage() {
    const router = useRouter();

    useEffect(() => {
        router.replace('/dashboard');
    }, [router]);

    return null;
}

================
File: frontend/pages/profile.tsx
================
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';

const ProfilePage: React.FC = () => {
    return (
        <Box sx={{ 
            height: '100%',
            width: '100%',
            position: 'absolute',
            top: 0,
            left: 0,
            overflow: 'auto',
            px: { xs: 2, sm: 3, md: 4 },
            py: { xs: 2, sm: 3 },
        }}>
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Profile
            </Typography>
            <Paper sx={{ p: 4 }}>
                <Typography>
                    Your profile settings and preferences. This feature is coming soon.
                </Typography>
            </Paper>
        </Box>
    );
};

export default ProfilePage;

================
File: frontend/styles/globals.css
================
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
}

================
File: frontend/styles/theme.ts
================
import { createTheme } from '@mui/material/styles';

export const theme = createTheme({
  typography: {
    fontFamily: 'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: {
        '@keyframes fadeIn': {
          from: { opacity: 0 },
          to: { opacity: 1 },
        },
        '@keyframes slideIn': {
          from: {
            transform: 'translateY(20px)',
            opacity: 0,
          },
          to: {
            transform: 'translateY(0)',
            opacity: 1,
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          transition: 'all 0.2s ease-in-out',
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: 8,
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        root: {
          padding: '12px 16px',
        },
        head: {
          fontWeight: 600,
          backgroundColor: 'rgba(0, 0, 0, 0.02)',
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: '#ffffff',
          color: 'inherit',
          borderRadius: 0,
        }
      }
    },
    MuiToolbar: {
      styleOverrides: {
        root: {
          borderRadius: 0,
          '@media (min-width: 600px)': {
            minHeight: '64px',
            padding: '0 24px',
          },
          '@media (max-width: 599px)': {
            minHeight: '48px',
            padding: '0 16px',
          }
        }
      }
    }
  },
  palette: {
    background: {
      default: '#f8f9fa',
    },
    text: {
      primary: 'rgba(0, 0, 0, 0.87)',
      secondary: 'rgba(0, 0, 0, 0.6)',
    },
  },
});

================
File: frontend/types/documents.ts
================
export type DocumentType = 'W-2' | '1099' | 'Expenses' | 'Donations';
export type DocumentStatus = 'all' | 'pending' | 'approved';

interface BaseDocument {
    id: string;
    type: DocumentType;
    status: Exclude<DocumentStatus, 'all'>;
    uploadDate: string;
}

export interface W2Document extends BaseDocument {
    type: 'W-2';
    employer: string;
    wages: number;
    fedWithholding: number;
}

export interface Form1099Document extends BaseDocument {
    type: '1099';
    employer: string;
    nonEmpCompensation: number;
}

export interface ExpenseDocument extends BaseDocument {
    type: 'Expenses';
    vendor: string;
    amount: number;
    date: string;
    payment_method: string;
    expenseType: string;
    originalReceipt?: {
        image_path: string;
        [key: string]: any;
    };
}

export interface DonationDocument extends BaseDocument {
    type: 'Donations';
    date: string;
    charityName: string;
    donationType: string;
    amount: number;
}

export type Document = W2Document | Form1099Document | ExpenseDocument | DonationDocument;

================
File: frontend/types/filters.ts
================
import { DocumentType } from './index';

export interface BaseFilter {
  type: DocumentType;
  status?: string[];
  dateRange?: {
    start: string;
    end: string;
  };
}

export interface W2Filter extends BaseFilter {
  type: 'W-2';
  employer?: string[];
  wageRange?: {
    min: number;
    max: number;
  };
}

export interface Form1099Filter extends BaseFilter {
  type: '1099';
  employer?: string[];
  amountRange?: {
    min: number;
    max: number;
  };
}

export interface ExpenseFilter extends BaseFilter {
  type: 'Expenses';
  vendor?: string[];
  amountRange?: {
    min: number;
    max: number;
  };
  paymentMethod?: string[];
  expenseType?: string[];
}

export interface DonationFilter extends BaseFilter {
  type: 'Donations';
  charityName?: string[];
  amountRange?: {
    min: number;
    max: number;
  };
  donationType?: string[];
}

export type DocumentFilter = W2Filter | Form1099Filter | ExpenseFilter | DonationFilter;

================
File: frontend/types/index.ts
================
// Document Types
export type DocumentType = 'W-2' | '1099' | 'Expenses' | 'Donations';
export type DocumentStatus = 'pending' | 'processed' | 'error';

// Receipt Types
export interface ReceiptItem {
    name: string;
    price: number;
    quantity: number;
}

export interface Receipt {
    id: number;
    date: string;
    totalAmount: number;
    vendor: string;
    category: string;
    imageUrl?: string;
    image_path?: string;
    items?: Array<{
        description: string;
        amount: number;
    }>;
    content?: any;
    payment_method?: string;
    amount?: string | number;
    replace?: never;
}

// Document Interfaces
export interface BaseDocument {
    id: number;
    type: DocumentType;
    status: DocumentStatus;
    uploadDate: string;
}

export interface W2Document extends BaseDocument {
    type: 'W-2';
    employer: string;
    wages: number;
    fedWithholding: number;
}

export interface Form1099Document extends BaseDocument {
    type: '1099';
    employer: string;
    nonEmpCompensation: number;
}

export interface ExpenseDocument extends BaseDocument {
    type: 'Expenses';
    vendor: string;
    amount: number;
    date: string;
    payment_method: string;
    expenseType: string;
}

export interface DonationDocument extends BaseDocument {
    type: 'Donations';
    charityName: string;
    amount: number;
    donationType: string;
    date: string;
}

export type Document = W2Document | Form1099Document | ExpenseDocument | DonationDocument;

// Search Types
export interface SearchResult {
    id: string;
    type: string;
    name: string;
    group: string;
}

================
File: frontend/.env.development
================
NEXT_PUBLIC_API_URL=http://localhost:3456
NEXT_PUBLIC_API_TIMEOUT=120000
NODE_OPTIONS=--max-http-header-size=81920

================
File: frontend/.eslintrc.js
================
module.exports = {
  extends: [
    'next/core-web-vitals',
    'plugin:@typescript-eslint/recommended',
    'prettier'
  ],
  rules: {
    '@typescript-eslint/no-unused-vars': ['error'],
    '@typescript-eslint/no-explicit-any': ['warn'],
    'react/prop-types': 'off'
  }
};

================
File: frontend/.gitignore
================
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: frontend/config.ts
================
export const CONFIG = {
    TIMEOUTS: {
        UPLOAD: 120000,  // 2 minutes in milliseconds
        SERVER: 120000,
        PROXY: 120000
    }
} as const;

================
File: frontend/next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,
    async rewrites() {
        return [
            {
                source: '/api/:path*',
                destination: 'http://localhost:3456/api/:path*',
            }
        ];
    },
    api: {
        bodyParser: {
            sizeLimit: '16mb',
        },
        responseLimit: '16mb',
    },
    httpAgentOptions: {
        keepAlive: true,
        timeout: 120000, // 120 seconds to match Flask's timeout
    },
};

module.exports = nextConfig;

================
File: frontend/package.json
================
{
  "name": "receipt-scanner-frontend",
  "version": "1.0.0",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@emotion/cache": "^11.14.0",
    "@emotion/react": "^11.11.3",
    "@emotion/server": "^11.11.0",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.16.11",
    "@mui/material": "^5.x.x",
    "@mui/x-date-pickers": "^6.18.6",
    "date-fns": "^2.30.0",
    "next": "^14.x.x",
    "react": "^18.x.x",
    "react-dom": "^18.x.x",
    "react-dropzone": "^14.2.3"
  },
  "devDependencies": {
    "@types/node": "^20.10.6",
    "@types/react": "^18.2.46",
    "@types/react-dom": "^18.2.18",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.0.0",
    "eslint-config-next": "^14.0.4",
    "typescript": "^5.3.3"
  }
}

================
File: frontend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"],
      "@components/*": ["components/*"],
      "@styles/*": ["styles/*"],
      "@types/*": ["types/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}

================
File: .gitignore
================
# Python virtual environments
venv/
.venv/
__pycache__/
*.pyc
*.py[cod]
*$py.class
*.so
.Python
ENV/
.env
.env.local
.env.*.local

# Development
.pytest_cache/
.coverage
htmlcov/
.mypy_cache/

# Database
*.db
*.sqlite3

# Uploads and media
uploads/
media/

# IDE
.vscode/
.idea/
*.swp
*.swo

# Node.js dependencies
node_modules/
.next/
out/
build/
.DS_Store

# Logs
*.log
logs/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Local development
.local/

# Lock files
yarn.lock
package-lock.json

# Backend
backend/Receipts/

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  // Only enable image optimization if actually using next/image
  images: process.env.ENABLE_IMAGE_OPTIMIZATION === 'true' ? {
    domains: ['localhost'],
  } : {},
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'http://localhost:3456/api/:path*'
      }
    ]
  }
};

module.exports = nextConfig;

================
File: README.md
================
# Document Management System

## 1. Project Structure

```
├── frontend/
│   ├── components/
│   │   ├── Documents/              # Document management components
│   │   ├── GlobalHeader/           # Application header
│   │   ├── LeftNav/                # Navigation sidebar
│   │   ├── Layout/                 # Main layout wrapper
│   │   └── common/                 # Shared components
│   ├── contexts/                   # React contexts
│   ├── styles/                     # Global styles
│   ├── .env.development            # Environment variables for development
│   ├── .eslintrc.js                # ESLint configuration
│   └── .gitignore                  # Files to ignore in version control
├── backend/
│   ├── api/
│   │   └── routes.py               # API endpoints
│   ├── models/
│   │   └── database.py             # Database models
│   ├── services/
│   │   ├── ocr_service.py          # OCR processing
│   │   └── categorization.py       # Document categorization
│   ├── tests/                      # Test suites
│   │   ├── conftest.py             # Test configuration and fixtures
│   │   ├── test_api.py             # API endpoint tests
│   │   ├── test_migrations.py      # Database migration tests
│   │   └── test_receipt_updates.py # Receipt update tests
│   └── .env                        # Environment variables for backend
```

## 2. Technologies Used

### Frontend
- **Next.js 14**: React framework for server-side rendering and static site generation.
- **TypeScript**: Type safety and improved developer experience.
- **Material-UI v5**: UI component library for React.
- **React Context**: State management.
- **Axios**: HTTP client for making API requests.
- **react-dropzone**: File upload handling.

### Backend
- **Flask**: Lightweight Python web framework.
- **SQLAlchemy**: ORM for database interactions.
- **SQLite**: Simple, file-based database.
- **OpenAI GPT-4 Vision API**: OCR processing.
- **pytest**: Testing framework.
- **Pillow**: Image processing library.

## 3. Frontend-Backend Integration

- **Backend** runs on port 3456 (`http://localhost:3456`).
- **Frontend** is configured in `.env.development`:
  ```
  NEXT_PUBLIC_API_URL=http://localhost:3456
  NEXT_PUBLIC_API_TIMEOUT=120000
  ```
- **API calls** are handled through Axios client.
- **CORS** is enabled for development.

## 4. File Purposes and Functionality

### Frontend Key Files
- **`DocumentsTable.tsx`**: Displays and manages documents.
- **`DocumentFilters.tsx`**: Implements advanced document filtering.
- **`DocumentUploadArea.tsx`**: Handles document upload UI and logic.
- **`GlobalHeader.tsx`**: Application header with search functionality.
- **`LeftNav.tsx`**: Navigation sidebar component.

### Backend Key Files
- **`routes.py`**: API endpoint definitions and request handling.
- **`database.py`**: SQLAlchemy models and database configuration.
- **`ocr_service.py`**: OpenAI GPT-4 integration for document processing.
- **`test_receipt_updates.py`**: Tests for receipt update functionality.
- **`test_migrations.py`**: Database migration tests.

## 5. Database Schema (ERD)

```mermaid
erDiagram
    Receipt ||--o{ ReceiptChangeHistory : "tracks_changes"
    Receipt {
        int id PK
        string image_path
        string vendor
        string amount
        string date
        string payment_method
        string category
        json content
        string status
    }
    ReceiptChangeHistory {
        int id PK
        int receipt_id FK
        string field_name
        string new_value
        datetime changed_at
        string changed_by
    }
```

## 6. Architecture Diagram

```mermaid
graph TB
    subgraph Frontend
        NC[Next.js Client]
        RC[React Components]
        CTX[React Context]
    end
    
    subgraph Backend
        FA[Flask App]
        API[REST API]
        OCR[OCR Service]
    end
    
    subgraph External
        OAPI[OpenAI API]
        DB[(SQLite)]
    end
    
    NC --> RC
    RC --> API
    API --> FA
    FA --> OCR
    OCR --> OAPI
    FA --> DB
```

## 7. Technology Choices Rationale

- **Next.js**: Chosen for SSR capabilities and built-in routing.
- **Flask**: Selected for its lightweight nature and microservices compatibility.
- **SQLite**: Zero configuration and easy maintenance.
- **Material-UI**: Comprehensive component library with enterprise features.
- **React Context**: Preferred over Redux for simpler state management.

## 8. React Context Structure

```typescript
interface SearchContextType {
    searchQuery: string;
    setSearchQuery: (query: string) => void;
}
```

Purpose:
- Manages global search functionality.
- Used by GlobalHeader for search input.
- Filters DocumentsTable results.
- Provides real-time search capabilities.

## 9. Styling Guidelines

```typescript
export const theme = createTheme({
    palette: {
        primary: {
            main: '#1976d2',
            light: '#42a5f5',
            dark: '#1565c0'
        }
    },
    typography: {
        fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
        h1: { fontSize: '2.5rem', fontWeight: 500 }
    }
});
```

## 10. Backend API Endpoints

```python
@api_bp.route('/api/receipts', methods=['GET'])
@api_bp.route('/api/receipts/<int:receipt_id>', methods=['GET'])
@api_bp.route('/api/upload', methods=['POST'])
@api_bp.route('/api/receipts/<int:receipt_id>', methods=['PATCH'])
@api_bp.route('/api/receipts/<int:receipt_id>', methods=['DELETE'])
```

## 11. Testing

### Test Structure

```
backend/tests/
├── conftest.py          # Test configuration and fixtures
├── test_api.py          # API endpoint tests
├── test_migrations.py   # Database migration tests
└── test_receipt_updates.py  # Receipt update tests
```

### Running Tests

```bash
# Run all tests
python -m pytest

# Run with coverage
python -m pytest --cov=backend

# Run specific test file
python -m pytest backend/tests/test_api.py
```

### Test Categories

- **Unit Tests**: Individual component testing.
- **Integration Tests**: End-to-end functionality.
- **Migration Tests**: Database schema verification.
- **API Tests**: Endpoint functionality verification.
