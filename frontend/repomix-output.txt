This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-26T07:00:04.611Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
components/
  common/
    DialogWrapper.tsx
    ErrorMessage.tsx
    index.ts
    LoadingSpinner.tsx
  Documents/
    DocumentFilters.tsx
    DocumentsFilters.tsx
    DocumentsTable.tsx
    DocumentsTabs.tsx
    DocumentUploadArea.tsx
    DocumentUploadFab.tsx
    EditableCell.tsx
    ExpenseFilters.tsx
  GlobalHeader/
    GlobalHeader.tsx
  Layout/
    Layout.tsx
  LeftNav/
    LeftNav.tsx
  ErrorBoundary.tsx
  ImageViewer.tsx
  JsonViewer.tsx
  ReceiptDetail.tsx
  ReceiptList.tsx
  ReceiptTable.tsx
  ReceiptUploader.tsx
  UploadArea.tsx
config/
  index.ts
contexts/
  AppContext.tsx
  index.ts
  SearchContext.tsx
hooks/
  useDocumentManagement.ts
  useSearch.ts
lib/
  api/
    documents.ts
  api.ts
  createEmotionCache.ts
pages/
  receipt/
    [id].tsx
  _app.tsx
  1040.tsx
  dashboard.tsx
  documents.tsx
  index.tsx
  profile.tsx
styles/
  globals.css
  theme.ts
types/
  documents.ts
  filters.ts
  index.ts
.env.development
.eslintrc.js
.gitignore
config.ts
next.config.js
package.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: components/common/DialogWrapper.tsx
================
import { Dialog, DialogTitle, DialogContent, IconButton } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';

interface DialogWrapperProps {
    title: string;
    open: boolean;
    onClose: () => void;
    children: React.ReactNode;
}

export const DialogWrapper = ({ title, open, onClose, children }: DialogWrapperProps) => (
    <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
        <DialogTitle sx={{ m: 0, p: 2, display: 'flex', justifyContent: 'space-between' }}>
            {title}
            <IconButton onClick={onClose}><CloseIcon /></IconButton>
        </DialogTitle>
        <DialogContent>
            {children}
        </DialogContent>
    </Dialog>
);

================
File: components/common/ErrorMessage.tsx
================
import { Alert, Box } from '@mui/material';

interface ErrorMessageProps {
  message: string;
}

export default function ErrorMessage({ message }: ErrorMessageProps) {
  return (
    <Box sx={{ my: 2 }}>
      <Alert severity="error">{message}</Alert>
    </Box>
  );
}

================
File: components/common/index.ts
================
export * from './ErrorMessage';
export * from './LoadingSpinner';
export * from './DialogWrapper';
export * from '../ReceiptTable';

================
File: components/common/LoadingSpinner.tsx
================
import { Box, CircularProgress, type SxProps } from '@mui/material';

interface LoadingSpinnerProps {
  minHeight?: string | number;
  sx?: SxProps;
}

export default function LoadingSpinner({ minHeight = '200px', sx }: LoadingSpinnerProps) {
  return (
    <Box
      display="flex"
      justifyContent="center"
      alignItems="center"
      minHeight={minHeight}
      sx={sx}
    >
      <CircularProgress />
    </Box>
  );
}

================
File: components/Documents/DocumentFilters.tsx
================
import React, { useState, useEffect } from 'react';
import {
    Box,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    Typography,
    TextField,
    Select,
    MenuItem,
    FormControl,
    InputLabel,
    Chip,
    Button,
    Menu,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import TuneIcon from '@mui/icons-material/Tune';
import RestartAltIcon from '@mui/icons-material/RestartAlt';
import { DocumentType } from '@/types';
import { DocumentFilter } from '@/types/filters';

interface FilterField {
    type: 'number-range' | 'date-range' | 'multi-select';
    label: string;
    field: string;
    options?: string[]; // For multi-select
}

interface FilterOptions {
    categories: string[];
    payment_methods: string[];
    statuses: string[];
    vendors: string[];
}

const FILTER_CONFIG: Record<DocumentType, FilterField[]> = {
    'W-2': [
        { type: 'multi-select', label: 'Employer', field: 'employer' },
        { type: 'number-range', label: 'Wages', field: 'wageRange' },
        { type: 'number-range', label: 'Withholding', field: 'withHoldingRange' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ],
    '1099': [
        { type: 'multi-select', label: 'Employer', field: 'employer' },
        { type: 'number-range', label: 'Amount', field: 'amountRange' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ],
    'Expenses': [
        { type: 'multi-select', label: 'Vendor', field: 'vendor' },
        { type: 'number-range', label: 'Amount', field: 'amountRange' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Payment Method', field: 'paymentMethod' },
        { type: 'multi-select', label: 'Expense Type', field: 'category' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ],
    'Donations': [
        { type: 'multi-select', label: 'Charity', field: 'charityName' },
        { type: 'number-range', label: 'Amount', field: 'amountRange' },
        { type: 'multi-select', label: 'Type', field: 'donationType' },
        { type: 'date-range', label: 'Date', field: 'dateRange' },
        { type: 'multi-select', label: 'Status', field: 'status' }
    ]
};

interface DocumentFiltersProps {
    type: DocumentType;
    filters: DocumentFilter;
    onFilterChange: (filters: DocumentFilter) => void;
    variant?: 'default' | 'toolbar';
    availableOptions?: Record<string, string[]>;
}

export const DocumentFilters: React.FC<DocumentFiltersProps> = ({
    type,
    filters,
    onFilterChange,
    variant = 'default',
    availableOptions = {}
}) => {
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const [filterOptions, setFilterOptions] = useState<FilterOptions>({
        categories: [],
        payment_methods: [],
        statuses: [],
        vendors: []
    });

    useEffect(() => {
        // Fetch filter options from the backend
        const fetchOptions = async () => {
            try {
                const response = await fetch('/api/options');
                if (!response.ok) {
                    throw new Error('Failed to fetch options');
                }
                const data = await response.json();
                setFilterOptions(data);
            } catch (error) {
                console.error('Error fetching filter options:', error);
            }
        };

        fetchOptions();
    }, []);

    const getOptionsForField = (field: string): string[] => {
        if (!availableOptions) return [];
        
        switch (field) {
            case 'category':
                return availableOptions.categories || [];
            case 'paymentMethod':
                return availableOptions.payment_methods || [];
            case 'status':
                return availableOptions.statuses || [];
            case 'vendor':
                return availableOptions.vendors || [];
            default:
                return [];
        }
    };

    const handleNumberRangeChange = (field: string, bound: 'min' | 'max', value: string) => {
        const numValue = value ? Number(value) : undefined;
        onFilterChange({
            ...filters,
            [field]: {
                ...(filters[field as keyof DocumentFilter] as any || {}),
                [bound]: numValue
            }
        });
    };

    const handleDateRangeChange = (field: string, bound: 'start' | 'end', value: string) => {
        onFilterChange({
            ...filters,
            [field]: {
                ...(filters[field as keyof DocumentFilter] as any || {}),
                [bound]: value || undefined
            }
        });
    };

    const handleMultiSelectChange = (field: string, values: string[]) => {
        onFilterChange({
            ...filters,
            [field]: values
        });
    };

    const handleRemoveFilter = (field: keyof DocumentFilter, value?: string) => {
        const newFilters = { ...filters };
        
        if (value && Array.isArray(newFilters[field])) {
            const currentValues = newFilters[field] as string[];
            newFilters[field] = currentValues.filter(v => v !== value) as any;
            if ((newFilters[field] as string[]).length === 0) {
                delete newFilters[field];
            }
        } else {
            delete newFilters[field];
        }
        onFilterChange(newFilters);
    };

    const handleResetFilters = () => {
        onFilterChange({});
    };

    const renderActiveFilters = () => {
        return (
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>
                {FILTER_CONFIG[type].map(field => {
                    const value = filters[field.field as keyof DocumentFilter];
                    if (!value) return null;

                    switch (field.type) {
                        case 'multi-select':
                            return (Array.isArray(value) ? value : []).map(v => (
                                <Chip
                                    key={`${field.field}-${v}`}
                                    label={`${field.label}: ${v}`}
                                    onDelete={() => handleRemoveFilter(field.field as keyof DocumentFilter, v)}
                                    size="small"
                                />
                            ));
                        case 'number-range': {
                            const range = value as { min?: number; max?: number };
                            if (!range.min && !range.max) return null;
                            return (
                                <Chip
                                    key={field.field}
                                    label={`${field.label}: ${range.min || '0'} - ${range.max || '∞'}`}
                                    onDelete={() => handleRemoveFilter(field.field as keyof DocumentFilter)}
                                    size="small"
                                />
                            );
                        }
                        case 'date-range': {
                            const dates = value as { start?: string; end?: string };
                            if (!dates.start && !dates.end) return null;
                            return (
                                <Chip
                                    key={field.field}
                                    label={`${field.label}: ${dates.start || '∞'} - ${dates.end || '∞'}`}
                                    onDelete={() => handleRemoveFilter(field.field as keyof DocumentFilter)}
                                    size="small"
                                />
                            );
                        }
                        default:
                            return null;
                    }
                })}
            </Box>
        );
    };

    const renderFilterField = (field: FilterField) => {
        const filterValue = filters[field.field as keyof DocumentFilter];

        switch (field.type) {
            case 'number-range': {
                const range = filterValue as { min?: number; max?: number } || {};
                return (
                    <Box sx={{ display: 'flex', gap: 2 }}>
                        <TextField
                            label={`Min ${field.label}`}
                            type="number"
                            size="small"
                            value={range.min || ''}
                            onChange={(e) => handleNumberRangeChange(field.field, 'min', e.target.value)}
                        />
                        <TextField
                            label={`Max ${field.label}`}
                            type="number"
                            size="small"
                            value={range.max || ''}
                            onChange={(e) => handleNumberRangeChange(field.field, 'max', e.target.value)}
                        />
                    </Box>
                );
            }

            case 'date-range': {
                const dates = filterValue as { start?: string; end?: string } || {};
                return (
                    <Box sx={{ display: 'flex', gap: 2 }}>
                        <TextField
                            label="Start Date"
                            type="date"
                            size="small"
                            InputLabelProps={{ shrink: true }}
                            value={dates.start || ''}
                            onChange={(e) => handleDateRangeChange(field.field, 'start', e.target.value)}
                        />
                        <TextField
                            label="End Date"
                            type="date"
                            size="small"
                            InputLabelProps={{ shrink: true }}
                            value={dates.end || ''}
                            onChange={(e) => handleDateRangeChange(field.field, 'end', e.target.value)}
                        />
                    </Box>
                );
            }

            case 'multi-select':
                return (
                    <FormControl size="small" sx={{ minWidth: 200 }}>
                        <InputLabel>{field.label}</InputLabel>
                        <Select
                            multiple
                            value={(filterValue as string[]) || []}
                            onChange={(e) => handleMultiSelectChange(field.field, e.target.value as string[])}
                            label={field.label}
                        >
                            {getOptionsForField(field.field).map((option) => (
                                <MenuItem key={option} value={option}>
                                    {option}
                                </MenuItem>
                            ))}
                        </Select>
                    </FormControl>
                );
        }
    };

    if (variant === 'toolbar') {
        return (
            <>
                <Button
                    startIcon={<TuneIcon />}
                    onClick={(e) => setAnchorEl(e.currentTarget)}
                    variant="outlined"
                    size="small"
                    endIcon={Object.keys(filters).length > 0 && 
                        <Chip 
                            label={Object.keys(filters).length} 
                            size="small" 
                            color="primary"
                        />
                    }
                >
                    Filters
                </Button>
                <Menu
                    anchorEl={anchorEl}
                    open={Boolean(anchorEl)}
                    onClose={() => setAnchorEl(null)}
                    PaperProps={{
                        sx: { width: 400, maxHeight: '80vh' }
                    }}
                >
                    <Box sx={{ p: 2 }}>
                        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                            {FILTER_CONFIG[type].map(field => (
                                <Box key={field.field}>
                                    {renderFilterField(field)}
                                </Box>
                            ))}
                        </Box>
                        {renderActiveFilters()}
                    </Box>
                </Menu>
            </>
        );
    }

    return (
        <Box sx={{ mb: 2 }}>
            <Accordion>
                <AccordionSummary
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                        bgcolor: 'background.default',
                        '&:hover': { bgcolor: 'action.hover' }
                    }}
                >
                    <Box sx={{ 
                        display: 'flex', 
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        width: '100%',
                        pr: 2
                    }}>
                        <Box sx={{ 
                            display: 'flex', 
                            alignItems: 'center', 
                            gap: 1 
                        }}>
                            <TuneIcon />
                            <Typography>Filters</Typography>
                        </Box>
                        
                        {Object.keys(filters).length > 0 && (
                            <Button
                                size="small"
                                startIcon={<RestartAltIcon />}
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleResetFilters();
                                }}
                                sx={{ ml: 2 }}
                            >
                                Reset Filters
                            </Button>
                        )}
                    </Box>
                </AccordionSummary>
                <AccordionDetails>
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                        {FILTER_CONFIG[type].map(field => (
                            <Box key={field.field}>
                                {renderFilterField(field)}
                            </Box>
                        ))}
                    </Box>
                </AccordionDetails>
            </Accordion>
            {renderActiveFilters()}
        </Box>
    );
};

================
File: components/Documents/DocumentsFilters.tsx
================
import React from 'react';
import { 
    Box, 
    TextField, 
    Select, 
    MenuItem, 
    Button,
    InputLabel,
    FormControl,
    SelectChangeEvent,
} from '@mui/material';
import { DocumentStatus } from '@/types';

interface DocumentsFiltersProps {
    statusFilter: DocumentStatus;
    searchQuery: string;
    onStatusChange: (status: DocumentStatus) => void;
    onSearchChange: (query: string) => void;
    onReset: () => void;
}

export const DocumentsFilters: React.FC<DocumentsFiltersProps> = ({
    statusFilter,
    searchQuery,
    onStatusChange,
    onSearchChange,
    onReset,
}) => {
    const handleStatusChange = (event: SelectChangeEvent) => {
        onStatusChange(event.target.value as DocumentStatus);
    };

    return (
        <Box 
            sx={{ 
                display: 'flex', 
                gap: 2, 
                mb: 3,
                flexDirection: { xs: 'column', sm: 'row' },
                alignItems: { xs: 'stretch', sm: 'center' },
            }}
        >
            <FormControl 
                sx={{ 
                    minWidth: { xs: '100%', sm: 200 } 
                }}
            >
                <InputLabel id="status-filter-label">Status</InputLabel>
                <Select
                    labelId="status-filter-label"
                    value={statusFilter}
                    label="Status"
                    onChange={handleStatusChange}
                    size="small"
                >
                    <MenuItem value="all">All</MenuItem>
                    <MenuItem value="pending">Pending</MenuItem>
                    <MenuItem value="approved">Approved</MenuItem>
                </Select>
            </FormControl>

            <TextField
                placeholder="Search in Documents..."
                value={searchQuery}
                onChange={(e) => onSearchChange(e.target.value)}
                size="small"
                sx={{ 
                    flex: 1,
                    minWidth: { xs: '100%', sm: 300 }
                }}
            />

            <Button
                variant="outlined"
                onClick={onReset}
                sx={{ 
                    minWidth: { xs: '100%', sm: 'auto' }
                }}
            >
                Reset Filters
            </Button>
        </Box>
    );
};

================
File: components/Documents/DocumentsTable.tsx
================
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    IconButton,
    TableSortLabel,
    Box,
    Typography,
    Tooltip,
    CircularProgress,
    Checkbox,
    Alert,
    Snackbar,
    Fade,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogContentText,
    DialogActions,
    Button,
} from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import EditIcon from '@mui/icons-material/Edit';
import VisibilityIcon from '@mui/icons-material/Visibility';
import DeleteIcon from '@mui/icons-material/Delete';
import { 
    DocumentType, 
    DocumentStatus, 
    Document,
    W2Document,
    Form1099Document,
    ExpenseDocument,
    DonationDocument
} from '@/types';
import { documentsApi } from '@/lib/api/documents';
import { useRouter } from 'next/router';
import { ImageViewer } from '@/components/ImageViewer';
import { DocumentFilter, 
    W2Filter, 
    Form1099Filter, 
    ExpenseFilter, 
    DonationFilter 
} from '@/types/filters';
import { DocumentFilters } from './DocumentFilters';
import { useSearch } from '@/contexts/SearchContext';
import { EditableCell } from './EditableCell';
import { updateDocument } from '@/lib/api/documents';
import { format, parse, isValid } from 'date-fns';
import { enUS } from 'date-fns/locale';

type ColumnId<T> = keyof T;

interface Column<T extends Document = Document> {
  id: keyof T | 'actions';
  label: string;
  minWidth?: number;
  align?: 'left' | 'right' | 'center';
  format?: (value: any) => string;
  editable?: boolean;
  editType?: 'text' | 'date' | 'amount' | 'select';
  options?: string[];
}

type DocumentColumns = {
  'W-2': Column<W2Document>[];
  '1099': Column<Form1099Document>[];
  'Expenses': Column<ExpenseDocument>[];
  'Donations': Column<DonationDocument>[];
};

const COLUMNS: DocumentColumns = {
  'W-2': [
    { id: 'employer', label: 'Employer', minWidth: 170 },
    { 
      id: 'wages',
      label: 'Wages',
      minWidth: 100,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { 
      id: 'fedWithholding',
      label: 'Fed Withholding',
      minWidth: 130,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { id: 'status', label: 'Status', minWidth: 100, align: 'center' }
  ],
  '1099': [
    { id: 'employer', label: 'Payer', minWidth: 170 },
    { 
      id: 'nonEmpCompensation',
      label: 'Amount',
      minWidth: 100,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { id: 'status', label: 'Status', minWidth: 100, align: 'center' }
  ],
  'Expenses': [
    { 
      id: 'vendor',
      label: 'Vendor',
      minWidth: 170,
      editable: true,
      editType: 'text'
    },
    { 
      id: 'amount',
      label: 'Amount',
      minWidth: 100,
      align: 'right',
      editable: true,
      editType: 'amount',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { 
      id: 'date',
      label: 'Date',
      minWidth: 100,
      editable: true,
      editType: 'date',
      format: (value: string) => new Date(value).toLocaleDateString()
    },
    { 
      id: 'payment_method',
      label: 'Payment Method',
      minWidth: 130,
      editable: true,
      editType: 'select',
      options: ['Credit Card', 'Debit Card', 'Cash', 'Check', 'Wire Transfer', 'Other']
    },
    { 
      id: 'category' as keyof ExpenseDocument,
      label: 'Expense Type',
      minWidth: 150,
      editable: true,
      editType: 'select',
      options: [] // Will be populated from backend /options endpoint
    },
    { 
      id: 'status' as keyof ExpenseDocument,
      label: 'Status',
      minWidth: 100,
      align: 'center',
      editable: true,
      editType: 'select',
      options: [] // Will be populated from backend /options endpoint
    }
  ],
  'Donations': [
    { id: 'charityName', label: 'Charity', minWidth: 170 },
    { 
      id: 'amount',
      label: 'Amount',
      minWidth: 100,
      align: 'right',
      format: (value: number) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
    },
    { id: 'donationType', label: 'Type', minWidth: 100 },
    { id: 'date', label: 'Date', minWidth: 100 },
    { id: 'status', label: 'Status', minWidth: 100, align: 'center' }
  ],
};

interface DocumentsTableProps {
    type: DocumentType;
    filters: DocumentFilter;
    onFilterChange: (newFilters: DocumentFilter) => void;
}

// Add this type for sorting
type SortComparator = (a: Document, b: Document) => number;

// Add this helper function at the top of the file
const isValidDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date instanceof Date && !isNaN(date.getTime());
};

const TableToolbar = ({ 
    type,
    numSelected, 
    onSelectAll, 
    onDelete,
    filters,
    onFilterChange,
    availableOptions
}: { 
    type: DocumentType;
    numSelected: number;
    onSelectAll: (event: React.ChangeEvent<HTMLInputElement>) => void;
    onDelete: () => void;
    filters: DocumentFilter;
    onFilterChange: (filters: DocumentFilter) => void;
    availableOptions: Record<string, string[]>;
}) => (
    <Box
        sx={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            borderBottom: 1,
            borderColor: 'divider',
            bgcolor: numSelected > 0 ? 'action.selected' : 'background.paper',
            px: 2,
            py: 1,
        }}
    >
        {/* Left side: Selection and bulk actions */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <Checkbox
                indeterminate={numSelected > 0}
                checked={numSelected > 0}
                onChange={onSelectAll}
            />
            {numSelected > 0 ? (
                <>
                    <Typography>
                        {numSelected} selected
                    </Typography>
                    <Tooltip title="Delete">
                        <IconButton 
                            onClick={onDelete}
                            size="small"
                        >
                            <DeleteIcon />
                        </IconButton>
                    </Tooltip>
                </>
            ) : (
                <Typography variant="h6" component="div">
                    {type}
                </Typography>
            )}
        </Box>

        {/* Right side: Filters */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
            <DocumentFilters
                type={type}
                filters={filters}
                onFilterChange={onFilterChange}
                availableOptions={availableOptions}
                variant="toolbar" // New prop to render in compact mode
            />
        </Box>
    </Box>
);

export const DocumentsTable: React.FC<DocumentsTableProps> = ({
    type,
    filters,
    onFilterChange,
}) => {
    const router = useRouter();
    const [documents, setDocuments] = useState<Document[]>([]);
    const [loading, setLoading] = useState(true);
    const [orderBy, setOrderBy] = useState<string>('');
    const [order, setOrder] = useState<'asc' | 'desc'>('asc');
    const [error, setError] = useState<string | null>(null);
    const [availableOptions, setAvailableOptions] = useState<Record<string, string[]>>({});
    const { searchQuery } = useSearch();
    const [selected, setSelected] = useState<string[]>([]);
    const [deleteSnackbar, setDeleteSnackbar] = useState({
        open: false,
        message: ''
    });
    const [showBulkDeleteConfirm, setShowBulkDeleteConfirm] = useState(false);
    const [isDeleting, setIsDeleting] = useState(false);
    const [bulkActionStatus, setBulkActionStatus] = useState<{
        show: boolean;
        message: string;
        type: 'success' | 'error';
    }>({ show: false, message: '', type: 'success' });

    useEffect(() => {
        fetchDocuments();
    }, [type]);

    useEffect(() => {
        // Set default sorting when type changes
        if (type === 'Expenses') {
            setOrderBy('date');
            setOrder('desc');
        } else {
            setOrderBy('');
            setOrder('asc');
        }
    }, [type]);

    useEffect(() => {
        if (documents.length > 0) {
            const options: Record<string, Set<string>> = {};
            
            documents.forEach(doc => {
                if (doc.type === 'Expenses') {
                    // Collect vendors
                    if (doc.vendor) {
                        options.vendor = options.vendor || new Set();
                        options.vendor.add(doc.vendor);
                    }
                    // Collect payment methods
                    if (doc.payment_method) {
                        options.paymentMethods = options.paymentMethods || new Set();
                        options.paymentMethods.add(doc.payment_method);
                    }
                    // Collect categories
                    if (doc.expenseType) {
                        options.categories = options.categories || new Set();
                        options.categories.add(doc.expenseType);
                    }
                }
                // Add similar collectors for other document types
            });

            // Convert Sets to arrays
            const finalOptions = Object.entries(options).reduce((acc, [key, value]) => {
                acc[key] = Array.from(value).sort();
                return acc;
            }, {} as Record<string, string[]>);

            setAvailableOptions(finalOptions);
        }
    }, [documents]);

    useEffect(() => {
        setSelected([]);
    }, [type]);

    const fetchDocuments = async () => {
        setLoading(true);
        setError(null);
        try {
            const docs = await documentsApi.getDocuments(type);
            console.log('DocumentsTable.fetchDocuments: Received documents:', docs);
            setDocuments(docs);
        } catch (error) {
            console.error('Error fetching documents:', error);
            setError('Failed to load documents. Please try again.');
        } finally {
            setLoading(false);
        }
    };

    const handleApprove = async (documentId: string) => {
        try {
            await documentsApi.approveDocument(documentId, type);
            await fetchDocuments(); // Refresh the list after approval
        } catch (error) {
            console.error('Error approving document:', error);
            // You might want to add error handling UI here
        }
    };

    const handleEdit = (documentId: string) => {
        // For now, just log the action
        console.log('Edit document:', documentId);
    };

    const handleSort = useCallback((columnId: string) => {
        const isAsc = orderBy === columnId && order === 'asc';
        setOrder(isAsc ? 'desc' : 'asc');
        setOrderBy(columnId);
    }, [orderBy, order]);

    const getFilteredDocuments = () => {
        if (!documents) return [];

        return documents.filter((doc) => {
            if (doc.type !== type) return false;

            // Handle different document types
            switch (doc.type) {
                case 'W-2': {
                    const w2Filter = filters as W2Filter;
                    const w2Doc = doc as W2Document;
                    
                    if (w2Filter.employer?.length && !w2Filter.employer.includes(w2Doc.employer)) return false;
                    if (w2Filter.wageRange?.min && w2Doc.wages < w2Filter.wageRange.min) return false;
                    if (w2Filter.wageRange?.max && w2Doc.wages > w2Filter.wageRange.max) return false;
                    break;
                }
                case 'Expenses': {
                    const expenseFilter = filters as ExpenseFilter;
                    const expenseDoc = doc as ExpenseDocument;
                    
                    if (expenseFilter.vendor?.length && !expenseFilter.vendor.includes(expenseDoc.vendor)) return false;
                    if (expenseFilter.amountRange?.min && expenseDoc.amount < expenseFilter.amountRange.min) return false;
                    if (expenseFilter.amountRange?.max && expenseDoc.amount > expenseFilter.amountRange.max) return false;
                    if (expenseFilter.paymentMethod?.length && !expenseFilter.paymentMethod.includes(expenseDoc.payment_method)) return false;
                    if (expenseFilter.category?.length && !expenseFilter.category.includes(expenseDoc.category)) return false;
                    break;
                }
                // ... other cases
            }

            // Common filters
            if (filters.status?.length && !filters.status.includes(doc.status)) return false;
            if (filters.dateRange?.start && new Date(doc.uploadDate) < new Date(filters.dateRange.start)) return false;
            if (filters.dateRange?.end && new Date(doc.uploadDate) > new Date(filters.dateRange.end)) return false;

            return true;
        });
    };

    // Add sorting logic
    const getSortedDocuments = useCallback(() => {
        const filtered = getFilteredDocuments();
        if (!orderBy) return filtered;

        return [...filtered].sort((a, b) => {
            let aValue = a[orderBy as keyof typeof a];
            let bValue = b[orderBy as keyof typeof b];

            // Handle special cases for expense documents
            if (a.type === 'Expenses' && b.type === 'Expenses') {
                // Handle amount sorting
                if (orderBy === 'amount') {
                    aValue = typeof aValue === 'string' 
                        ? parseFloat(aValue.replace(/[^0-9.-]+/g, ''))
                        : aValue;
                    bValue = typeof bValue === 'string' 
                        ? parseFloat(bValue.replace(/[^0-9.-]+/g, ''))
                        : bValue;
                }

                // Handle date sorting
                if (orderBy === 'date') {
                    const aValid = isValidDate(aValue as string);
                    const bValid = isValidDate(bValue as string);

                    // If both dates are invalid, maintain their original order
                    if (!aValid && !bValid) return 0;

                    // In ascending order: invalid dates go to the end
                    // In descending order: invalid dates go to the beginning
                    if (!aValid) return order === 'asc' ? 1 : -1;
                    if (!bValid) return order === 'asc' ? -1 : 1;

                    // Both dates are valid, compare them
                    const aTime = new Date(aValue as string).getTime();
                    const bTime = new Date(bValue as string).getTime();
                    return order === 'asc' ? aTime - bTime : bTime - aTime;
                }
            }

            // Handle null/undefined values
            if (aValue === null || aValue === undefined) return 1;
            if (bValue === null || bValue === undefined) return -1;
            if (aValue === bValue) return 0;

            // Handle numeric values
            if (typeof aValue === 'number' && typeof bValue === 'number') {
                return order === 'asc' ? aValue - bValue : bValue - aValue;
            }

            // Handle string values
            const aString = String(aValue).toLowerCase();
            const bString = String(bValue).toLowerCase();
            
            return order === 'asc' 
                ? aString.localeCompare(bString)
                : bString.localeCompare(aString);
        });
    }, [getFilteredDocuments, orderBy, order]);

    const renderActions = (document: Document) => {
        if (document.type === 'Expenses') {
            return (
                <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
                    <Tooltip title="View Receipt">
                        <IconButton
                            size="small"
                            onClick={(e) => {
                                e.stopPropagation(); // Prevent row click
                                handleEdit(document.id);
                            }}
                        >
                            <VisibilityIcon fontSize="small" />
                        </IconButton>
                    </Tooltip>
                    <Tooltip title="Edit">
                        <IconButton
                            size="small"
                            onClick={(e) => {
                                e.stopPropagation(); // Prevent row click
                                handleEdit(document.id);
                            }}
                        >
                            <EditIcon fontSize="small" />
                        </IconButton>
                    </Tooltip>
                </Box>
            );
        }

        return (
            <Box sx={{ display: 'flex', gap: 1, justifyContent: 'center' }}>
                {document.status !== 'Approved' && (
                    <Tooltip title="Approve">
                        <IconButton
                            onClick={() => handleApprove(document.id)}
                            color="primary"
                            size="small"
                        >
                            <CheckCircleIcon />
                        </IconButton>
                    </Tooltip>
                )}
                <Tooltip title="Edit">
                    <IconButton
                        size="small"
                        onClick={() => handleEdit(document.id)}
                    >
                        <EditIcon fontSize="small" />
                    </IconButton>
                </Tooltip>
            </Box>
        );
    };

    const filteredDocuments = useMemo(() => 
        getFilteredDocuments(), 
        [documents, getFilteredDocuments, searchQuery]
    );

    const sortedDocuments = useMemo(() => 
        getSortedDocuments(), 
        [getFilteredDocuments, orderBy, order, getSortedDocuments]
    );

    const handleSelectAllClick = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.checked) {
            const newSelected = documents.map(doc => doc.id);
            setSelected(newSelected);
            return;
        }
        setSelected([]);
    };

    const handleClick = (id: string) => {
        const selectedIndex = selected.indexOf(id);
        let newSelected: string[] = [];

        if (selectedIndex === -1) {
            newSelected = newSelected.concat(selected, id);
        } else if (selectedIndex === 0) {
            newSelected = newSelected.concat(selected.slice(1));
        } else if (selectedIndex === selected.length - 1) {
            newSelected = newSelected.concat(selected.slice(0, -1));
        } else if (selectedIndex > 0) {
            newSelected = newSelected.concat(
                selected.slice(0, selectedIndex),
                selected.slice(selectedIndex + 1)
            );
        }

        setSelected(newSelected);
    };

    const handleBulkDelete = async () => {
        if (!selected.length) return;
        
        setIsDeleting(true);
        try {
            await documentsApi.deleteDocuments(selected);
            
            // Only clear selection and refresh if delete was successful
            setSelected([]);
            await fetchDocuments();
            
            setBulkActionStatus({
                show: true,
                message: 'Successfully deleted selected items',
                type: 'success'
            });
            setShowBulkDeleteConfirm(false);
        } catch (error) {
            console.error('Bulk delete error:', error);
            setBulkActionStatus({
                show: true,
                message: error instanceof Error ? error.message : 'Failed to delete selected items',
                type: 'error'
            });
        } finally {
            setIsDeleting(false);
        }
    };

    const renderCell = (document: Document, column: Column<typeof document>) => {
        if (column.id === 'actions') {
            return renderActions(document);
        }

        const value = document[column.id as keyof typeof document];
        
        if (column.editable) {
            return (
                <EditableCell
                    value={value}
                    type={column.editType || 'text'}
                    options={column.options}
                    onSave={async (newValue) => {
                        await handleUpdateField(document.id, column.id as string, newValue);
                    }}
                    format={column.format}
                    align={column.align}
                />
            );
        }

        return column.format ? column.format(value) : value;
    };

    const handleUpdateField = async (documentId: string, field: string, value: any) => {
        try {
            console.log('DocumentsTable.handleUpdateField: Updating field:', {
                documentId,
                field,
                value
            });
            
            // Format the value based on type before sending to API
            const formattedValue = typeof value === 'string' && field === 'amount'
                ? parseFloat(value.replace(/[^\d.-]/g, ''))
                : value;
            
            const updates = { [field]: formattedValue };
            const updatedDoc = await updateDocument(documentId, updates);
            
            // Update all fields in the document with the response
            setDocuments(prevDocs =>
                prevDocs.map(doc =>
                    doc.id === documentId 
                        ? { ...doc, ...updatedDoc }
                        : doc
                )
            );
        } catch (error) {
            console.error('DocumentsTable.handleUpdateField: Update failed:', {
                error,
                documentId,
                field,
                value
            });
            throw error;
        }
    };

    if (loading) {
        return (
            <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                <CircularProgress />
            </Box>
        );
    }

    if (error) {
        return (
            <Paper 
                variant="outlined" 
                sx={{ 
                    p: 4, 
                    textAlign: 'center',
                    color: 'error.main'
                }}
            >
                <Typography>{error}</Typography>
            </Paper>
        );
    }

    if (documents.length === 0) {
        return (
            <Paper 
                variant="outlined" 
                sx={{ 
                    p: 4, 
                    textAlign: 'center',
                    color: 'text.secondary'
                }}
            >
                <Typography>
                    No {type} documents found
                </Typography>
            </Paper>
        );
    }

    return (
        <>
            <DocumentFilters
                type={type}
                filters={filters}
                onFilterChange={onFilterChange}
                availableOptions={availableOptions}
            />
            <Paper>
                <TableToolbar 
                    type={type}
                    numSelected={selected.length}
                    onSelectAll={handleSelectAllClick}
                    onDelete={handleBulkDelete}
                    filters={filters}
                    onFilterChange={onFilterChange}
                    availableOptions={availableOptions}
                />
                <TableContainer>
                    <Table stickyHeader size="small">
                        <TableHead>
                            <TableRow>
                                <TableCell padding="checkbox" />
                                {COLUMNS[type].map((column) => (
                                    <TableCell
                                        key={column.id}
                                        align={column.align}
                                        style={{ minWidth: column.minWidth }}
                                    >
                                        <TableSortLabel
                                            active={orderBy === column.id}
                                            direction={orderBy === column.id ? order : 'asc'}
                                            onClick={() => handleSort(column.id)}
                                            sx={{
                                                '& .MuiTableSortLabel-icon': {
                                                    opacity: orderBy === column.id ? 1 : 0.5
                                                }
                                            }}
                                        >
                                            {column.label}
                                        </TableSortLabel>
                                    </TableCell>
                                ))}
                                <TableCell align="right">Actions</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {sortedDocuments.map((document) => (
                                <TableRow 
                                    hover 
                                    key={document.id}
                                    selected={selected.includes(document.id)}
                                    sx={{ 
                                        '&:hover': {
                                            bgcolor: 'action.hover',
                                        }
                                    }}
                                >
                                    <TableCell padding="checkbox">
                                        <Checkbox
                                            checked={selected.includes(document.id)}
                                            onChange={() => handleClick(document.id)}
                                        />
                                    </TableCell>
                                    {COLUMNS[type].map((column) => renderCell(document, column))}
                                    <TableCell align="right">
                                        {renderActions(document)}
                                    </TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                </TableContainer>
            </Paper>

            <Snackbar
                open={deleteSnackbar.open}
                autoHideDuration={6000}
                onClose={() => setDeleteSnackbar({ ...deleteSnackbar, open: false })}
                message={deleteSnackbar.message}
            />

            <Dialog
                open={showBulkDeleteConfirm}
                onClose={() => setShowBulkDeleteConfirm(false)}
            >
                <DialogTitle>Confirm Delete</DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Are you sure you want to delete {selected.length} selected items?
                    </DialogContentText>
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setShowBulkDeleteConfirm(false)}>
                        Cancel
                    </Button>
                    <Button 
                        onClick={handleBulkDelete}
                        color="error"
                        disabled={isDeleting}
                    >
                        {isDeleting ? 'Deleting...' : 'Delete'}
                    </Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={bulkActionStatus.show}
                autoHideDuration={6000}
                onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
            >
                <Alert 
                    severity={bulkActionStatus.type}
                    onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
                >
                    {bulkActionStatus.message}
                </Alert>
            </Snackbar>
        </>
    );
};

================
File: components/Documents/DocumentsTabs.tsx
================
import React from 'react';
import { Tabs, Tab, Box } from '@mui/material';
import { DocumentType } from '@/types';

interface DocumentsTabsProps {
    activeTab: DocumentType;
    onTabChange: (tab: DocumentType) => void;
}

const TABS: { value: DocumentType; label: string }[] = [
    { value: 'W-2', label: 'W-2' },
    { value: '1099', label: '1099' },
    { value: 'Expenses', label: 'Expenses' },
    { value: 'Donations', label: 'Donations' },
];

export const DocumentsTabs: React.FC<DocumentsTabsProps> = ({ 
    activeTab, 
    onTabChange 
}) => {
    return (
        <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
            <Tabs 
                value={activeTab}
                onChange={(_, newValue) => onTabChange(newValue)}
                variant="scrollable"
                scrollButtons="auto"
                aria-label="document type tabs"
                sx={{
                    '& .MuiTab-root': {
                        fontSize: '1rem',
                        fontWeight: 600,
                        textTransform: 'none',
                        minWidth: 100,
                    }
                }}
            >
                {TABS.map(tab => (
                    <Tab 
                        key={tab.value}
                        value={tab.value}
                        label={tab.label}
                        id={`tab-${tab.value}`}
                        aria-controls={`tabpanel-${tab.value}`}
                    />
                ))}
            </Tabs>
        </Box>
    );
};

================
File: components/Documents/DocumentUploadArea.tsx
================
import React, { useCallback, useState } from 'react';
import { Box, Typography, LinearProgress, Alert } from '@mui/material';
import { useDropzone } from 'react-dropzone';
import CloudUploadIcon from '@mui/icons-material/CloudUpload';
import { DocumentType } from '@/types';
import { documentsApi } from '@/lib/api/documents';

interface DocumentUploadAreaProps {
    activeTab: DocumentType;
    onUploadComplete?: () => void;
}

export const DocumentUploadArea: React.FC<DocumentUploadAreaProps> = ({ 
    activeTab,
    onUploadComplete 
}) => {
    const [isUploading, setIsUploading] = useState(false);
    const [uploadError, setUploadError] = useState<string | null>(null);

    const onDrop = useCallback(async (acceptedFiles: File[]) => {
        if (acceptedFiles.length === 0) return;

        setIsUploading(true);
        setUploadError(null);

        try {
            const file = acceptedFiles[0];
            await documentsApi.uploadDocument(file, activeTab);
            if (onUploadComplete) {
                onUploadComplete();
            }
        } catch (error) {
            setUploadError('Failed to upload document. Please try again.');
            console.error('Upload error:', error);
        } finally {
            setIsUploading(false);
        }
    }, [activeTab, onUploadComplete]);

    const { getRootProps, getInputProps, isDragActive } = useDropzone({
        onDrop,
        accept: {
            'image/jpeg': ['.jpg', '.jpeg'],
            'image/png': ['.png'],
            'application/pdf': ['.pdf']
        },
        multiple: false,
        disabled: isUploading
    });

    return (
        <Box 
            {...getRootProps()}
            sx={{
                p: 3,
                mb: 3,
                border: '2px dashed',
                borderColor: theme => 
                    isDragActive 
                        ? 'primary.main' 
                        : uploadError 
                            ? 'error.main' 
                            : 'divider',
                borderRadius: 1,
                bgcolor: theme =>
                    isDragActive
                        ? 'primary.light'
                        : uploadError
                            ? 'error.light'
                            : 'background.default',
                cursor: isUploading ? 'wait' : 'pointer',
                transition: 'all 0.2s ease',
                textAlign: 'center',
                position: 'relative'
            }}
        >
            <input {...getInputProps()} />

            {isUploading && (
                <LinearProgress 
                    sx={{ 
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        borderTopLeftRadius: 'inherit',
                        borderTopRightRadius: 'inherit'
                    }}
                />
            )}

            <Box sx={{ 
                display: 'flex', 
                flexDirection: 'column', 
                alignItems: 'center',
                gap: 2
            }}>
                <CloudUploadIcon 
                    sx={{ 
                        fontSize: 48,
                        color: theme => 
                            isDragActive 
                                ? 'primary.main' 
                                : 'text.secondary'
                    }} 
                />
                
                <Typography variant="h6" component="div">
                    {isDragActive
                        ? `Drop your ${activeTab} document here`
                        : isUploading
                            ? 'Uploading...'
                            : `Drag and drop your ${activeTab} document here`}
                </Typography>

                <Typography variant="body2" color="text.secondary">
                    or click to select files (PDF, JPEG, PNG)
                </Typography>
            </Box>

            {uploadError && (
                <Alert 
                    severity="error" 
                    sx={{ mt: 2 }}
                    onClose={() => setUploadError(null)}
                >
                    {uploadError}
                </Alert>
            )}
        </Box>
    );
};

================
File: components/Documents/DocumentUploadFab.tsx
================
import React, { useState } from 'react';
import { 
    Fab, 
    Dialog,
    DialogTitle,
    DialogContent,
    IconButton,
    Box,
    useTheme,
    useMediaQuery
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import CloseIcon from '@mui/icons-material/Close';
import { DocumentUploadArea } from './DocumentUploadArea';
import { DocumentType } from '@/types';

export const DocumentUploadFab: React.FC = () => {
    const [isOpen, setIsOpen] = useState(false);
    const theme = useTheme();
    const fullScreen = useMediaQuery(theme.breakpoints.down('sm'));

    return (
        <>
            <Fab
                color="primary"
                aria-label="upload document"
                onClick={() => setIsOpen(true)}
                sx={{
                    position: 'fixed',
                    bottom: 24,
                    right: 24,
                }}
            >
                <AddIcon />
            </Fab>

            <Dialog
                open={isOpen}
                onClose={() => setIsOpen(false)}
                fullScreen={fullScreen}
                maxWidth="md"
                fullWidth
            >
                <DialogTitle sx={{ 
                    m: 0, 
                    p: 2, 
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }}>
                    Upload Document
                    <IconButton
                        aria-label="close"
                        onClick={() => setIsOpen(false)}
                        sx={{ color: 'text.secondary' }}
                    >
                        <CloseIcon />
                    </IconButton>
                </DialogTitle>
                <DialogContent>
                    <Box sx={{ pt: 2 }}>
                        <DocumentUploadArea activeTab={'W-2' as DocumentType} />
                    </Box>
                </DialogContent>
            </Dialog>
        </>
    );
};

================
File: components/Documents/EditableCell.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import {
  TextField,
  TableCell,
  ClickAwayListener,
  Select,
  MenuItem,
  InputAdornment,
  Box,
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { format, parse, isValid } from 'date-fns';
import { enUS } from 'date-fns/locale';

interface EditableCellProps {
  value: string | number | null;
  type: 'text' | 'date' | 'amount' | 'select';
  onSave: (newValue: string) => Promise<void>;
  options?: string[];
  disabled?: boolean;
  align?: 'left' | 'right' | 'center';
  format?: (value: any) => string;
}

export const EditableCell: React.FC<EditableCellProps> = ({
  value,
  type,
  onSave,
  options = [],
  disabled = false,
  align = 'left',
  format: formatValue,
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState('');
  const [error, setError] = useState<string | null>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    setEditValue(value != null ? value.toString() : '');
  }, [value]);

  const handleClick = () => {
    if (!disabled) {
      console.log('EditableCell: Starting edit mode:', { type, value });
      setIsEditing(true);
    }
  };

  const exitEditMode = () => {
    setIsEditing(false);
    setEditValue(value.toString());
    setError(null);
  };

  const handleSave = async () => {
    if (!isEditing) return;
    
    try {
      if (type === 'date') {
        console.log('EditableCell.handleSave: Processing date value:', {
          editValue,
          type: typeof editValue
        });
        
        // If the value is empty, don't process it
        if (!editValue.trim()) {
          console.log('EditableCell.handleSave: Empty date value, skipping');
          await onSave('');
          setError(null);
          exitEditMode();
          return;
        }

        // Try to parse the date
        const date = parse(editValue.trim(), 'yyyy-MM-dd', new Date(), { locale: enUS });
        console.log('EditableCell.handleSave: Parsed date:', {
          date,
          isValid: isValid(date)
        });

        if (!isValid(date)) {
          console.error('EditableCell.handleSave: Invalid date format:', editValue);
          throw new Error('Please use YYYY-MM-DD format');
        }

        // Format the date for saving
        const formattedDate = format(date, 'yyyy-MM-dd', { locale: enUS });
        console.log('EditableCell.handleSave: Sending formatted date:', formattedDate);
        
        await onSave(formattedDate);
        console.log('EditableCell.handleSave: Date saved successfully');
        setError(null);
      } else if (type === 'amount') {
        const amount = parseFloat(editValue.replace(/[^\d.-]/g, ''));
        if (isNaN(amount)) {
          throw new Error('Invalid amount format');
        }
        await onSave(amount.toString());
        setError(null);
      } else {
        await onSave(editValue);
        setError(null);
      }
      exitEditMode();
    } catch (err) {
      console.error('EditableCell.handleSave: Error saving value:', {
        error: err,
        type,
        value: editValue
      });
      setError(err instanceof Error ? err.message : 'An error occurred');
      return;
    }
  };

  const handleDateChange = (newValue: Date | null) => {
    console.log('EditableCell.handleDateChange: New date selected:', {
      newValue,
      isValid: newValue && isValid(newValue)
    });

    if (newValue && isValid(newValue)) {
      const formattedDate = format(newValue, 'yyyy-MM-dd', { locale: enUS });
      console.log('EditableCell.handleDateChange: Formatted date:', formattedDate);
      setEditValue(formattedDate);
      setError(null);
    } else {
      console.log('EditableCell.handleDateChange: Invalid or null date');
      setEditValue('');
      setError('Please select a valid date');
    }
  };

  const parseDate = (dateStr: string) => {
    console.log('EditableCell.parseDate: Input:', {
      value: dateStr,
      type: typeof dateStr
    });
    
    try {
      if (!dateStr || dateStr === 'Invalid Date') {
        console.log('EditableCell.parseDate: Empty or Invalid Date string');
        return null;
      }
      const trimmedDate = dateStr.trim();
      console.log('EditableCell.parseDate: Trimmed:', trimmedDate);
      
      const date = parse(trimmedDate, 'yyyy-MM-dd', new Date(), { locale: enUS });
      console.log('EditableCell.parseDate: Parsed result:', {
        date,
        isValid: isValid(date)
      });
      
      return isValid(date) ? date : null;
    } catch (e) {
      console.error('EditableCell.parseDate: Error:', e);
      return null;
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSave();
    } else if (e.key === 'Escape') {
      exitEditMode();
    }
  };

  if (!isEditing) {
    return (
      <TableCell
        align={align}
        onClick={handleClick}
        sx={{ 
          cursor: disabled ? 'default' : 'pointer',
          padding: '16px',
          '&:hover': {
            backgroundColor: disabled ? 'transparent' : 'action.hover',
          }
        }}
      >
        {formatValue ? formatValue(value) : value}
      </TableCell>
    );
  }

  return (
    <TableCell 
      align={align} 
      padding="none"
      sx={{
        position: 'relative',
        '& .MuiInputBase-root': {
          backgroundColor: 'background.paper',
        }
      }}
    >
      <ClickAwayListener onClickAway={handleSave}>
        <Box sx={{ p: 1 }}>
          {type === 'date' ? (
            <LocalizationProvider dateAdapter={AdapterDateFns}>
              <DatePicker
                value={parseDate(editValue)}
                onChange={handleDateChange}
                format="yyyy-MM-dd"
                slotProps={{
                  textField: {
                    error: !!error,
                    helperText: error || 'Use format: YYYY-MM-DD',
                    onKeyDown: handleKeyDown,
                    size: "small",
                    fullWidth: true,
                    inputRef: inputRef,
                    sx: { backgroundColor: 'background.paper' }
                  }
                }}
              />
            </LocalizationProvider>
          ) : type === 'amount' ? (
            <TextField
              value={editValue}
              onChange={(e) => setEditValue(e.target.value)}
              onKeyDown={handleKeyDown}
              error={!!error}
              helperText={error}
              size="small"
              fullWidth
              inputRef={inputRef}
              InputProps={{
                startAdornment: <InputAdornment position="start">$</InputAdornment>,
              }}
              sx={{ backgroundColor: 'background.paper' }}
            />
          ) : type === 'select' ? (
            <Select
              value={editValue}
              onChange={(e) => setEditValue(e.target.value)}
              onKeyDown={handleKeyDown}
              size="small"
              fullWidth
              sx={{ backgroundColor: 'background.paper' }}
            >
              {options.map((option) => (
                <MenuItem key={option} value={option}>
                  {option}
                </MenuItem>
              ))}
            </Select>
          ) : (
            <TextField
              value={editValue}
              onChange={(e) => setEditValue(e.target.value)}
              onKeyDown={handleKeyDown}
              error={!!error}
              helperText={error}
              size="small"
              fullWidth
              inputRef={inputRef}
              sx={{ backgroundColor: 'background.paper' }}
            />
          )}
        </Box>
      </ClickAwayListener>
    </TableCell>
  );
};

================
File: components/Documents/ExpenseFilters.tsx
================
import React, { useState, useEffect } from 'react';
import {
    Box,
    Accordion,
    AccordionSummary,
    AccordionDetails,
    Typography,
    TextField,
    Select,
    MenuItem,
    FormControl,
    InputLabel,
    Chip,
    IconButton,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import FilterListIcon from '@mui/icons-material/FilterList';
import CloseIcon from '@mui/icons-material/Close';

export interface ExpenseFilter {
    vendor?: string[];
    amountRange?: {
        min?: number;
        max?: number;
    };
    dateRange?: {
        start?: string;
        end?: string;
    };
    paymentMethods?: string[];
    categories?: string[];
    status?: string[];
}

interface FilterOptions {
    categories: string[];
    payment_methods: string[];
    statuses: string[];
    vendors: string[];
}

interface ExpenseFiltersProps {
    filters: ExpenseFilter;
    onFilterChange: (filters: ExpenseFilter) => void;
}

export const ExpenseFilters: React.FC<ExpenseFiltersProps> = ({
    filters,
    onFilterChange,
}) => {
    const [filterOptions, setFilterOptions] = useState<FilterOptions>({
        categories: [],
        payment_methods: [],
        statuses: [],
        vendors: []
    });

    useEffect(() => {
        // Fetch filter options from the backend
        const fetchOptions = async () => {
            try {
                const response = await fetch('/api/options');
                if (!response.ok) {
                    throw new Error('Failed to fetch options');
                }
                const data = await response.json();
                setFilterOptions(data);
            } catch (error) {
                console.error('Error fetching filter options:', error);
            }
        };

        fetchOptions();
    }, []);

    const handleRemoveFilter = (type: keyof ExpenseFilter, value?: string) => {
        const newFilters = { ...filters };
        if (value && Array.isArray(newFilters[type])) {
            newFilters[type] = (newFilters[type] as string[]).filter(v => v !== value);
            if ((newFilters[type] as string[]).length === 0) {
                delete newFilters[type];
            }
        } else {
            delete newFilters[type];
        }
        onFilterChange(newFilters);
    };

    return (
        <Box sx={{ mb: 2 }}>
            <Accordion>
                <AccordionSummary
                    expandIcon={<ExpandMoreIcon />}
                    sx={{ 
                        bgcolor: 'background.default',
                        '&:hover': { bgcolor: 'action.hover' }
                    }}
                >
                    <Box sx={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: 1 
                    }}>
                        <FilterListIcon />
                        <Typography>Filters</Typography>
                    </Box>
                </AccordionSummary>
                <AccordionDetails>
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                        {/* Amount Range */}
                        <Box sx={{ display: 'flex', gap: 2 }}>
                            <TextField
                                label="Min Amount"
                                type="number"
                                size="small"
                                value={filters.amountRange?.min || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    amountRange: {
                                        ...filters.amountRange,
                                        min: e.target.value ? Number(e.target.value) : undefined
                                    }
                                })}
                            />
                            <TextField
                                label="Max Amount"
                                type="number"
                                size="small"
                                value={filters.amountRange?.max || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    amountRange: {
                                        ...filters.amountRange,
                                        max: e.target.value ? Number(e.target.value) : undefined
                                    }
                                })}
                            />
                        </Box>

                        {/* Date Range */}
                        <Box sx={{ display: 'flex', gap: 2 }}>
                            <TextField
                                label="Start Date"
                                type="date"
                                size="small"
                                InputLabelProps={{ shrink: true }}
                                value={filters.dateRange?.start || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    dateRange: {
                                        ...filters.dateRange,
                                        start: e.target.value || undefined
                                    }
                                })}
                            />
                            <TextField
                                label="End Date"
                                type="date"
                                size="small"
                                InputLabelProps={{ shrink: true }}
                                value={filters.dateRange?.end || ''}
                                onChange={(e) => onFilterChange({
                                    ...filters,
                                    dateRange: {
                                        ...filters.dateRange,
                                        end: e.target.value || undefined
                                    }
                                })}
                            />
                        </Box>

                        {/* Multi-select filters */}
                        <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                            {/* Vendor Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Vendor</InputLabel>
                                <Select
                                    multiple
                                    value={filters.vendor || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        vendor: e.target.value as string[]
                                    })}
                                    label="Vendor"
                                >
                                    {filterOptions.vendors.map((vendor) => (
                                        <MenuItem key={vendor} value={vendor}>
                                            {vendor}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>

                            {/* Payment Method Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Payment Method</InputLabel>
                                <Select
                                    multiple
                                    value={filters.paymentMethods || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        paymentMethods: e.target.value as string[]
                                    })}
                                    label="Payment Method"
                                >
                                    {filterOptions.payment_methods.map((method) => (
                                        <MenuItem key={method} value={method}>
                                            {method}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>

                            {/* Category Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Category</InputLabel>
                                <Select
                                    multiple
                                    value={filters.categories || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        categories: e.target.value as string[]
                                    })}
                                    label="Category"
                                >
                                    {filterOptions.categories.map((category) => (
                                        <MenuItem key={category} value={category}>
                                            {category}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>

                            {/* Status Select */}
                            <FormControl size="small" sx={{ minWidth: 200 }}>
                                <InputLabel>Status</InputLabel>
                                <Select
                                    multiple
                                    value={filters.status || []}
                                    onChange={(e) => onFilterChange({
                                        ...filters,
                                        status: e.target.value as string[]
                                    })}
                                    label="Status"
                                >
                                    {filterOptions.statuses.map((status) => (
                                        <MenuItem key={status} value={status}>
                                            {status}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Box>
                    </Box>
                </AccordionDetails>
            </Accordion>

            {/* Active Filters Display */}
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>
                {Object.entries(filters).map(([key, value]) => {
                    if (Array.isArray(value)) {
                        return value.map((v) => (
                            <Chip
                                key={`${key}-${v}`}
                                label={`${key}: ${v}`}
                                onDelete={() => handleRemoveFilter(key as keyof ExpenseFilter, v)}
                                size="small"
                            />
                        ));
                    }
                    if (key === 'amountRange' && value) {
                        const { min, max } = value;
                        if (min || max) {
                            return (
                                <Chip
                                    key="amount"
                                    label={`Amount: ${min || '0'} - ${max || '∞'}`}
                                    onDelete={() => handleRemoveFilter('amountRange')}
                                    size="small"
                                />
                            );
                        }
                    }
                    if (key === 'dateRange' && value) {
                        const { start, end } = value;
                        if (start || end) {
                            return (
                                <Chip
                                    key="date"
                                    label={`Date: ${start || '∞'} - ${end || '∞'}`}
                                    onDelete={() => handleRemoveFilter('dateRange')}
                                    size="small"
                                />
                            );
                        }
                    }
                    return null;
                })}
            </Box>
        </Box>
    );
};

================
File: components/GlobalHeader/GlobalHeader.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import Link from 'next/link';
import { 
    AppBar,
    Toolbar,
    Typography,
    InputBase,
    Box,
    IconButton,
    Paper,
    useMediaQuery,
    useTheme,
    TextField
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import HelpOutlineIcon from '@mui/icons-material/HelpOutline';
import { styled } from '@mui/material/styles';
import { SearchResult } from '@/types';
import { useSearch } from '@/contexts/SearchContext';

const SearchInput = styled(InputBase)(({ theme }) => ({
    marginLeft: theme.spacing(1),
    flex: 1,
}));

const SearchResults = styled(Paper)(({ theme }) => ({
    position: 'absolute',
    top: '100%',
    left: 0,
    right: 0,
    zIndex: 1,
    marginTop: theme.spacing(1),
    maxHeight: '400px',
    overflow: 'auto'
}));

const ResultGroup = styled(Box)(({ theme }) => ({
    padding: theme.spacing(1, 2)
}));

const GroupHeader = styled(Typography)(({ theme }) => ({
    color: theme.palette.text.secondary,
    fontSize: '0.75rem',
    fontWeight: 600,
    textTransform: 'uppercase',
    marginBottom: theme.spacing(1)
}));

const SearchResultItem = styled(Box)(({ theme }) => ({
    display: 'flex',
    alignItems: 'center',
    padding: theme.spacing(1),
    cursor: 'pointer',
    '&:hover': {
        backgroundColor: theme.palette.action.hover
    }
}));

const TaxDisplay = styled(Typography)(({ theme }) => ({
    fontSize: '1.125rem',
    fontWeight: 600,
    letterSpacing: '0.5px',
    textTransform: 'uppercase',
    color: theme.palette.primary.main,
    display: 'flex',
    alignItems: 'center',
    gap: theme.spacing(1),
    '& .amount': {
        fontWeight: 700,
        color: theme.palette.success.main
    }
}));

// Add children to the component props
interface GlobalHeaderProps {
    children?: React.ReactNode;
}

const GlobalHeader: React.FC<GlobalHeaderProps> = ({ children }) => {
    const { searchQuery, setSearchQuery } = useSearch();
    const [showSearchResults, setShowSearchResults] = useState(false);
    const [isSearchExpanded, setIsSearchExpanded] = useState(false);
    const searchRef = useRef<HTMLDivElement>(null);
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const defaultSearchResults: SearchResult[] = [
        { id: '1', type: 'W-2', name: 'Google Inc', group: 'W-2 Employers' },
        { id: '2', type: '1099', name: 'Freelance Client', group: '1099 Payers' },
        { id: '3', type: 'expense', name: 'Office Supplies', group: 'Vendors' },
        { id: '4', type: 'donation', name: 'Red Cross', group: 'Charities' },
    ];

    const [searchResults, setSearchResults] = useState([...defaultSearchResults]);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (searchRef.current && !searchRef.current.contains(event.target as Node)) {
                setShowSearchResults(false);
                if (isMobile) setIsSearchExpanded(false);
            }
        };

        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [isMobile]);

    const handleSearchFocus = () => {
        setShowSearchResults(true);
        setIsSearchExpanded(true);
    };

    const handleSearchClick = () => {
        if (isMobile && !isSearchExpanded) {
            setIsSearchExpanded(true);
        }
    };

    const groupedResults = searchResults.reduce((acc, result) => ({
        ...acc,
        [result.group]: [...(acc[result.group] || []), result]
    }), {} as Record<string, SearchResult[]>);

    return (
        <AppBar 
            position="fixed" 
            color="default" 
            elevation={1}
            sx={{ 
                zIndex: theme => theme.zIndex.drawer + 1,
                borderRadius: 0,
                '& .MuiToolbar-root': {
                    borderRadius: 0,
                }
            }}
        >
            <Toolbar>
                {children}
                <Typography
                    variant="h6"
                    component={Link}
                    href="/"
                    sx={{ 
                        textDecoration: 'none',
                        color: 'inherit',
                        flexGrow: 0,
                        display: isMobile && isSearchExpanded ? 'none' : 'block'
                    }}
                >
                    ten40
                </Typography>

                <Box sx={{ 
                    flexGrow: 1, 
                    display: 'flex', 
                    justifyContent: 'center',
                    visibility: (isMobile && isSearchExpanded) ? 'hidden' : 'visible',
                    py: 1
                }}>
                    <TaxDisplay>
                        CURRENT TAX: <span className="amount">+$500</span>
                    </TaxDisplay>
                </Box>

                <Box sx={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: 2,
                    ml: 'auto'
                }}>
                    <Box 
                        ref={searchRef}
                        sx={{ 
                            position: 'relative',
                            width: isSearchExpanded ? '100%' : 'auto',
                            maxWidth: '300px',
                            transition: 'width 0.2s ease-in-out'
                        }}
                    >
                        {(!isMobile || isSearchExpanded) && (
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <SearchIcon sx={{ color: 'text.secondary', mr: 1 }} />
                                <SearchInput
                                    placeholder="Search..."
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                    onFocus={handleSearchFocus}
                                    onClick={handleSearchClick}
                                    sx={{ width: isSearchExpanded ? '100%' : '200px' }}
                                />
                            </Box>
                        )}
                        {showSearchResults && (
                            <SearchResults elevation={3}>
                                {Object.entries(groupedResults).map(([group, results]) => (
                                    <ResultGroup key={group}>
                                        <GroupHeader>{group}</GroupHeader>
                                        {results.map((result) => (
                                            <SearchResultItem key={result.id}>
                                                <Typography variant="body2" color="text.secondary" sx={{ mr: 1 }}>
                                                    {result.type}
                                                </Typography>
                                                <Typography variant="body2">
                                                    {result.name}
                                                </Typography>
                                            </SearchResultItem>
                                        ))}
                                    </ResultGroup>
                                ))}
                            </SearchResults>
                        )}
                    </Box>

                    {(!isMobile || !isSearchExpanded) && (
                        <IconButton
                            onClick={() => {/* TODO: Implement help panel */}}
                            title="Get Help"
                            size="small"
                            sx={{ ml: 1 }}
                        >
                            <HelpOutlineIcon />
                        </IconButton>
                    )}
                </Box>
            </Toolbar>
        </AppBar>
    );
};

export default GlobalHeader;

================
File: components/Layout/Layout.tsx
================
import React, { useState } from 'react';
import { Box, IconButton, useMediaQuery, useTheme } from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import { LeftNav } from '../LeftNav/LeftNav';
import GlobalHeader from '../GlobalHeader/GlobalHeader';

interface LayoutProps {
    children: React.ReactNode;
}

const DRAWER_WIDTH = 250;
const HEADER_HEIGHT = 64;

export const Layout: React.FC<LayoutProps> = ({ children }) => {
    const [mobileOpen, setMobileOpen] = useState(false);
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const handleDrawerToggle = () => {
        setMobileOpen(!mobileOpen);
    };

    return (
        <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
            <GlobalHeader>
                {isMobile && (
                    <IconButton
                        color="inherit"
                        aria-label="open drawer"
                        edge="start"
                        onClick={handleDrawerToggle}
                        sx={{ mr: 2, display: { sm: 'none' } }}
                    >
                        <MenuIcon />
                    </IconButton>
                )}
            </GlobalHeader>
            
            <Box sx={{ display: 'flex', flex: 1 }}>
                <LeftNav 
                    mobileOpen={mobileOpen} 
                    onMobileClose={() => setMobileOpen(false)} 
                />
                
                <Box
                    component="main"
                    sx={{
                        flexGrow: 1,
                        minHeight: `calc(100vh - ${HEADER_HEIGHT}px)`,
                        mt: `${HEADER_HEIGHT}px`,
                        width: '100%',
                        position: 'relative',
                        pl: { sm: `${DRAWER_WIDTH}px` },
                    }}
                >
                    {children}
                </Box>
            </Box>
        </Box>
    );
};

================
File: components/LeftNav/LeftNav.tsx
================
import React from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import {
    Drawer,
    List,
    ListItem,
    ListItemButton,
    ListItemIcon,
    ListItemText,
    useTheme,
    useMediaQuery,
    IconButton,
    Box,
} from '@mui/material';
import { styled } from '@mui/material/styles';
import DashboardIcon from '@mui/icons-material/Dashboard';
import DescriptionIcon from '@mui/icons-material/Description';
import ReceiptIcon from '@mui/icons-material/Receipt';
import PersonIcon from '@mui/icons-material/Person';
import CloseIcon from '@mui/icons-material/Close';

const DRAWER_WIDTH = 250;
const HEADER_HEIGHT = 64; // Standard MUI AppBar height

interface NavItem {
    path: string;
    label: string;
    icon: React.ReactNode;
}

const NAV_ITEMS: NavItem[] = [
    { path: '/dashboard', label: 'Dashboard', icon: <DashboardIcon /> },
    { path: '/documents', label: 'Documents', icon: <DescriptionIcon /> },
    { path: '/1040', label: '1040', icon: <ReceiptIcon /> },
    { path: '/profile', label: 'Profile', icon: <PersonIcon /> },
];

const StyledDrawer = styled(Drawer)(({ theme }) => ({
    width: DRAWER_WIDTH,
    flexShrink: 0,
    '& .MuiDrawer-paper': {
        width: DRAWER_WIDTH,
        boxSizing: 'border-box',
        borderRight: `1px solid ${theme.palette.divider}`,
        backgroundColor: theme.palette.background.paper,
        height: `calc(100% - ${HEADER_HEIGHT}px)`,
        top: HEADER_HEIGHT,
    },
}));

interface LeftNavProps {
    mobileOpen: boolean;
    onMobileClose: () => void;
}

export const LeftNav: React.FC<LeftNavProps> = ({ mobileOpen, onMobileClose }) => {
    const router = useRouter();
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const isSelected = (path: string, currentPath: string) => {
        if (path === '/documents') {
            return currentPath === path || currentPath.startsWith('/receipt/');
        }
        return currentPath === path;
    };

    const drawer = (
        <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
            {isMobile && (
                <Box sx={{ 
                    display: 'flex', 
                    justifyContent: 'flex-end', 
                    p: 1,
                    borderBottom: 1,
                    borderColor: 'divider'
                }}>
                    <IconButton onClick={onMobileClose} size="small">
                        <CloseIcon />
                    </IconButton>
                </Box>
            )}
            <List sx={{ flex: 1, pt: isMobile ? 0 : 2 }}>
                {NAV_ITEMS.map(({ path, label, icon }) => (
                    <ListItem key={path} disablePadding>
                        <ListItemButton
                            component={Link}
                            href={path}
                            selected={isSelected(path, router.pathname)}
                            onClick={isMobile ? onMobileClose : undefined}
                            sx={{
                                py: 1.5,
                                px: 2,
                                '&.Mui-selected': {
                                    bgcolor: 'primary.light',
                                    color: 'primary.main',
                                    '&:hover': {
                                        bgcolor: 'primary.light',
                                    },
                                    '& .MuiListItemIcon-root': {
                                        color: 'primary.main',
                                    },
                                },
                            }}
                        >
                            <ListItemIcon sx={{ minWidth: 40 }}>
                                {icon}
                            </ListItemIcon>
                            <ListItemText 
                                primary={label}
                                primaryTypographyProps={{
                                    fontSize: '0.9375rem',
                                    fontWeight: 600,
                                }}
                            />
                        </ListItemButton>
                    </ListItem>
                ))}
            </List>
        </Box>
    );

    return (
        <>
            {/* Desktop permanent drawer */}
            {!isMobile && (
                <StyledDrawer
                    variant="permanent"
                    open
                >
                    {drawer}
                </StyledDrawer>
            )}

            {/* Mobile temporary drawer */}
            {isMobile && (
                <Drawer
                    variant="temporary"
                    open={mobileOpen}
                    onClose={onMobileClose}
                    ModalProps={{
                        keepMounted: true,
                    }}
                    sx={{
                        display: { xs: 'block', sm: 'none' },
                        '& .MuiDrawer-paper': { 
                            width: DRAWER_WIDTH,
                            boxSizing: 'border-box',
                            top: HEADER_HEIGHT,
                            height: `calc(100% - ${HEADER_HEIGHT}px)`,
                        },
                    }}
                >
                    {drawer}
                </Drawer>
            )}
        </>
    );
};

================
File: components/ErrorBoundary.tsx
================
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Alert, Button, Box } from '@mui/material';

interface Props {
    children: ReactNode;
}

interface State {
    hasError: boolean;
    error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
    public state: State = {
        hasError: false,
        error: null
    };

    public static getDerivedStateFromError(error: Error): State {
        return { hasError: true, error };
    }

    public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.error('Uncaught error:', error, errorInfo);
    }

    public render() {
        if (this.state.hasError) {
            return (
                <Box sx={{ p: 2 }}>
                    <Alert 
                        severity="error"
                        action={
                            <Button 
                                color="inherit" 
                                size="small"
                                onClick={() => window.location.reload()}
                            >
                                Reload Page
                            </Button>
                        }
                    >
                        Something went wrong. Please try again.
                    </Alert>
                </Box>
            );
        }

        return this.props.children;
    }
}

================
File: components/ImageViewer.tsx
================
import React from 'react';
import { Box, useMediaQuery, Theme } from '@mui/material';
import { DialogWrapper } from './common/DialogWrapper';

interface ImageViewerProps {
    imagePath: string;
    onClose: () => void;
}

export const ImageViewer: React.FC<ImageViewerProps> = ({ imagePath, onClose }) => {
    const isSmallScreen = useMediaQuery((theme: Theme) => theme.breakpoints.down('sm'));

    return (
        <DialogWrapper
            title="Receipt Image"
            open={true}
            onClose={onClose}
        >
            <Box sx={{ bgcolor: 'black', p: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                    <img 
                        src={`/api/images/${imagePath}`}
                        alt="Receipt"
                        style={{
                            maxWidth: '100%',
                            maxHeight: isSmallScreen ? '90vh' : 'calc(90vh - 100px)',
                            objectFit: 'contain'
                        }}
                    />
                </Box>
            </Box>
        </DialogWrapper>
    );
};

================
File: components/JsonViewer.tsx
================
import React from 'react';
import { Paper, Box } from '@mui/material';
import { DialogWrapper } from './common/DialogWrapper';

interface JsonViewerProps {
    data: any;
    onClose: () => void;
}

export const JsonViewer: React.FC<JsonViewerProps> = ({ data, onClose }) => {
    return (
        <DialogWrapper
            title="Receipt Data"
            open={true}
            onClose={onClose}
        >
            <Paper 
                sx={{ 
                    p: 2, 
                    bgcolor: 'grey.100',
                    maxHeight: '60vh',
                    overflow: 'auto'
                }}
            >
                <pre style={{ margin: 0, fontSize: '0.875rem' }}>
                    {JSON.stringify(data, null, 2)}
                </pre>
            </Paper>
        </DialogWrapper>
    );
};

================
File: components/ReceiptDetail.tsx
================
import { useState, useEffect } from 'react';
import { Box, Typography, Paper, Grid, Skeleton } from '@mui/material';
import { fetchReceipt } from '../lib/api/documents';
import ErrorMessage from './common/ErrorMessage';
import { Receipt } from '../types';

interface ReceiptDetailProps {
  receiptId: string | string[] | undefined;
}

export default function ReceiptDetail({ receiptId }: ReceiptDetailProps) {
  const [receipt, setReceipt] = useState<Receipt | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadReceipt = async () => {
      if (!receiptId) return;
      
      try {
        setLoading(true);
        const data = await fetchReceipt(receiptId.toString());
        setReceipt(data);
      } catch (err) {
        setError('Failed to load receipt details');
        console.error('Error loading receipt:', err);
      } finally {
        setLoading(false);
      }
    };

    loadReceipt();
  }, [receiptId]);

  if (loading) {
    return <ReceiptSkeleton />;
  }

  if (error) {
    return <ErrorMessage message={error} />;
  }

  if (!receipt) {
    return <ErrorMessage message="Receipt not found" />;
  }

  return (
    <Paper elevation={2}>
      <Box p={3}>
        <Grid container spacing={3}>
          <Grid item xs={12} md={6}>
            <Typography variant="h5" gutterBottom>
              Receipt Details
            </Typography>
            <Typography>
              <strong>Date:</strong> {new Date(receipt.date).toLocaleDateString()}
            </Typography>
            <Typography>
              <strong>Total Amount:</strong> ${receipt.totalAmount.toFixed(2)}
            </Typography>
            <Typography>
              <strong>Vendor:</strong> {receipt.vendor}
            </Typography>
            <Typography>
              <strong>Category:</strong> {receipt.category}
            </Typography>
          </Grid>
          <Grid item xs={12} md={6}>
            {receipt.imageUrl && (
              <Box
                component="img"
                src={receipt.imageUrl}
                alt="Receipt"
                sx={{
                  maxWidth: '100%',
                  height: 'auto',
                  borderRadius: 1
                }}
              />
            )}
          </Grid>
        </Grid>
      </Box>
    </Paper>
  );
}

const ReceiptSkeleton = () => (
  <Paper elevation={2}>
    <Box p={3}>
      <Grid container spacing={3}>
        <Grid item xs={12} md={6}>
          <Skeleton variant="text" width="60%" height={40} />
          <Skeleton variant="text" width="40%" />
          <Skeleton variant="text" width="40%" />
          <Skeleton variant="text" width="40%" />
        </Grid>
        <Grid item xs={12} md={6}>
          <Skeleton variant="rectangular" width="100%" height={300} />
        </Grid>
      </Grid>
    </Box>
  </Paper>
);

================
File: components/ReceiptList.tsx
================
import React, { useState, useEffect } from 'react';
import { 
    Container, 
    Typography, 
    Paper, 
    Table, 
    TableBody, 
    TableCell, 
    TableContainer, 
    TableHead, 
    TableRow,
    Button,
    Box,
    IconButton,
    CircularProgress,
    Tooltip,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    DialogContentText,
    Checkbox,
    Alert,
    Snackbar
} from '@mui/material';
import UploadIcon from '@mui/icons-material/Upload';
import VisibilityIcon from '@mui/icons-material/Visibility';
import DataObjectIcon from '@mui/icons-material/DataObject';
import DeleteIcon from '@mui/icons-material/Delete';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import { JsonViewer } from '@/components/JsonViewer';
import { ImageViewer } from '@/components/ImageViewer';
import { UploadArea } from './UploadArea';

interface Receipt {
    id: number;
    image_path: string;
    vendor: string;
    amount: string;
    date: string;
    payment_method: string;
    category: string;
    content: any;
}

type SortField = 'vendor' | 'amount' | 'date' | 'payment_method' | 'category';
type SortDirection = 'asc' | 'desc';

export const ReceiptList = () => {
    const [receipts, setReceipts] = useState<Receipt[]>([]);
    const [selectedImage, setSelectedImage] = useState<string | null>(null);
    const [selectedJson, setSelectedJson] = useState<any | null>(null);
    const [isUploading, setIsUploading] = useState(false);
    const [uploadError, setUploadError] = useState<string | null>(null);
    const [deleteConfirmOpen, setDeleteConfirmOpen] = useState<number | null>(null);
    const [isDeleting, setIsDeleting] = useState(false);
    const [sortField, setSortField] = useState<SortField>('date');
    const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
    const [selectedReceipts, setSelectedReceipts] = useState<number[]>([]);
    const [showBulkDeleteConfirm, setShowBulkDeleteConfirm] = useState(false);
    const [bulkActionStatus, setBulkActionStatus] = useState<{
        show: boolean;
        message: string;
        type: 'success' | 'error';
    }>({ show: false, message: '', type: 'success' });

    const fetchReceipts = async () => {
        try {
            const response = await fetch('/api/receipts');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            setReceipts(data);
        } catch (error) {
            console.error('Error fetching receipts:', error);
        }
    };

    useEffect(() => {
        fetchReceipts();
    }, []);

    const handleFileUpload = async (file: File) => {
        console.log('Starting file upload for:', file.name);
        
        // Check file type
        if (!file.type.match(/^image\/(jpeg|png)$/)) {
            const error = 'Invalid file type. Please upload a JPEG or PNG image.';
            console.error(error);
            setUploadError(error);
            return;
        }

        if (file.size > 15 * 1024 * 1024) {
            const error = 'File size too large. Maximum size is 15MB.';
            console.error(error);
            setUploadError(error);
            return;
        }

        setIsUploading(true);
        setUploadError(null);
        const formData = new FormData();
        formData.append('file', file);

        try {
            console.log('Sending request to /api/upload');
            
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            console.log('Upload response status:', response.status);
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Upload failed: ${response.statusText}. ${errorText}`);
            }

            const data = await response.json();
            console.log('Upload response:', data);

            await fetchReceipts();
        } catch (error) {
            const message = error instanceof Error ? error.message : 'Upload failed';
            console.error('Upload error:', error);
            setUploadError(message);
        } finally {
            setIsUploading(false);
        }
    };

    const handleDeleteConfirm = async () => {
        if (deleteConfirmOpen === null) return;

        setIsDeleting(true);
        try {
            const response = await fetch(`/api/receipts/${deleteConfirmOpen}`, {
                method: 'DELETE'
            });

            if (!response.ok) {
                throw new Error(`Failed to delete receipt: ${response.statusText}`);
            }

            await fetchReceipts();
        } catch (error) {
            console.error('Delete error:', error);
        } finally {
            setIsDeleting(false);
            setDeleteConfirmOpen(null);
        }
    };

    const sortReceipts = (receipts: Receipt[]): Receipt[] => {
        return [...receipts].sort((a, b) => {
            const aValue = a[sortField];
            const bValue = b[sortField];
            
            const comparison = sortDirection === 'asc' 
                ? String(aValue).localeCompare(String(bValue))
                : String(bValue).localeCompare(String(aValue));
            
            return comparison;
        });
    };

    const handleSort = (field: SortField) => {
        if (field === sortField) {
            setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
        } else {
            setSortField(field);
            setSortDirection('asc');
        }
    };

    const SortIcon = ({ field }: { field: SortField }) => {
        if (sortField !== field) return (
            <KeyboardArrowUpIcon 
                sx={{ 
                    width: 16, 
                    height: 16, 
                    color: 'text.disabled' 
                }} 
            />
        );
        return sortDirection === 'asc' 
            ? <KeyboardArrowUpIcon sx={{ width: 16, height: 16 }} />
            : <KeyboardArrowDownIcon sx={{ width: 16, height: 16 }} />;
    };

    const handleSelectAll = (event: React.ChangeEvent<HTMLInputElement>) => {
        if (event.target.checked) {
            setSelectedReceipts(receipts.map(receipt => receipt.id));
        } else {
            setSelectedReceipts([]);
        }
    };

    const handleSelectOne = (id: number) => {
        setSelectedReceipts(prev => {
            if (prev.includes(id)) {
                return prev.filter(receiptId => receiptId !== id);
            } else {
                return [...prev, id];
            }
        });
    };

    const handleBulkDelete = async () => {
        setShowBulkDeleteConfirm(false);
        setIsDeleting(true);
        try {
            const results = await Promise.all(
                selectedReceipts.map(id =>
                    fetch(`/api/receipts/${id}`, { method: 'DELETE' })
                    .then(response => ({ id, success: response.ok }))
                )
            );

            const failedDeletes = results.filter(r => !r.success).length;
            
            if (failedDeletes > 0) {
                setBulkActionStatus({
                    show: true,
                    message: `Failed to delete ${failedDeletes} receipts`,
                    type: 'error'
                });
            } else {
                setBulkActionStatus({
                    show: true,
                    message: 'Successfully deleted selected receipts',
                    type: 'success'
                });
            }
            
            // Clear selections and refresh list regardless of success
            setSelectedReceipts([]);
            await fetchReceipts();
            
        } catch (error) {
            console.error('Bulk delete error:', error);
            setBulkActionStatus({
                show: true,
                message: 'Error deleting receipts',
                type: 'error'
            });
            // Still refresh to ensure UI is in sync
            await fetchReceipts();
        } finally {
            setIsDeleting(false);
        }
    };

    return (
        <Container 
            maxWidth={false} 
            disableGutters 
            sx={{ 
                height: '100%',
                maxWidth: '100%',
                boxSizing: 'border-box',
                px: { xs: 2, sm: 3, md: 4 },
                py: { xs: 2, sm: 3 },
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
            }}
        >
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Receipt Organizer
            </Typography>

            <Box sx={{ 
                width: '100%',
                display: 'flex',
                flexDirection: 'column',
                gap: { xs: 2, sm: 4 }
            }}>
                <TableContainer component={Paper}>
                    <UploadArea 
                        onUpload={handleFileUpload} 
                        isUploading={isUploading}
                        error={uploadError}
                    />
                </TableContainer>

                {selectedReceipts.length > 0 && (
                    <Box sx={{ 
                        width: '100%',
                        p: 2,
                        bgcolor: 'primary.light', 
                        borderRadius: 1,
                        display: 'flex',
                        alignItems: 'center',
                        gap: 2
                    }}>
                        <Typography sx={{ color: 'white' }}>
                            {selectedReceipts.length} items selected
                        </Typography>
                        <Button
                            variant="contained"
                            color="error"
                            onClick={() => setShowBulkDeleteConfirm(true)}
                            disabled={isDeleting}
                            size="small"
                        >
                            Delete Selected
                        </Button>
                    </Box>
                )}

                <TableContainer component={Paper} variant="outlined">
                    <Table size="small">
                        <TableHead>
                            <TableRow
                                sx={{
                                    bgcolor: 'grey.50',  // Light grey background
                                    '& th': {  // Target all header cells
                                        borderBottom: '2px solid',
                                        borderColor: 'grey.200',
                                        fontWeight: 600,
                                        color: 'grey.700'
                                    }
                                }}
                            >
                                <TableCell padding="checkbox">
                                    <Checkbox
                                        indeterminate={
                                            selectedReceipts.length > 0 && 
                                            selectedReceipts.length < receipts.length
                                        }
                                        checked={
                                            receipts.length > 0 && 
                                            selectedReceipts.length === receipts.length
                                        }
                                        onChange={handleSelectAll}
                                    />
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('vendor')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Vendor
                                        <SortIcon field="vendor" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('amount')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Amount
                                        <SortIcon field="amount" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('date')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Date
                                        <SortIcon field="date" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('payment_method')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Payment Method
                                        <SortIcon field="payment_method" />
                                    </Box>
                                </TableCell>
                                <TableCell 
                                    onClick={() => handleSort('category')}
                                    sx={{ 
                                        cursor: 'pointer',
                                        userSelect: 'none',
                                        '&:hover': { bgcolor: 'action.hover' }
                                    }}
                                >
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                        Category
                                        <SortIcon field="category" />
                                    </Box>
                                </TableCell>
                                <TableCell align="left">Actions</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {sortReceipts(receipts).map((receipt) => (
                                <TableRow 
                                    key={receipt.id} 
                                    hover
                                    onClick={() => setSelectedImage(receipt.image_path)}
                                    sx={{ 
                                        cursor: 'pointer',
                                        '&:hover': {
                                            bgcolor: 'action.hover',
                                        }
                                    }}
                                >
                                    <TableCell 
                                        padding="checkbox"
                                        onClick={(e) => e.stopPropagation()}
                                    >
                                        <Checkbox
                                            checked={selectedReceipts.includes(receipt.id)}
                                            onChange={() => handleSelectOne(receipt.id)}
                                        />
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.vendor}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.amount}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.date}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.payment_method}
                                    </TableCell>
                                    <TableCell sx={{ 
                                        maxWidth: { xs: '120px', sm: '200px', md: '300px' },
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        whiteSpace: 'nowrap'
                                    }}>
                                        {receipt.category}
                                    </TableCell>
                                    <TableCell 
                                        align="left"
                                        sx={{ 
                                            width: { xs: '140px', sm: '220px' },
                                            pr: { xs: 1, sm: 2 }
                                        }}
                                    >
                                        <Box 
                                            sx={{ 
                                                display: 'flex', 
                                                gap: { xs: 1, sm: 1.5 },
                                                justifyContent: 'flex-start'
                                            }}
                                            onClick={(e) => e.stopPropagation()}
                                        >
                                            <Tooltip title="View Receipt">
                                                <IconButton
                                                    size="small"
                                                    onClick={() => setSelectedImage(receipt.image_path)}
                                                    sx={{ 
                                                        color: 'text.secondary',
                                                        '&:hover': { color: '#2196f3' }
                                                    }}
                                                >
                                                    <VisibilityIcon sx={{ fontSize: 20 }} />
                                                </IconButton>
                                            </Tooltip>
                                            <Tooltip title="View Data">
                                                <IconButton
                                                    size="small"
                                                    onClick={() => setSelectedJson(receipt.content)}
                                                    sx={{ 
                                                        color: 'text.secondary',
                                                        '&:hover': { color: '#2196f3' }
                                                    }}
                                                >
                                                    <DataObjectIcon sx={{ fontSize: 20 }} />
                                                </IconButton>
                                            </Tooltip>
                                            <Tooltip title="Delete">
                                                <IconButton
                                                    size="small"
                                                    onClick={() => setDeleteConfirmOpen(receipt.id)}
                                                    sx={{ 
                                                        color: 'text.secondary',
                                                        '&:hover': { color: '#f44336' }
                                                    }}
                                                >
                                                    <DeleteIcon sx={{ fontSize: 20 }} />
                                                </IconButton>
                                            </Tooltip>
                                        </Box>
                                    </TableCell>
                                </TableRow>
                            ))}
                        </TableBody>
                    </Table>
                </TableContainer>
            </Box>

            {selectedImage && (
                <ImageViewer
                    imagePath={selectedImage}
                    onClose={() => setSelectedImage(null)}
                />
            )}
            {selectedJson && (
                <JsonViewer
                    data={selectedJson}
                    onClose={() => setSelectedJson(null)}
                />
            )}

            <Dialog
                open={deleteConfirmOpen !== null}
                onClose={() => setDeleteConfirmOpen(null)}
            >
                <DialogTitle>
                    Confirm Delete
                </DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Are you sure you want to delete this receipt? This action cannot be undone.
                    </DialogContentText>
                </DialogContent>
                <DialogActions>
                    <Button
                        onClick={() => setDeleteConfirmOpen(null)}
                        color="inherit"
                    >
                        Cancel
                    </Button>
                    <Button
                        onClick={handleDeleteConfirm}
                        color="error"
                        variant="contained"
                        disabled={isDeleting}
                    >
                        {isDeleting ? 'Deleting...' : 'Delete'}
                    </Button>
                </DialogActions>
            </Dialog>

            <Dialog
                open={showBulkDeleteConfirm}
                onClose={() => setShowBulkDeleteConfirm(false)}
            >
                <DialogTitle>
                    Confirm Delete
                </DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        Are you sure you want to delete {selectedReceipts.length} selected receipts? 
                        This action cannot be undone.
                    </DialogContentText>
                </DialogContent>
                <DialogActions>
                    <Button
                        onClick={() => setShowBulkDeleteConfirm(false)}
                        color="inherit"
                    >
                        Cancel
                    </Button>
                    <Button
                        onClick={handleBulkDelete}
                        color="error"
                        variant="contained"
                        disabled={isDeleting}
                    >
                        {isDeleting ? 'Deleting...' : 'Delete'}
                    </Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={bulkActionStatus.show}
                autoHideDuration={6000}
                onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
            >
                <Alert 
                    severity={bulkActionStatus.type}
                    onClose={() => setBulkActionStatus(prev => ({ ...prev, show: false }))}
                >
                    {bulkActionStatus.message}
                </Alert>
            </Snackbar>
        </Container>
    );
};

export default ReceiptList;

================
File: components/ReceiptTable.tsx
================
import React from 'react';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    IconButton,
    Box,
    Tooltip
} from '@mui/material';
import VisibilityIcon from '@mui/icons-material/Visibility';
import DataObjectIcon from '@mui/icons-material/DataObject';
import DeleteIcon from '@mui/icons-material/Delete';
import { Receipt } from '@/types';

interface ReceiptTableProps {
    receipts: Receipt[];
    onViewImage: (imagePath: string) => void;
    onViewJson: (content: any) => void;
    onDelete: (id: number) => void;
}

export const ReceiptTable: React.FC<ReceiptTableProps> = ({
    receipts,
    onViewImage,
    onViewJson,
    onDelete
}) => {
    return (
        <TableContainer component={Paper}>
            <Table size="small">
                <TableHead>
                    <TableRow>
                        <TableCell>Vendor</TableCell>
                        <TableCell>Amount</TableCell>
                        <TableCell>Date</TableCell>
                        <TableCell>Payment Method</TableCell>
                        <TableCell>Category</TableCell>
                        <TableCell align="right">Actions</TableCell>
                    </TableRow>
                </TableHead>
                <TableBody>
                    {receipts.map((receipt) => (
                        <TableRow key={receipt.id}>
                            <TableCell>{receipt.vendor}</TableCell>
                            <TableCell>{receipt.amount}</TableCell>
                            <TableCell>{receipt.date}</TableCell>
                            <TableCell>{receipt.payment_method}</TableCell>
                            <TableCell>{receipt.category}</TableCell>
                            <TableCell align="right">
                                <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
                                    {receipt.image_path && (
                                        <Tooltip title="View Receipt">
                                            <IconButton
                                                size="small"
                                                onClick={() => onViewImage(receipt.image_path!)}
                                            >
                                                <VisibilityIcon fontSize="small" />
                                            </IconButton>
                                        </Tooltip>
                                    )}
                                    {receipt.content && (
                                        <Tooltip title="View Data">
                                            <IconButton
                                                size="small"
                                                onClick={() => onViewJson(receipt.content)}
                                            >
                                                <DataObjectIcon fontSize="small" />
                                            </IconButton>
                                        </Tooltip>
                                    )}
                                    <Tooltip title="Delete">
                                        <IconButton
                                            size="small"
                                            onClick={() => onDelete(receipt.id)}
                                        >
                                            <DeleteIcon fontSize="small" />
                                        </IconButton>
                                    </Tooltip>
                                </Box>
                            </TableCell>
                        </TableRow>
                    ))}
                </TableBody>
            </Table>
        </TableContainer>
    );
};

================
File: components/ReceiptUploader.tsx
================
import React, { useCallback, useState, useEffect } from 'react';
import { 
    Box, 
    Typography, 
    LinearProgress, 
    Button,
    styled
} from '@mui/material';
import UploadIcon from '@mui/icons-material/Upload';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import ErrorIcon from '@mui/icons-material/Error';
import { ReceiptTable } from './common';
import { ImageViewer } from './ImageViewer';
import { JsonViewer } from './JsonViewer';
import { Receipt } from '@/types';

const HiddenInput = styled('input')({
    display: 'none'
});

export const ReceiptUploader: React.FC = () => {
    const [isDragging, setIsDragging] = useState(false);
    const [uploadProgress, setUploadProgress] = useState(0);
    const [uploadStatus, setUploadStatus] = useState<'idle' | 'uploading' | 'success' | 'error'>('idle');
    const [fileName, setFileName] = useState("");
    const [receipts, setReceipts] = useState<Receipt[]>([]);
    const [selectedImage, setSelectedImage] = useState<string | null>(null);
    const [selectedJson, setSelectedJson] = useState<any | null>(null);
    const [uploadError, setUploadError] = useState<string | null>(null);
    const [deleteConfirmOpen, setDeleteConfirmOpen] = useState<number | null>(null);

    // Fetch receipts on component mount
    useEffect(() => {
        fetchReceipts();
    }, []);

    const fetchReceipts = async () => {
        try {
            const response = await fetch('/api/receipts');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            setReceipts(data);
        } catch (error) {
            console.error('Error fetching receipts:', error);
        }
    };

    const handleDragEnter = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    }, []);

    const handleDragLeave = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    }, []);

    const handleDragOver = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
    }, []);

    const validateFile = (file: File) => {
        const validTypes = ['image/jpeg', 'image/png'];
        if (!validTypes.includes(file.type)) {
            setUploadError('Only JPEG and PNG files are supported');
            setUploadStatus('error');
            return false;
        }
        return true;
    };

    const handleDrop = useCallback(async (e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
        
        const files = e.dataTransfer.files;
        if (files.length) {
            const file = files[0];
            if (validateFile(file)) {
                await handleUpload(file);
            }
        }
    }, []);

    const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file && validateFile(file)) {
            await handleUpload(file);
        }
    };

    const handleUpload = async (file: File) => {
        setFileName(file.name);
        setUploadStatus('uploading');
        setUploadProgress(0);
        setUploadError(null);

        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error(`Upload failed: ${response.statusText}`);
            }

            setUploadStatus('success');
            setUploadProgress(100);
            await fetchReceipts(); // Refresh the list after successful upload
        } catch (error) {
            console.error('Upload error:', error);
            setUploadStatus('error');
            setUploadError(error instanceof Error ? error.message : 'Upload failed');
        }
    };

    return (
        <>
            <Box
                sx={{
                    position: 'relative',
                    width: '100%',
                    height: '256px', // equivalent to h-64
                    borderRadius: 2,
                    border: '2px dashed',
                    borderColor: theme => {
                        if (uploadStatus === "success") return 'success.main';
                        if (uploadStatus === "error") return 'error.main';
                        return isDragging ? 'primary.main' : 'divider';
                    },
                    bgcolor: theme => {
                        if (uploadStatus === "success") return 'success.light';
                        if (uploadStatus === "error") return 'error.light';
                        return isDragging ? 'primary.light' : 'grey.50';
                    },
                    transition: 'all 0.2s ease-in-out',
                    cursor: 'pointer'
                }}
                onDragEnter={handleDragEnter}
                onDragOver={handleDragOver}
                onDragLeave={handleDragLeave}
                onDrop={handleDrop}
                role="button"
                tabIndex={0}
                aria-label="Upload receipt"
            >
                <Box
                    sx={{
                        position: 'absolute',
                        inset: 0,
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        justifyContent: 'center',
                        p: 3,
                        textAlign: 'center'
                    }}
                >
                    <Box sx={{ 
                        mb: 2,
                        color: theme => {
                            if (uploadStatus === "success") return 'success.main';
                            if (uploadStatus === "error") return 'error.main';
                            return isDragging ? 'primary.main' : 'text.secondary';
                        }
                    }}>
                        {uploadStatus === "success" ? <CheckCircleIcon sx={{ fontSize: 48 }} />
                            : uploadStatus === "error" ? <ErrorIcon sx={{ fontSize: 48 }} />
                            : <UploadIcon sx={{ fontSize: 48 }} />
                        }
                    </Box>

                    <Typography 
                        variant="h6" 
                        sx={{ mb: 1, color: 'text.primary' }}
                    >
                        {uploadStatus === "success" ? "Upload Complete!"
                            : uploadStatus === "error" ? "Upload Failed"
                            : "Drag and drop your receipt here"}
                    </Typography>

                    <Typography 
                        variant="body2" 
                        sx={{ mb: 2, color: 'text.secondary' }}
                    >
                        {uploadStatus === "error" ? uploadError
                            : "Or click to browse files (JPEG, PNG)"}
                    </Typography>

                    {uploadStatus === 'idle' && (
                        <label>
                            <HiddenInput
                                type="file"
                                accept="image/jpeg,image/png"
                                onChange={handleFileSelect}
                            />
                            <Button
                                variant="contained"
                                component="span"
                                startIcon={<UploadIcon />}
                            >
                                Browse Files
                            </Button>
                        </label>
                    )}
                </Box>
            </Box>

            {uploadStatus === 'uploading' && (
                <Box sx={{ mt: 2 }}>
                    <Box sx={{ 
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        mb: 1 
                    }}>
                        <Typography variant="body2" color="text.secondary">
                            {fileName}
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                            {uploadProgress}%
                        </Typography>
                    </Box>
                    <LinearProgress 
                        variant="determinate" 
                        value={uploadProgress}
                        sx={{ height: 8, borderRadius: 1 }}
                    />
                </Box>
            )}

            <Box sx={{ mt: 4 }}>
                <ReceiptTable 
                    receipts={receipts}
                    onViewImage={setSelectedImage}
                    onViewJson={setSelectedJson}
                    onDelete={setDeleteConfirmOpen}
                />
            </Box>

            {selectedImage && (
                <ImageViewer
                    imagePath={selectedImage}
                    onClose={() => setSelectedImage(null)}
                />
            )}
            
            {selectedJson && (
                <JsonViewer
                    data={selectedJson}
                    onClose={() => setSelectedJson(null)}
                />
            )}
        </>
    );
};

export default ReceiptUploader;

================
File: components/UploadArea.tsx
================
import React from 'react';
import { 
    Paper, 
    Box, 
    Typography, 
    Button, 
    LinearProgress, 
    Alert 
} from '@mui/material';
import UploadIcon from '@mui/icons-material/Upload';
import { useDropzone } from 'react-dropzone';

interface UploadAreaProps {
    onUpload: (file: File) => Promise<void>;
    isUploading: boolean;
    error?: string | null;
}

export const UploadArea: React.FC<UploadAreaProps> = ({ onUpload, isUploading, error }) => {
    const { getRootProps, getInputProps, isDragActive } = useDropzone({
        accept: {
            'image/jpeg': ['.jpg', '.jpeg'],
            'image/png': ['.png']
        },
        multiple: false,
        disabled: isUploading,
        onDrop: async (acceptedFiles) => {
            if (acceptedFiles?.[0]) {
                await onUpload(acceptedFiles[0]);
            }
        }
    });

    return (
        <Paper 
            {...getRootProps()}
            variant="outlined" 
            sx={{ 
                p: { xs: 1.5, sm: 2, md: 4 },
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: { xs: 1, sm: 2 },
                borderStyle: 'dashed',
                position: 'relative',
                cursor: 'pointer',
                borderColor: isDragActive ? 'primary.main' : 'divider',
                bgcolor: isDragActive ? 'action.hover' : 'background.paper',
                transition: 'all 0.2s ease',
                '&:hover': {
                    borderColor: 'primary.main',
                    bgcolor: 'action.hover'
                }
            }}
        >
            <input {...getInputProps()} />
            
            {isUploading && (
                <LinearProgress 
                    sx={{ 
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        borderTopLeftRadius: 'inherit',
                        borderTopRightRadius: 'inherit'
                    }}
                />
            )}
            
            <Box 
                sx={{ 
                    bgcolor: 'action.hover',
                    borderRadius: '50%',
                    p: { xs: 1.5, sm: 2 },
                    display: 'flex'
                }}
            >
                <UploadIcon />
            </Box>

            <Button
                variant="contained"
                component="span"
                startIcon={<UploadIcon />}
                disabled={isUploading}
                sx={{
                    width: { xs: '100%', sm: 'auto' },
                    minHeight: { xs: 40, sm: 36 },
                    fontSize: { xs: '0.8125rem', sm: '0.875rem' }
                }}
            >
                {isUploading ? 'Uploading...' : 'Upload Receipt'}
            </Button>

            <Typography 
                variant="body2" 
                color="text.secondary"
                align="center"
                sx={{ 
                    fontSize: { xs: '0.75rem', sm: '0.875rem' }
                }}
            >
                {isDragActive 
                    ? 'Drop the receipt here...'
                    : isUploading 
                        ? 'Processing your receipt...' 
                        : 'Supported formats: JPEG, PNG'
                }
            </Typography>

            {error && (
                <Alert 
                    severity="error" 
                    sx={{ 
                        width: '100%',
                        mt: { xs: 1, sm: 2 }
                    }}
                >
                    {error}
                </Alert>
            )}
        </Paper>
    );
};

================
File: config/index.ts
================
export const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3456';

export const CONFIG = {
    API: {
        BASE_URL: API_BASE_URL,
        TIMEOUT: parseInt(process.env.NEXT_PUBLIC_API_TIMEOUT || '120000', 10)
    }
} as const;

================
File: contexts/AppContext.tsx
================
import React, { createContext, useContext } from 'react';
import { useSearch } from '../hooks/useSearch';
import { useDocumentManagement } from '../hooks/useDocumentManagement';
import { Receipt } from '@/types';

interface AppContextType {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  documents: {
    uploadReceipt: (file: File) => Promise<Receipt>;
    getReceipts: () => Promise<Receipt[]>;
    deleteReceipt: (id: number) => Promise<void>;
    fetchReceipt: (id: string | string[]) => Promise<Receipt>;
  };
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AppContextProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const search = useSearch();
  const documents = useDocumentManagement();

  const value = {
    ...search,
    documents
  };

  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useAppContext must be used within an AppContextProvider');
  }
  return context;
};

================
File: contexts/index.ts
================
export * from './SearchContext';

================
File: contexts/SearchContext.tsx
================
import React, { createContext, useContext, useState } from 'react';

interface SearchContextType {
    searchQuery: string;
    setSearchQuery: (query: string) => void;
}

const SearchContext = createContext<SearchContextType | undefined>(undefined);

export const SearchProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [searchQuery, setSearchQuery] = useState('');

    return (
        <SearchContext.Provider value={{ searchQuery, setSearchQuery }}>
            {children}
        </SearchContext.Provider>
    );
};

export const useSearch = () => {
    const context = useContext(SearchContext);
    if (context === undefined) {
        throw new Error('useSearch must be used within a SearchProvider');
    }
    return context;
};

================
File: hooks/useDocumentManagement.ts
================
import { useCallback } from 'react';
import { documentsApi } from '../lib/api/documents';
import { Receipt } from '@/types';

interface DocumentManagement {
  uploadReceipt: (file: File) => Promise<Receipt>;
  getReceipts: () => Promise<Receipt[]>;
  deleteReceipt: (id: number) => Promise<void>;
  fetchReceipt: (id: string | string[]) => Promise<Receipt>;
}

export const useDocumentManagement = (): DocumentManagement => {
  const uploadReceipt = useCallback(async (file: File) => {
    const response = await documentsApi.uploadDocument(file, 'Expenses');
    return response as Receipt;
  }, []);

  const getReceipts = useCallback(async () => {
    const documents = await documentsApi.getDocuments('Expenses');
    return documents.map(doc => doc.originalReceipt as Receipt).filter(Boolean);
  }, []);

  const deleteReceipt = useCallback(async (id: number) => {
    try {
        await documentsApi.deleteDocument(id.toString());
    } catch (error) {
        console.error('Delete error:', error);
        throw new Error('Failed to delete receipt. Please try again.');
    }
  }, []);

  const fetchReceipt = useCallback(async (id: string | string[]) => {
    const receiptId = Array.isArray(id) ? id[0] : id;
    return documentsApi.fetchReceipt(receiptId);
  }, []);

  return {
    uploadReceipt,
    getReceipts,
    deleteReceipt,
    fetchReceipt
  };
};

================
File: hooks/useSearch.ts
================
import { useState, useCallback } from 'react';

export const useSearch = () => {
  const [searchQuery, setSearchQuery] = useState('');

  const handleSearch = useCallback((query: string) => {
    setSearchQuery(query);
  }, []);

  return {
    searchQuery,
    setSearchQuery: handleSearch
  };
};

================
File: lib/api/documents.ts
================
import { Document, DocumentType, Receipt } from '@/types';
import { API_BASE_URL } from '@/config';
import { format, parse, isValid } from 'date-fns';
import { enUS } from 'date-fns/locale';

// Mock data for testing (excluding Expenses)
const mockDocuments: Document[] = [
    {
        id: '1',
        type: 'W-2',
        employer: 'Tech Corp',
        wages: 85000,
        fedWithholding: 15000,
        status: 'pending',
        uploadDate: '2024-01-15'
    },
    {
        id: '2',
        type: '1099',
        employer: 'Freelance Inc',
        nonEmpCompensation: 25000,
        status: 'approved',
        uploadDate: '2024-02-01'
    },
    {
        id: '4',
        type: 'Donations',
        date: '2024-01-30',
        charityName: 'Local Food Bank',
        donationType: 'Cash',
        amount: 1000,
        status: 'approved',
        uploadDate: '2024-02-01'
    }
];

const transformDate = (dateStr: string): string => {
    if (!dateStr || dateStr === 'N/A' || dateStr.toLowerCase() === 'n/a') {
        console.log('documentsApi.transformDate: Empty or N/A date:', dateStr);
        return '';
    }
    
    console.log('documentsApi.transformDate: Processing date:', dateStr);
    
    try {
        // Clean up the date string first
        const cleanDate = dateStr.replace(/['"]/g, '').trim();
        if (!cleanDate) {
            console.log('documentsApi.transformDate: Empty date after cleanup');
            return '';
        }

        // Array of possible date formats to try
        const formats = [
            'MM/dd/yy',
            'MM/dd/yyyy',
            'dd MMM \'yy HH:mm a',
            'dd MMM yyyy HH:mm a',
            'yyyy-MM-dd',
            'MM-dd-yyyy',
            'dd-MM-yyyy',
            'dd MMM yyyy',
            'MMM dd yyyy',
            'dd/MM/yyyy',
            'dd/MM/yy'
        ];

        // Try each format
        for (const fmt of formats) {
            try {
                const date = parse(cleanDate, fmt, new Date(), { locale: enUS });
                if (isValid(date)) {
                    const result = format(date, 'yyyy-MM-dd', { locale: enUS });
                    console.log('documentsApi.transformDate: Successfully parsed date:', {
                        input: dateStr,
                        cleaned: cleanDate,
                        format: fmt,
                        result
                    });
                    return result;
                }
            } catch (e) {
                // Continue to next format if this one fails
                continue;
            }
        }
        
        console.warn('documentsApi.transformDate: Could not parse date with any format:', {
            original: dateStr,
            cleaned: cleanDate
        });
        return '';
    } catch (e) {
        console.error('documentsApi.transformDate: Error transforming date:', {
            error: e,
            input: dateStr
        });
        return '';
    }
};

export const documentsApi = {
    async getDocuments(type: DocumentType) {
        // For Expenses, use the existing receipts API
        if (type === 'Expenses') {
            const response = await fetch('/api/receipts');
            if (!response.ok) {
                throw new Error('Failed to fetch expenses');
            }
            const receipts = await response.json();
            console.log('documentsApi.getDocuments: Raw receipts from API:', receipts);
            
            // Transform receipt data to match Document interface
            return receipts.map((receipt: any) => {
                console.log('documentsApi.getDocuments: Processing receipt:', receipt);
                const transformed = {
                    id: receipt.id.toString(),
                    type: 'Expenses' as const,
                    vendor: receipt.vendor,
                    amount: receipt.amount,
                    date: transformDate(receipt.date),
                    payment_method: receipt.payment_method || 'Unknown',
                    expenseType: receipt.category || 'Uncategorized',
                    status: receipt.status || 'pending',
                    uploadDate: transformDate(receipt.date),
                    image_path: receipt.image_path,
                    content: receipt.content,
                    originalReceipt: receipt
                };
                console.log('documentsApi.getDocuments: Transformed receipt:', transformed);
                return transformed;
            });
        }

        // For other document types, use mock data
        await new Promise(resolve => setTimeout(resolve, 500));
        return mockDocuments.filter(doc => doc.type === type);
    },

    async uploadDocument(file: File, type: DocumentType) {
        // For Expenses, use the existing upload API
        if (type === 'Expenses') {
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to upload expense');
            }

            return await response.json();
        }

        // For other document types, use mock upload
        await new Promise(resolve => setTimeout(resolve, 1500));
        return { success: true };
    },

    async approveDocument(id: string, type: DocumentType) {
        // Mock approval for all document types for now
        await new Promise(resolve => setTimeout(resolve, 500));
        console.log(`Mocked approval for ${type} document ${id}`);
        return { success: true };
    },

    async deleteDocument(id: string) {
        try {
            // Use the correct API endpoint without the base URL since it's handled by Next.js
            const response = await fetch(`/api/receipts/${id}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
            });

            if (!response.ok) {
                throw new Error(`Failed to delete document: ${response.statusText}`);
            }

            return;
        } catch (error) {
            console.error('Error deleting document:', error);
            throw new Error('Failed to delete the selected items. Please try again.');
        }
    },

    async deleteDocuments(ids: string[]) {
        try {
            await Promise.all(
                ids.map(id => this.deleteDocument(id))
            );
        } catch (error) {
            console.error('Error deleting documents:', error);
            throw error;
        }
    }
};

export async function fetchReceipt(id: string): Promise<Receipt> {
  const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/receipts/${id}`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch receipt');
  }
  
  return response.json();
} 

export const updateDocument = async (
  receiptId: number,
  updates: Partial<Document>
): Promise<Document> => {
  const response = await fetch(`/api/receipts/${receiptId}/update`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(updates),
  });

  if (!response.ok) {
    const error = await response.json();
    console.error("Update failed:", error);
    throw new Error(error.message || `Failed to update document: ${error.details ? JSON.stringify(error.details) : 'Unknown error'}`);
  }

  const data = await response.json();
  return data.receipt;
};

================
File: lib/api.ts
================
import { CONFIG } from '@/config';

export const api = {
    async uploadReceipt(file: File) {
        const formData = new FormData();
        formData.append('file', file);

        const response = await fetch('/api/upload', {
            method: 'POST',
            body: formData,
            signal: AbortSignal.timeout(CONFIG.TIMEOUTS.UPLOAD)
        });

        if (!response.ok) {
            throw new Error(`Upload failed: ${response.statusText}`);
        }

        return response.json();
    },

    async getReceipts() {
        const response = await fetch('/api/receipts');
        if (!response.ok) {
            throw new Error(`Failed to fetch receipts: ${response.statusText}`);
        }
        return response.json();
    },

    async deleteReceipt(id: number) {
        const response = await fetch(`/api/receipts/${id}`, {
            method: 'DELETE'
        });
        if (!response.ok) {
            throw new Error(`Failed to delete receipt: ${response.statusText}`);
        }
        return response.json();
    },

    async fetchReceipt(id: string) {
        const response = await fetch(`/api/receipts/${id}`);
        
        if (!response.ok) {
            throw new Error('Failed to fetch receipt');
        }
        
        return response.json();
    }
};

================
File: lib/createEmotionCache.ts
================
import createCache from '@emotion/cache';

export default function createEmotionCache() {
  return createCache({ key: 'css', prepend: true });
}

================
File: pages/receipt/[id].tsx
================
import { useRouter } from 'next/router';
import ReceiptDetail from '../../components/ReceiptDetail';
import { Box } from '@mui/material';
import LoadingSpinner from '../../components/common/LoadingSpinner';

export default function ReceiptPage() {
  const router = useRouter();
  
  // Wait for the router to be ready and have query parameters
  if (!router.isReady) {
    return <LoadingSpinner />;
  }

  const { id } = router.query;

  return (
    <Box sx={{ p: 3 }}>
      <ReceiptDetail receiptId={id} />
    </Box>
  );
}

================
File: pages/_app.tsx
================
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import type { AppProps } from 'next/app';
import { ErrorBoundary } from '../components/ErrorBoundary';
import { Layout } from '../components/Layout/Layout';
import { theme } from '../styles/theme';
import { CacheProvider } from '@emotion/react';
import createEmotionCache from '../lib/createEmotionCache';
import { SearchProvider } from '../contexts/SearchContext';
import { AppContextProvider } from '../contexts/AppContext';

function MyApp({ Component, pageProps }: AppProps) {
    const clientSideEmotionCache = createEmotionCache();

    return (
        <CacheProvider value={clientSideEmotionCache}>
            <ThemeProvider theme={theme}>
                <SearchProvider>
                    <AppContextProvider>
                        <ErrorBoundary>
                            <Layout>
                                <Component {...pageProps} />
                            </Layout>
                        </ErrorBoundary>
                    </AppContextProvider>
                </SearchProvider>
            </ThemeProvider>
        </CacheProvider>
    );
}

export default MyApp;

================
File: pages/1040.tsx
================
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';

const Form1040Page: React.FC = () => {
    return (
        <Box sx={{ 
            height: '100%',
            width: '100%',
            position: 'absolute',
            top: 0,
            left: 0,
            overflow: 'auto',
            px: { xs: 2, sm: 3, md: 4 },
            py: { xs: 2, sm: 3 },
        }}>
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Form 1040
            </Typography>
            <Paper sx={{ p: 4 }}>
                <Typography>
                    Your Form 1040 preparation area. This feature is coming soon.
                </Typography>
            </Paper>
        </Box>
    );
};

export default Form1040Page;

================
File: pages/dashboard.tsx
================
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';

const DashboardPage: React.FC = () => {
    return (
        <Box sx={{ 
            height: '100%',
            width: '100%',
            position: 'absolute',
            top: 0,
            left: 0,
            overflow: 'auto',
            px: { xs: 2, sm: 3, md: 4 },
            py: { xs: 2, sm: 3 },
        }}>
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Dashboard
            </Typography>
            <Paper sx={{ p: 4 }}>
                <Typography>
                    Welcome to your tax dashboard. This feature is coming soon.
                </Typography>
            </Paper>
        </Box>
    );
};

export default DashboardPage;

================
File: pages/documents.tsx
================
import React, { useState } from 'react';
import { Box, Container } from '@mui/material';
import { DocumentsTabs } from '@/components/Documents/DocumentsTabs';
import { DocumentsTable } from '@/components/Documents/DocumentsTable';
import { DocumentUploadArea } from '@/components/Documents/DocumentUploadArea';
import { DocumentUploadFab } from '@/components/Documents/DocumentUploadFab';
import { DocumentType } from '@/types';
import { DocumentFilter } from '@/types/filters';

const DocumentsPage: React.FC = () => {
    const [activeTab, setActiveTab] = useState<DocumentType>('W-2');
    const [refreshTrigger, setRefreshTrigger] = useState(0);
    
    // Persistent filters for each document type
    const [filters, setFilters] = useState<Record<DocumentType, DocumentFilter>>({
        'W-2': {},
        '1099': {},
        'Expenses': {},
        'Donations': {}
    });

    const handleTabChange = (tab: DocumentType) => {
        setActiveTab(tab);
    };

    const handleFilterChange = (newFilters: DocumentFilter) => {
        setFilters(prev => ({
            ...prev,
            [activeTab]: newFilters
        }));
    };

    const handleUploadComplete = () => {
        setRefreshTrigger(prev => prev + 1);
    };

    return (
        <Box 
            sx={{ 
                height: '100%',
                width: '100%',
                position: 'absolute',
                top: 0,
                left: 0,
                overflow: 'auto'
            }}
        >
            <Container maxWidth={false} sx={{ py: 3 }}>
                <DocumentsTabs 
                    activeTab={activeTab}
                    onTabChange={handleTabChange}
                />

                <DocumentUploadArea 
                    activeTab={activeTab}
                    onUploadComplete={handleUploadComplete}
                />

                <DocumentsTable 
                    type={activeTab}
                    filters={filters[activeTab]}
                    onFilterChange={handleFilterChange}
                    key={refreshTrigger}
                />

                <DocumentUploadFab />
            </Container>
        </Box>
    );
};

export default DocumentsPage;

================
File: pages/index.tsx
================
import { useEffect } from 'react';
import { useRouter } from 'next/router';

export default function HomePage() {
    const router = useRouter();

    useEffect(() => {
        router.replace('/dashboard');
    }, [router]);

    return null;
}

================
File: pages/profile.tsx
================
import React from 'react';
import { Box, Typography, Paper } from '@mui/material';

const ProfilePage: React.FC = () => {
    return (
        <Box sx={{ 
            height: '100%',
            width: '100%',
            position: 'absolute',
            top: 0,
            left: 0,
            overflow: 'auto',
            px: { xs: 2, sm: 3, md: 4 },
            py: { xs: 2, sm: 3 },
        }}>
            <Typography 
                variant="h4" 
                component="h1" 
                gutterBottom
                sx={{ 
                    fontSize: { xs: '1.25rem', sm: '1.5rem', md: '2rem' },
                    mb: { xs: 2, sm: 4 },
                    textTransform: 'uppercase'
                }}
            >
                Profile
            </Typography>
            <Paper sx={{ p: 4 }}>
                <Typography>
                    Your profile settings and preferences. This feature is coming soon.
                </Typography>
            </Paper>
        </Box>
    );
};

export default ProfilePage;

================
File: styles/globals.css
================
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
}

================
File: styles/theme.ts
================
import { createTheme } from '@mui/material/styles';

export const theme = createTheme({
  typography: {
    fontFamily: 'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: {
        '@keyframes fadeIn': {
          from: { opacity: 0 },
          to: { opacity: 1 },
        },
        '@keyframes slideIn': {
          from: {
            transform: 'translateY(20px)',
            opacity: 0,
          },
          to: {
            transform: 'translateY(0)',
            opacity: 1,
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          transition: 'all 0.2s ease-in-out',
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: 8,
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        root: {
          padding: '12px 16px',
        },
        head: {
          fontWeight: 600,
          backgroundColor: 'rgba(0, 0, 0, 0.02)',
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: '#ffffff',
          color: 'inherit',
          borderRadius: 0,
        }
      }
    },
    MuiToolbar: {
      styleOverrides: {
        root: {
          borderRadius: 0,
          '@media (min-width: 600px)': {
            minHeight: '64px',
            padding: '0 24px',
          },
          '@media (max-width: 599px)': {
            minHeight: '48px',
            padding: '0 16px',
          }
        }
      }
    }
  },
  palette: {
    background: {
      default: '#f8f9fa',
    },
    text: {
      primary: 'rgba(0, 0, 0, 0.87)',
      secondary: 'rgba(0, 0, 0, 0.6)',
    },
  },
});

================
File: types/documents.ts
================
export type DocumentType = 'W-2' | '1099' | 'Expenses' | 'Donations';
export type DocumentStatus = 'Pending' | 'Approved' | 'Rejected' | 'all';

interface BaseDocument {
    id: string;
    type: DocumentType;
    status: Exclude<DocumentStatus, 'all'>;
    uploadDate: string;
}

export interface W2Document extends BaseDocument {
    type: 'W-2';
    employer: string;
    wages: number;
    fedWithholding: number;
}

export interface Form1099Document extends BaseDocument {
    type: '1099';
    employer: string;
    nonEmpCompensation: number;
}

export interface ExpenseDocument extends BaseDocument {
    type: 'Expenses';
    vendor: string;
    amount: number;
    date: string;
    payment_method: string;
    category: string;
    originalReceipt?: {
        image_path: string;
        [key: string]: any;
    };
}

export interface DonationDocument extends BaseDocument {
    type: 'Donations';
    date: string;
    charityName: string;
    donationType: string;
    amount: number;
}

export type Document = W2Document | Form1099Document | ExpenseDocument | DonationDocument;

================
File: types/filters.ts
================
import { DocumentType } from './index';

export interface BaseFilter {
  type: DocumentType;
  status?: string[];
  dateRange?: {
    start: string;
    end: string;
  };
}

export interface W2Filter extends BaseFilter {
  type: 'W-2';
  employer?: string[];
  wageRange?: {
    min: number;
    max: number;
  };
}

export interface Form1099Filter extends BaseFilter {
  type: '1099';
  employer?: string[];
  amountRange?: {
    min: number;
    max: number;
  };
}

export interface ExpenseFilter extends BaseFilter {
  type: 'Expenses';
  vendor?: string[];
  amountRange?: {
    min: number;
    max: number;
  };
  paymentMethod?: string[];
  category?: string[];
}

export interface DonationFilter extends BaseFilter {
  type: 'Donations';
  charityName?: string[];
  amountRange?: {
    min: number;
    max: number;
  };
  donationType?: string[];
}

export type DocumentFilter = W2Filter | Form1099Filter | ExpenseFilter | DonationFilter;

================
File: types/index.ts
================
// Document Types
export type DocumentType = 'W-2' | '1099' | 'Expenses' | 'Donations';
export type DocumentStatus = 'pending' | 'processed' | 'error';

// Receipt Types
export interface ReceiptItem {
    name: string;
    price: number;
    quantity: number;
}

export interface Receipt {
    id: number;
    date: string;
    totalAmount: number;
    vendor: string;
    category: string;
    imageUrl?: string;
    image_path?: string;
    items?: Array<{
        description: string;
        amount: number;
    }>;
    content?: any;
    payment_method?: string;
    amount?: string | number;
    replace?: never;
}

// Document Interfaces
export interface BaseDocument {
    id: number;
    type: DocumentType;
    status: DocumentStatus;
    uploadDate: string;
}

export interface W2Document extends BaseDocument {
    type: 'W-2';
    employer: string;
    wages: number;
    fedWithholding: number;
}

export interface Form1099Document extends BaseDocument {
    type: '1099';
    employer: string;
    nonEmpCompensation: number;
}

export interface ExpenseDocument extends BaseDocument {
    type: 'Expenses';
    vendor: string;
    amount: number;
    date: string;
    payment_method: string;
    expenseType: string;
}

export interface DonationDocument extends BaseDocument {
    type: 'Donations';
    charityName: string;
    amount: number;
    donationType: string;
    date: string;
}

export type Document = W2Document | Form1099Document | ExpenseDocument | DonationDocument;

// Search Types
export interface SearchResult {
    id: string;
    type: string;
    name: string;
    group: string;
}

================
File: .env.development
================
NEXT_PUBLIC_API_URL=http://localhost:3456
NEXT_PUBLIC_API_TIMEOUT=120000
NODE_OPTIONS=--max-http-header-size=81920

================
File: .eslintrc.js
================
module.exports = {
  extends: [
    'next/core-web-vitals',
    'plugin:@typescript-eslint/recommended',
    'prettier'
  ],
  rules: {
    '@typescript-eslint/no-unused-vars': ['error'],
    '@typescript-eslint/no-explicit-any': ['warn'],
    'react/prop-types': 'off'
  }
};

================
File: .gitignore
================
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: config.ts
================
export const CONFIG = {
    TIMEOUTS: {
        UPLOAD: 120000,  // 2 minutes in milliseconds
        SERVER: 120000,
        PROXY: 120000
    }
} as const;

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,
    async rewrites() {
        return [
            {
                source: '/api/:path*',
                destination: 'http://localhost:3456/api/:path*',
            }
        ];
    },
    api: {
        bodyParser: {
            sizeLimit: '16mb',
        },
        responseLimit: '16mb',
    },
    httpAgentOptions: {
        keepAlive: true,
        timeout: 120000, // 120 seconds to match Flask's timeout
    },
};

module.exports = nextConfig;

================
File: package.json
================
{
  "name": "receipt-scanner-frontend",
  "version": "1.0.0",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@emotion/cache": "^11.14.0",
    "@emotion/react": "^11.11.3",
    "@emotion/server": "^11.11.0",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.16.11",
    "@mui/material": "^5.x.x",
    "@mui/x-date-pickers": "^6.18.6",
    "date-fns": "^2.30.0",
    "next": "^14.x.x",
    "react": "^18.x.x",
    "react-dom": "^18.x.x",
    "react-dropzone": "^14.2.3"
  },
  "devDependencies": {
    "@types/node": "^20.10.6",
    "@types/react": "^18.2.46",
    "@types/react-dom": "^18.2.18",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.0.0",
    "eslint-config-next": "^14.0.4",
    "typescript": "^5.3.3"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"],
      "@components/*": ["components/*"],
      "@styles/*": ["styles/*"],
      "@types/*": ["types/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}
